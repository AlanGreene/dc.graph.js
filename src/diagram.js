/**
 * `dc_graph.diagram` is a dc.js-compatible network visualization component. It registers in
 * the dc.js chart registry and its nodes and edges are generated from crossfilter groups. It
 * logically derives from the dc.js
 * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin},
 * but it does not physically derive from it since so much is different about network
 * visualization versus conventional charts.
 * @name diagram
 * @memberof dc_graph
 * @param {String|node} parent - Any valid
 * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector}
 * specifying a dom block element such as a div; or a dom element.
 * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed
 * in. Filter interaction with a chart will only trigger events and redraws within the
 * chart's group.
 * @return {dc_graph.diagram}
 **/
dc_graph.diagram = function (parent, chartGroup) {
    // different enough from regular dc charts that we don't use bases
    var _chart = {};
    var _svg = null, _defs = null, _g = null, _nodeLayer = null, _edgeLayer = null;
    var _worker = null;
    var _dispatch = d3.dispatch('end', 'start', 'drawn');
    var _nodes = {}, _edges = {}; // hold state between runs
    var _stats = {};
    var _nodes_snapshot, _edges_snapshot;
    var _children = {}, _arrows = {};
    var _running = false; // for detecting concurrency issues

    /**
     * Set or get the width attribute of the diagram. See `.height` below.
     * @name width
     * @memberof dc_graph.diagram
     * @instance
     * @param {Number} [width=200]
     * @return {Number}
     * @return {dc_graph.diagram}
     **/
    _chart.width = property(200).react(resizeSvg);

    /**
     * Set or get the height attribute of the diagram. The width and height are applied to the
     * SVG element generated by the diagram when rendered. If a value is given, then the
     * diagram is returned for method chaining. If no value is given, then the current value of
     * the height attribute will be returned. Default: 200
     * @name height
     * @memberof dc_graph.diagram
     * @instance
     * @param {Number} [height=200]
     * @return {Number}
     * @return {dc_graph.diagram}
     **/
    _chart.height = property(200).react(resizeSvg);

    /**
     * Get or set the root element, which is usually the parent div. Normally the root is set
     * when the diagram is constructed; setting it later may have unexpected consequences.
     * @name root
     * @memberof dc_graph.diagram
     * @instance
     * @param {node} [root]
     * @return {node}
     * @return {dc_graph.diagram}
     **/
    _chart.root = property(null).react(function(e) {
        if(e.empty())
            console.log('Warning: parent selector ' + parent + " doesn't seem to exist");
    });

    /**
     * Get or set whether mouse wheel rotation or touchpad gestures will zoom the diagram, and
     * whether dragging on the background pans the diagram.
     * @name mouseZoomable
     * @memberof dc_graph.diagram
     * @instance
     * @param {Boolean} [mouseZoomable=true]
     * @return {Boolean}
     * @return {dc_graph.diagram}
     **/
    _chart.mouseZoomable = property(true);

    /**
     * Set or get the crossfilter dimension which represents the nodes (vertices) in the
     * diagram. Typically there will be a crossfilter instance for the nodes, and another for
     * the edges.

     * *The node dimension currently does nothing, but once selection is supported, it will be
     * used for filtering other charts on the same crossfilter instance based on the nodes
     * selected.*
     * @name nodeDimension
     * @memberof dc_graph.diagram
     * @instance
     * @param {crossfilter.dimension} [nodeDimension]
     * @return {crossfilter.dimension}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeDimension = property();

    /**
     * Set or get the crossfilter group which is the data source for the nodes in the
     * diagram. The diagram will use the group's `.all()` method to get an array of `{key,
     * value}` pairs, where the key is a unique identifier, and the value is usually an object
     * containing the node's attributes. All accessors work with these key/value pairs.

     * If the group is changed or returns different values, the next call to `.redraw()` will
     * reflect the changes incrementally.

     * It is possible to pass another object with the same `.all()` interface instead of a
     * crossfilter group.
     * @name nodeGroup
     * @memberof dc_graph.diagram
     * @instance
     * @param {crossfilter.group} [nodeGroup]
     * @return {crossfilter.group}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeGroup = property();

    /**
     * Set or get the crossfilter dimension which represents the edges in the
     * diagram. Typically there will be a crossfilter instance for the nodes, and another for
     * the edges.

     * *The edge dimension currently does nothing, but once selection is supported, it will be
     * used for filtering other charts on the same crossfilter instance based on the edges
     * selected.*

     * @name edgeDimension
     * @memberof dc_graph.diagram
     * @instance
     * @param {crossfilter.dimension} [edgeDimension]
     * @return {crossfilter.dimension}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeDimension = property();

    /**
     * Set or get the crossfilter group which is the data source for the edges in the
     * diagram. See `.nodeGroup` above for the way data is loaded from a crossfilter group.

     * The values in the key/value pairs returned by `diagram.edgeGroup().all()` need to
     * support, at a minimum, the `nodeSource` and `nodeTarget`, which should return the same
     * keys as the `nodeKey`

     * @name edgeGroup
     * @memberof dc_graph.diagram
     * @instance
     * @param {crossfilter.group} [edgeGroup]
     * @return {crossfilter.group}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeGroup = property();

    /**
     * Set or get the function which will be used to retrieve the unique key for each node. By
     * default, this accesses the `key` field of the object passed to it. The keys should match
     * the keys returned by the `.edgeSource` and `.edgeTarget`.

     * @name nodeKey
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function} [nodeKey]
     * @return {Function}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeKey = _chart.nodeKeyAccessor = property(function(kv) {
        return kv.key;
    });

    /**
     * Set or get the function which will be used to retrieve the unique key for each edge. By
     * default, this accesses the `key` field of the object passed to it.

     * @name edgeKey
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function} [edgeKey]
     * @return {Function}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeKey = _chart.edgeKeyAccessor = property(function(kv) {
        return kv.key;
    });

    /**
     * Set or get the function which will be used to retrieve the source (origin/tail) key of
     * the edge objects.  The key must equal the key returned by the `.nodeKey` for one of the
     * nodes; if it does not, or if the node is currently filtered out, the edge will not be
     * displayed. By default, looks for `.value.sourcename`.

     * @name edgeSource
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function} [edgeSource]
     * @return {Function}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeSource = _chart.sourceAccessor = property(function(kv) {
        return kv.value.sourcename;
    });

    /**
     * Set or get the function which will be used to retrieve the target (destination/head) key
     * of the edge objects.  The key must equal the key returned by the `.nodeKey` for one of
     * the nodes; if it does not, or if the node is currently filtered out, the edge will not
     * be displayed. By default, looks for `.value.targetname`.
     * @name edgeTarget
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function} [edgeTarget]
     * @return {Function}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeTarget = _chart.targetAccessor = property(function(kv) {
        return kv.value.targetname;
    });

    /**
     * Set or get the function which will be used to retrieve the radius, in pixels, for each
     * node. This determines the height of nodes, and the width, if `nodeFitLabel` is
     * false.
     * @name nodeRadius
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Number} [nodeRadius=25]
     * @return {Function|Number}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeRadius = _chart.nodeRadiusAccessor = property(25);

    /**
     * Set or get the function which will be used to retrieve the stroke width, in pixels, for
     * drawing the outline of each node. According to the SVG specification, the outline will
     * be drawn half on top of the fill, and half outside. Default: 1
     * @name nodeStrokeWidth
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Number} [nodeStrokeWidth=1]
     * @return {Function|Number}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeStrokeWidth = _chart.nodeStrokeWidthAccessor = property(1);

    /**
     * Set or get the function which will be used to retrieve the stroke color for the outline
     * of each node.
     * @name nodeStroke
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [nodeStroke='black']
     * @return {Function|String}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeStroke = _chart.nodeStrokeAccessor = property('black');

    /**
     * If set, the value returned from `nodeFill` will be processed through this
     * {@link https://github.com/mbostock/d3/wiki/Scales d3.scale}
     * to return the fill color. If falsy, uses the identity function (no scale).
     * @name nodeFillScale
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|d3.scale} [nodeFillScale]
     * @return {Function|d3.scale}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeFillScale = property(null);

    /**
     * Set or get the function which will be used to retrieve the fill color for the body of each
     * node.
     * @name nodeFill
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [nodeFill='white']
     * @return {Function|String}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeFill = _chart.nodeFillAccessor = property('white');

    /**
     * Set or get the padding or minimum distance, in pixels, between nodes in the diagram.
     * @name nodePadding
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Number} [nodePadding=6]
     * @return {Function|Number}
     * @return {dc_graph.diagram}
     **/
    _chart.nodePadding = property(6);

    /**
     * Set or get the function which will be used to retrieve the label text to display in each
     * node. By default, looks for a field `label` or `name` inside the `value` field.
     * @name nodeLabel
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [nodeLabel]
     * @return {Function|String}
     * @example
     * // Default behavior
     * diagram.nodeLabel(function(kv) {
     *   return kv.value.label || kv.value.name;
     * });
     * @return {dc_graph.diagram}
     **/
    _chart.nodeLabel = _chart.nodeLabelAccessor = property(function(kv) {
        return kv.value.label || kv.value.name;
    });

    /**
     * Set or get the function which will be used to retrieve the label fill color. Default: null
     * @name nodeLabelFill
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [nodeLabelFill=null]
     * @return {Function|String}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeLabelFill = _chart.nodeLabelFillAccessor = property(null);

    /**
     * Whether to fit the node shape around the label
     * @name nodeFitLabel
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Boolean} [nodeFitLabel=true]
     * @return {Function|Boolean}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeFitLabel = _chart.nodeFitLabelAccessor = property(true);

    /**
     * The shape to use for drawing each node, specified as an object with at least the field
     * `shape`: ellipse, polygon

     * If `shape = polygon`:
     * * `sides`: number of sides for a polygon
     * @name nodeShape
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Object} [nodeShape={shape: 'ellipse'}]
     * @return {Function|Object}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeShape = property({shape: 'ellipse'});

    /**
     * Set or get the function which will be used to retrieve the node title, usually rendered
     * as a tooltip. By default, uses the key of the node.
     * @name nodeTitle
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [nodeTitle]
     * @return {Function|String}
     * @example
     * // Default behavior
     * chart.nodeTitle(function(kv) {
     *   return _chart.nodeKeyAccessor()(kv);
     * });
     * @return {dc_graph.diagram}
     **/
    _chart.nodeTitle = _chart.nodeTitleAccessor = property(function(kv) {
        return _chart.nodeKeyAccessor()(kv);
    });

    /**
     * By default, nodes are added to the layout in the order that `.nodeGroup().all()` returns
     * them. If specified, `.nodeOrdering` provides an accessor that returns a key to sort the
     * nodes on.  *It would be better not to rely on ordering to affect layout, but it may
     * affect the layout in some cases.*
     * @name nodeOrdering
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function} [nodeOrdering]
     * @return {Function}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeOrdering = property(null);

    /**
     * Specify an accessor that returns an {x,y} coordinate for a node that should be
     * {@link https://github.com/tgdwyer/WebCola/wiki/Fixed-Node-Positions fixed in place},
     * and returns falsy for other nodes.
     * @name nodeFixed
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Object} [nodeFixed]
     * @return {Function|Object}
     * @return {dc_graph.diagram}
     **/
    _chart.nodeFixed = _chart.nodeFixedAccessor = property(null);


    /**
     * Set or get the function which will be used to retrieve the stroke color for the edges.
     * @name edgeStroke
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [edgeStroke='black']
     * @return {Function|String}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeStroke = _chart.edgeStrokeAccessor = property('black');

    /**
     * Set or get the function which will be used to retrieve the stroke width for the edges.
     * @name edgeStrokeWidth
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Number} [edgeStrokeWidth=1]
     * @return {Function|Number}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeStrokeWidth = _chart.edgeStrokeWidthAccessor = property(1);

    /**
     * Set or get the function which will be used to retrieve the edge opacity, a number from 0
     * to 1.
     * @name edgeOpacity
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Number} [edgeOpacity=1]
     * @return {Function|Number}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeOpacity = _chart.edgeOpacityAccessor = property(1);

    /**
     * Set or get the function which will be used to retrieve the edge label text. The label is
     * displayed when an edge is hovered over. By default, uses the `edgeKey`.
     * @name edgeLabel
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [edgeLabel]
     * @example
     * // Default behavior
     * chart.edgeLabel(function(d) {
     *   return _chart.edgeKey()(d);
     * });
     * @return {Function|String}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeLabel = _chart.edgeLabelAccessor = property(function(d) {
        return _chart.edgeKey()(d);
    });

    /**
     * Set or get the function which will be used to retrieve the name of the arrowhead to use
     * for the target/ head/destination of the edge. Arrow symbols can be specified with
     * `.defineArrow()`. Return null to display no arrowhead.
     * @name edgeArrowhead
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [edgeArrowhead='vee']
     * @return {Function|String}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeArrowhead = _chart.edgeArrowheadAccessor = property('vee');

    /**
     * Set or get the function which will be used to retrieve the name of the arrow tail to use
     * for the tail/source of the edge. Arrow symbols can be specified with
     * `.defineArrow()`. Return null to display no arrowtail.
     * @name edgeArrowtail
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [edgeArrowtail=null]
     * @return {Function|String}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeArrowtail = _chart.edgeArrowtailAccessor = property(null);

    /**
     * Multiplier for arrow size.
     * @name edgeArrowSize
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Number} [edgeArrowSize=1]
     * @return {Function|Number}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeArrowSize = property(1);

    /**
     * To draw an edge but not have it affect the layout, specify a function which returns
     * false for that edge.  By default, will return false if the `notLayout` field of the edge
     * value is truthy, true otherwise.
     * @name edgeIsLayout
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Boolean} [edgeIsLayout]
     * @example
     * // Default behavior
     * chart.edgeIsLayout(function(kv) {
     *   return !kv.value.notLayout;
     * });
     * @return {Function|Boolean}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeIsLayout = _chart.edgeIsLayoutAccessor = property(function(kv) {
        return !kv.value.notLayout;
    });

    /**
     * Currently, three strategies are supported for specifying the lengths of edges:
     * * 'individual' - uses the `edgeLength` for each edge. If it returns falsy, uses the
     * `baseLength`
     * * 'symmetric', 'jaccard' - compute the edge length based on the graph structure around
     * the edge. See
     * {@link https://github.com/tgdwyer/WebCola/wiki/link-lengths the cola.js wiki}
     * for more details.
     * 'none' - no edge lengths will be specified
     * @name lengthStrategy
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|String} [lengthStrategy='symmetric']
     * @return {Function|String}
     * @return {dc_graph.diagram}
     **/
    _chart.lengthStrategy = property('symmetric');

    /**
     * When the `.lengthStrategy` is 'individual', this accessor will be used to read the
     * length of each edge.  By default, reads the `distance` field of the edge. If the
     * distance is falsy, uses the `baseLength`.
     * @name edgeLength
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Number} [edgeLength]
     * @example
     * // Default behavior
     * chart.edgeLength(function(kv) {
     *   return kv.value.distance;
     * });
     * @return {Function|Number}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeLength = _chart.edgeDistanceAccessor = property(function(kv) {
        return kv.value.distance;
    });

    /**
     * @name flowLayout
     * @memberof dc_graph.diagram
     * @instance
     * @param {Object} [flowLayout]
     * @example
     * // No flow (default)
     * chart.flowLayout(null)
     * // flow in x with min separation 200
     * chart.flowLayout({axis: 'x', minSeparation: 200})
     **/
    _chart.flowLayout = property(null);

    /**
     * Gets or sets the default edge length (in pixels) when the `.lengthStrategy` is
     * 'individual', and the base value to be multiplied for 'symmetric' and 'jaccard' edge
     * lengths.
     * @name baseLength
     * @memberof dc_graph.diagram
     * @instance
     * @param {Number} [baseLength]
     * @return {Number}
     * @return {dc_graph.diagram}
     **/
    _chart.baseLength = property(30);

    /**
     * Whether to highlight neighboring edges when hovering over a node. Not completely working
     * yet.
     * @name highlightNeighbors
     * @memberof dc_graph.diagram
     * @instance
     * @param {Boolean} [highlightNeighbors]
     * @return {Boolean}
     * @return {dc_graph.diagram}
     **/
    _chart.highlightNeighbors = property(false);

    /**
     * Gets or sets the transition duration, the length of time each change to the diagram will
     * be animated.
     * @name transitionDuration
     * @memberof dc_graph.diagram
     * @instance
     * @param {Number} [transitionDuration]
     * @return {Number}
     * @return {dc_graph.diagram}
     **/
    _chart.transitionDuration = property(500);

    /**
     * How transitions should be split into separate animations to emphasize
     * the delete, modify, and insert operations:
     * * `none`: modify and insert operations animate at the same time
     * * `modins`: modify operations happen before inserts
     * * `insmod`: insert operations happen before modifies
     *
     * Deletions always happen before/during layout computation.
     * @name stageTransitions
     * @memberof dc_graph.diagram
     * @instance
     * @param {String} [stageTransitions]
     * @return {String}
     * @return {dc_graph.diagram}
     **/
    _chart.stageTransitions = property('none');

    /**
     * The delete transition happens simultaneously with layout, which can take longer
     * than the transition duration. Delaying it can bring it closer to the other
     * staged transitions.
     * @name deleteDelay
     * @memberof dc_graph.diagram
     * @instance
     * @param {Number} [deleteDelay]
     * @return {Number}
     * @return {dc_graph.diagram}
     **/
    _chart.deleteDelay = property(0);

    /**
     * Whether to put connected components each in their own group, to stabilize layout.
     * @name groupConnected
     * @memberof dc_graph.diagram
     * @instance
     * @param {String} [stageTransitions]
     * @return {String}
     * @return {dc_graph.diagram}
     **/
    _chart.groupConnected = property(false);

    /**
     * Gets or sets the maximum time spent doing layout for a render or redraw. Set to 0 for no
     * limit.
     * @name timeLimit
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function|Number} [timeLimit=0]
     * @return {Function|Number}
     * @return {dc_graph.diagram}
     **/
    _chart.timeLimit = property(0);

    /**
     * Gets or sets a function which will be called with the current nodes and edges on each
     * redraw in order to derive new layout constraints. The constraints are built from scratch
     * on each redraw.

     * This can be used to generate alignment (rank) or axis constraints. By default, no
     * constraints will be added, although cola.js uses constraints internally to implement
     * flow and overlap prevention. See
     * {@link https://github.com/tgdwyer/WebCola/wiki/Constraints the cola.js wiki}
     * for more details.

     * For convenience, dc.graph.js implements a other constraints on top of those implemented
     * by cola.js:
     * * 'ordering' - the nodes will be ordered on the specified `axis` according to the keys
     * returned by the `ordering` function, by creating separation constraints using the
     * specified `gap`.
     * * 'circle' - (experimental) the nodes will be placed in a circle using "wheel"
     * edge lengths similar to those described in
     * {@link http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf Scalable, Versatile, and Simple Constrained Graph Layout}
     * *Although this is not as performant or stable as might be desired, it may work for
     * simple cases. In particular, it should use edge length *constraints*, which don't yet
     * exist in cola.js.*
     *
     * Because it is tedious to write code to generate constraints for a graph, **dc.graph.js**
     * also includes a {@link #dc_graph+constraint_pattern constraint generator} to produce
     * this constrain function, specifying the constraints themselves in a graph.
     * @name constrain
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function} [constrain]
     * @return {Function}
     * @return {dc_graph.diagram}
     **/
    _chart.constrain = property(function(nodes, edges) {
        return [];
    });

    /**
     * If there are multiple edges between the same two nodes, start them this many pixels away
     * from the original so they don't overlap.
     * @name parallelEdgeOffset
     * @memberof dc_graph.diagram
     * @instance
     * @param {Number} [parallelEdgeOffset=10]
     * @return {Number}
     * @return {dc_graph.diagram}
     **/
    _chart.parallelEdgeOffset = property(10);

    /**
     * By default, edges are added to the layout in the order that `.edgeGroup().all()` returns
     * them. If specified, `.edgeOrdering` provides an accessor that returns a key to sort the
     * edges on.

     * *It would be better not to rely on ordering to affect layout, but it may affect the
     * layout in some cases. (Probably less than node ordering, but it does affect which
     * parallel edge is which.)*
     * @name edgeOrdering
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function} [edgeOrdering]
     * @return {Function}
     * @return {dc_graph.diagram}
     **/
    _chart.edgeOrdering = property(null);

    /**
     * Currently there are some bugs when the same instance of cola.js is used multiple
     * times. (In particular, overlaps between nodes may not be eliminated
     * {@link https://github.com/tgdwyer/WebCola/issues/118 if cola is not reinitialized}
     * This flag can be set true to construct a new cola layout object on each redraw. However,
     * layout seems to be more stable if this is set false, so hopefully this will be fixed
     * soon.
     * @name initLayoutOnRedraw
     * @memberof dc_graph.diagram
     * @instance
     * @param {Boolean} [initLayoutOnRedraw=false]
     * @return {Boolean}
     * @return {dc_graph.diagram}
     **/
    _chart.initLayoutOnRedraw = property(false);

    /**
     * Whether to perform layout when the data is unchanged from the last redraw.
     * @name layoutUnchanged
     * @memberof dc_graph.diagram
     * @instance
     * @param {Boolean} [layoutUnchanged=false]
     * @return {Boolean}
     * @return {dc_graph.diagram}
     **/
    _chart.layoutUnchanged = property(false);

    /**
     * When `layoutUnchanged` is false, this will force layout to happen again. This may be needed
     * when changing a parameter but not changing the topology of the graph. (Yes, probably should
     * not be necessary.)
     * @name relayout
     * @memberof dc_graph.diagram
     * @instance
     * @return {dc_graph.diagram}
     **/
    _chart.relayout = function() {
        _nodes_snapshot = _edges_snapshot = null;
        return this;
    };

    /**
     * Function to call to generate an initial layout. Takes (diagram, nodes, edges)
     * @name initialLayout
     * @memberof dc_graph.diagram
     * @instance
     * @param {Function} [initialLayout=null]
     * @return {Function}
     * @return {dc_graph.diagram}
     **/
    _chart.initialLayout = property(null);

    _chart.initialOnly = property(false);

    /**
     * By default, all nodes are included, and edges are only included if both end-nodes are
     * visible.  If `.induceNodes` is set, then only nodes which have at least one edge will be
     * shown.
     * @name induceNodes
     * @memberof dc_graph.diagram
     * @instance
     * @param {Boolean} [induceNodes=false]
     * @return {Boolean}
     * @return {dc_graph.diagram}
     **/
    _chart.induceNodes = property(false);

    /**
     * If this flag is true, the positions of nodes and will be updated while layout is
     * iterating. If false, the positions will only be updated once layout has
     * stabilized. Note: this may not be compatible with transitionDuration.
     * @name showLayoutSteps
     * @memberof dc_graph.diagram
     * @instance
     * @param {Boolean} [showLayoutSteps=false]
     * @return {Boolean}
     * @return {dc_graph.diagram}
     **/
    _chart.showLayoutSteps = property(false);

    /**
     * Assigns a legend object which will be displayed within the same SVG element and
     * according to the visual encoding of this diagram.
     * @name legend
     * @memberof dc_graph.diagram
     * @instance
     * @param {Object} [legend]
     * @return {Object}
     * @return {dc_graph.diagram}
     **/
    _chart.legend = property(null).react(function(l) {
        l.parent(_chart);
    });

    /**
     * Specifies another kind of child layer or interface. For example, this can
     * be used to display tooltips on nodes using `dc_graph.tip`.

     * The child needs to support a `parent` method, the diagram to modify.
     * @name child
     * @memberof dc_graph.diagram
     * @instance
     * @param {String} [id] - the name of the child to modify or add
     * @param {Object} [object] - the child object to add, or null to remove
     * @example
     * // Display tooltips on node hover, via the d3-tip library
     * var tip = dc_graph.tip()
     * tip.content(function(d, k) {
     *   // you can do an asynchronous call here, e.g. d3.json, if you need
     *   // to fetch data to show the tooltip - just call k() with the content
     *   k("This is <em>" + d.orig.value.name + "</em>");
     * });
     * diagram.child('tip', tip);
     * @return {dc_graph.diagram}
     **/
    _chart.child = function(id, object) {
        // do not notify unnecessarily
        if(_children[id] === object)
            return _chart;
        if(_children[id])
            _children[id].parent(null);
        _children[id] = object;
        if(object)
            object.parent(_chart);
        return _chart;
    };


    _chart.edgeId = function(d) {
        return 'edge-' + param(_chart.edgeKey())(d).replace(/[^\w-_]/g, '-');
    };

    _chart.arrowId = function(d, kind) {
        return 'arrow-' + kind + '-' + _chart.edgeId(d);
    };

    _chart.textpathId = function(d) {
        return 'textpath-' + _chart.edgeId(d);
    };

    /**
     * Instructs cola.js to fit the connected components. Default: true
     * @name handleDisconnected
     * @memberof dc_graph.diagram
     * @instance
     * @param {Boolean} [handleDisconnected=true]
     * @return {Boolean}
     * @return {dc_graph.diagram}
     **/
    _chart.handleDisconnected = property(true);

    function initLayout() {
        if(!_worker)
            _worker = new Worker('js/dc.graph-worker.js');
        _worker.postMessage({
            command: 'init',
            args: {
                width: _chart.width(),
                height: _chart.height(),
                handleDisconnected: _chart.handleDisconnected(),
                lengthStrategy: _chart.lengthStrategy(),
                baseLength: _chart.baseLength(),
                flowLayout: _chart.flowLayout()
            }
        });
    }

    _chart._buildNode = function(node, nodeEnter) {
        if(_chart.nodeTitle())
            nodeEnter.append('title');
        nodeEnter.each(infer_shape(_chart));
        var changedShape = node.filter(shape_changed(_chart));
        changedShape.select('.node-shape').remove();
        changedShape.each(infer_shape(_chart));
        changedShape.insert(shape_element(_chart), ':first-child')
            .attr('class', 'node-shape');
        nodeEnter.append(shape_element(_chart))
            .attr('class', 'node-shape');
        nodeEnter.append('text')
            .attr('class', 'node-label')
            .attr('fill', param(_chart.nodeLabelFill()));
        node.select('title')
            .text(param(_chart.nodeTitle()));
        var text = node.select('text.node-label');
        var tspan = text.selectAll('tspan').data(function(n) {
            var lines = param(_chart.nodeLabel())(n);
            if(!lines)
                return [];
            else if(typeof lines === 'string')
                lines = [lines];
            var first = lines.length%2 ? 0.3 - (lines.length-1)/2 : 1-lines.length/2;
                    return lines.map(function(line, i) { return {line: line, ofs: (i==0 ? first : 1) + 'em'}; });
        });
        tspan.enter().append('tspan')
            .attr('x', 0)
            .attr('dy', function(d) { return d.ofs; });
        tspan.text(function(d) { return d.line; });
        text.each(fit_shape(_chart));
        node.select('.node-shape')
            .each(shape_attrs(_chart))
            .attr({
                stroke: param(_chart.nodeStroke()),
                'stroke-width': param(_chart.nodeStrokeWidth()),
                fill: compose(_chart.nodeFillScale() || identity, param(_chart.nodeFill()))
            });
    };

    function has_source_and_target(e) {
        return !!e.source && !!e.target;
    }

    // three stages: delete before layout, and modify & insert split the transitionDuration
    function transition_duration() {
        return (_chart.stageTransitions() !== 'none') ?
            _chart.transitionDuration() / 2 :
            _chart.transitionDuration();
    }

    function transition_delay(is_enter) {
        return _chart.stageTransitions() === 'none' ||
            _chart.stageTransitions() === 'modins' === !is_enter ?
            0 :
            _chart.transitionDuration() / 2;
    }

    _chart.isRunning = function() {
        return _running;
    };

    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Computes a new layout based on the nodes and edges in the edge groups, and
     * displays the diagram.  To the extent possible, the diagram will minimize changes in
     * positions from the previous layout.  `.render()` must be called the first time, and
     * `.redraw()` can be called after that.

     * `.redraw()` will be triggered by changes to the filters in any other charts in the same
     * dc.js chart group.

     * Unlike in dc.js, `redraw` executes asynchronously, because drawing can be computationally
     * intensive, and the diagram will be drawn multiple times if
     * {@link #dc_graph.diagram+showLayoutSteps showLayoutSteps}
     * is enabled. Watch the {@link #dc_graph.diagram+on 'end'} event to know when layout is
     * complete.
     **/
    var _needsRedraw = false;
    _chart.redraw = function () {
        // since dc.js can receive UI events and trigger redraws whenever it wants,
        // and cola absolutely will not tolerate being poked while it's doing layout,
        // we need to guard the startLayout call.
        if(_running) {
            _needsRedraw = true;
            return this;
        }
        else return _chart.startLayout();
    };

    _chart.startLayout = function () {
        var nodes = _chart.nodeGroup().all();
        var edges = _chart.edgeGroup().all();
        if(_running) {
            throw new Error('dc_graph.diagram.redraw already running!');
        }
        _running = true;

        if(_worker)
            _worker.postMessage({command: 'stop'});

        if(_chart.initLayoutOnRedraw())
            initLayout();

        // ordering shouldn't matter, but we support ordering in case it does
        if(_chart.nodeOrdering()) {
            nodes = crossfilter.quicksort.by(_chart.nodeOrdering())(nodes.slice(0), 0, nodes.length);
        }
        if(_chart.edgeOrdering()) {
            edges = crossfilter.quicksort.by(_chart.edgeOrdering())(edges.slice(0), 0, edges.length);
        }

        var wnodes = regenerate_objects(_nodes, nodes, function(v) {
            return _chart.nodeKey()(v);
        }, function(v1, v) {
            v1.orig = v;
            v1.cola = v1.cola || {};
            v1.cola.dcg_nodeKey = param(_chart.nodeKey())(v1);
            if(_chart.nodeFixed())
                v1.cola.dcg_nodeFixed = param(_chart.nodeFixed())(v1);
        });
        var wedges = regenerate_objects(_edges, edges, function(e) {
            return _chart.edgeKey()(e);
        }, function(e1, e) {
            e1.orig = e;
            e1.cola = e1.cola || {};
            e1.cola.dcg_edgeKey = param(_chart.edgeKey())(e1);
            e1.cola.dcg_edgeSource = param(_chart.edgeSource())(e1);
            e1.cola.dcg_edgeTarget = param(_chart.edgeTarget())(e1);
            e1.source = _nodes[e1.cola.dcg_edgeSource];
            e1.target = _nodes[e1.cola.dcg_edgeTarget];
            e1.cola.dcg_edgeLength = param(_chart.edgeLength())(e1);
        });

        // remove edges that don't have both end nodes
        wedges = wedges.filter(has_source_and_target);

        // remove self-edges (since we can't draw them - will be option later)
        wedges = wedges.filter(function(e) { return e.source !== e.target; });

        // and optionally, nodes that have no edges
        if(_chart.induceNodes()) {
            var keeps = {};
            wedges.forEach(function(e) {
                keeps[e.cola.dcg_edgeSource] = true;
                keeps[e.cola.dcg_edgeTarget] = true;
            });
            wnodes = wnodes.filter(function(n) { return keeps[n.cola.dcg_nodeKey]; });
            for(var k in _nodes)
                if(!keeps[k])
                    delete _nodes[k];
        }

        wnodes.forEach(function(v, i) {
            v.index = i;
        });

        _stats = {nnodes: wnodes.length, nedges: wedges.length};

        // optionally do nothing if the topology hasn't changed
        var skip_layout = false;
        if(!_chart.layoutUnchanged()) {
            var nodes_snapshot = JSON.stringify(wnodes.map(get_original)),
                edges_snapshot = JSON.stringify(wedges.map(get_original));
            if(nodes_snapshot === _nodes_snapshot && edges_snapshot === _edges_snapshot)
                skip_layout = true;
            _nodes_snapshot = nodes_snapshot;
            _edges_snapshot = edges_snapshot;
        }

        // annotate parallel edges so we can draw them specially
        if(_chart.parallelEdgeOffset()) {
            var em = new Array(wnodes.length);
            for(var i = 0; i < em.length; ++i) {
                em[i] = new Array(em.length); // technically could be diagonal array
                for(var j = 0; j < em.length; ++j)
                    em[i][j] = {
                        n: 0,
                        ports: {}
                    };
            }
            wedges.forEach(function(e) {
                var min = Math.min(e.source.index, e.target.index),
                    max = Math.max(e.source.index, e.target.index);
                e.parallel = em[min][max].n++;
                e.ports = em[min][max].ports;
            });
            for(i = 0; i < em.length; ++i)
                for(j = 0; j < em.length; ++j)
                    if(em[i][j].n)
                        em[i][j].ports.n = em[i][j].n;
        }

        if(_chart.initialLayout())
            _chart.initialLayout()(_chart, wnodes, wedges);

        // create edge SVG elements
        var edge = _edgeLayer.selectAll('.edge')
                .data(wedges, param(_chart.edgeKey()));
        var edgeEnter = edge.enter().append('svg:path')
                .attr({
                    class: 'edge',
                    id: _chart.edgeId,
                    opacity: 0
                });
        edge
            .attr('stroke', param(_chart.edgeStroke()))
            .attr('stroke-width', param(_chart.edgeStrokeWidth()))
            .attr('marker-end', function(d) {
                var name = param(_chart.edgeArrowhead())(d),
                    id = edgeArrow(d, 'head', name);
                return id ? 'url(#' + id + ')' : null;
            })
            .attr('marker-start', function(d) {
                var name = param(_chart.edgeArrowtail())(d),
                    arrow_id = edgeArrow(d, 'tail', name);
                return name ? 'url(#' + arrow_id + ')' : null;
            });
        edge.exit().transition()
            .duration(transition_duration())
            .delay(_chart.deleteDelay())
            .attr('opacity', 0)
            .each(function(d) {
                edgeArrow(d, 'head', null);
                edgeArrow(d, 'head', null);
            })
            .remove();

        // another wider copy of the edge just for hover events
        var edgeHover = _edgeLayer.selectAll('.edge-hover')
                .data(wedges, param(_chart.edgeKey()));
        var edgeHoverEnter = edgeHover.enter().append('svg:path')
            .attr('class', 'edge-hover')
            .attr('opacity', 0)
            .attr('stroke', 'green')
            .attr('stroke-width', 10)
            .on('mouseover', function(d) {
                d3.select('#' + _chart.edgeId(d) + '-label')
                    .attr('visibility', 'visible');
            })
            .on('mouseout', function(d) {
                d3.select('#' + _chart.edgeId(d) + '-label')
                    .attr('visibility', 'hidden');
            });
        edgeHover.exit().remove();

        var edgeLabels = _edgeLayer.selectAll(".edge-label")
                .data(wedges, param(_chart.edgeKey()));
        var edgeLabelsEnter = edgeLabels.enter()
              .append('text')
                .attr('id', function(d) {
                    return _chart.edgeId(d) + '-label';
                })
                .attr('visibility', 'hidden')
                .attr({'class':'edge-label',
                       'text-anchor': 'middle',
                       dy:-2})
              .append('textPath')
                .attr('startOffset', '50%')
                .attr('xlink:href', function(d) {
                    var id = _chart.textpathId(d);
                    _chart.addOrRemoveDef(id, true, 'svg:path');
                    return '#' + id;
                });
        edgeLabels.each(function(d) {
            d.dcg_bbox = null;
        })
          .selectAll('textPath')
            .text(function(d){
                return param(_chart.edgeLabel())(d);
            });
        edgeLabels.exit().transition()
            .duration(transition_duration())
            .delay(_chart.deleteDelay())
            .attr('opacity', 0).remove();

        // create node SVG elements
        var node = _nodeLayer.selectAll('.node')
                .data(wnodes, param(_chart.nodeKey()));
        var nodeEnter = node.enter().append('g')
                .attr('class', 'node')
                .attr('opacity', '0'); // don't show until has layout
        // .call(_d3cola.drag);

        _chart._buildNode(node, nodeEnter);
        node.exit().transition()
            .duration(transition_duration())
            .delay(_chart.deleteDelay())
            .attr('opacity', 0)
            .remove();

        _dispatch.drawn(node, edge);

        // cola constraints always use indices, but node references
        // are more friendly, so translate those

        // i am not satisfied with this constraint generation api...
        // https://github.com/dc-js/dc.graph.js/issues/10
        var constraints = _chart.constrain()(wnodes, wedges);
        // translate references from names to indices (ugly)
        constraints.forEach(function(c) {
            if(c.type) {
                switch(c.type) {
                case 'alignment':
                    c.offsets.forEach(function(o) {
                        o.node = _nodes[o.node].index;
                    });
                    break;
                case 'circle':
                    c.nodes.forEach(function(n) {
                        n.node = _nodes[n.node].index;
                    });
                    break;
                }
            } else if(c.axis) {
                c.left = _nodes[c.left].index;
                c.right = _nodes[c.right].index;
            }
        });

        // pseudo-cola.js features

        // 1. non-layout edges are drawn but not told to cola.js
        var layout_edges = wedges.filter(param(_chart.edgeIsLayout()));
        var nonlayout_edges = wedges.filter(function(x) {
            return !param(_chart.edgeIsLayout())(x);
        });

        // 2. type=circle constraints
        var circle_constraints = constraints.filter(function(c) {
            return c.type === 'circle';
        });
        constraints = constraints.filter(function(c) {
            return c.type !== 'circle';
        });
        circle_constraints.forEach(function(c) {
            var R = (c.distance || _chart.baseLength()*4) / (2*Math.sin(Math.PI/c.nodes.length));
            var nindices = c.nodes.map(function(x) { return x.node; });
            var namef = function(i) {
                return param(_chart.nodeKey())(wnodes[i]);
            };
            var wheel = dc_graph.wheel_edges(namef, nindices, R)
                    .map(function(e) {
                        var e1 = {internal: e};
                        e1.source = _nodes[e.sourcename];
                        e1.target = _nodes[e.targetname];
                        return e1;
                    });
            layout_edges = layout_edges.concat(wheel);
        });

        // 3. ordered alignment
        var ordered_constraints = constraints.filter(function(c) {
            return c.type === 'ordering';
        });
        constraints = constraints.filter(function(c) {
            return c.type !== 'ordering';
        });
        ordered_constraints.forEach(function(c) {
            var sorted = c.nodes.map(function(n) { return _nodes[n]; });
            if(c.ordering) {
                var sort = crossfilter.quicksort.by(param(c.ordering));
                sorted = sort(sorted, 0, sorted.length);
            }
            var left;
            sorted.forEach(function(n, i) {
                if(i===0)
                    left = n;
                else {
                    constraints.push({
                        left: left.index,
                        right: (left = n).index,
                        axis: c.axis,
                        gap: c.gap
                    });
                }
            });
        });
        if(_chart.legend())
            _chart.legend().redraw();
        if(skip_layout) {
            _running = false;
            _dispatch.end(false);
            return this;
        }
        var startTime = Date.now();

        function refreshObjects(rnodes, redges) {
            rnodes.forEach(function(rn) {
                var n = _nodes[rn.dcg_nodeKey];
                n.cola.x = rn.x;
                n.cola.y = rn.y;
            });
            redges.forEach(function(re) {
                var e = _edges[re.dcg_edgeKey];
            });
        }
        _worker.onmessage = function(e) {
            var args = e.data.args;
            switch(e.data.response) {
            case 'tick':
                var elapsed = Date.now() - startTime;
                refreshObjects(args.nodes, args.edges);
                if(_chart.showLayoutSteps())
                    draw(node, nodeEnter, edge, edgeEnter, edgeHover, edgeHoverEnter, edgeLabels, edgeLabelsEnter);
                if(_needsRedraw || _chart.timeLimit() && elapsed > _chart.timeLimit()) {
                    console.log('cancelled');
                    _worker.postMessage({
                        command: 'stop'
                    });
                }
                break;
            case 'end':
                if(!_chart.showLayoutSteps())
                    draw(node, nodeEnter, edge, edgeEnter, edgeHover, edgeHoverEnter, edgeLabels, edgeLabelsEnter);
                else layout_done(true);
                break;
            case 'start':
                console.log('COLA START'); // doesn't seem to fire
                _dispatch.start();
            }
        };
        _dispatch.start(); // cola doesn't seem to fire this itself?
        _worker.postMessage({
            command: 'data',
            args: {
                nodes: wnodes.map(function(v) { return v.cola; }),
                edges: layout_edges.map(function(v) { return v.cola; }),
                constraints: constraints,
                opts: {groupConnected: _chart.groupConnected()}
            }
        });
        _worker.postMessage({
            command: 'start',
            args: {
                initialUnconstrainedIterations: 10,
                initialUserConstraintIterations: 20,
                initialAllConstraintsIterations: 20,
                initialOnly: _chart.initialOnly()
            }
        });
        return this;
    };


    function layout_done(happens) {
        _dispatch.end(happens);
        _running = false;
        if(_needsRedraw) {
            _needsRedraw = false;
            window.setTimeout(function() {
                _chart.startLayout();
            }, 0);
        }
    }

    function calc_edge_path(d, age, sx, sy, tx, ty) {
        if(!d.ports[age]) {
            var source_padding = d.source.dcg_ry +
                    param(_chart.nodeStrokeWidth())(d.source) / 2,
                target_padding = d.target.dcg_ry +
                    param(_chart.nodeStrokeWidth())(d.target) / 2;
            d.ports[age] = new Array(d.ports.n);
            for(var p = 0; p < d.ports.n; ++p) {
                // alternate parallel edges over, then under
                var dir = (!!(p%2) === (sx < tx)) ? -1 : 1,
                    port = Math.floor((p+1)/2),
                    last = port ? d.ports[age][p > 2 ? p - 2 : 0].path : null;
                var path = draw_edge_to_shapes(_chart, d.source, d.target, sx, sy, tx, ty,
                                              last, dir, _chart.parallelEdgeOffset(),
                                              source_padding, target_padding
                                              );
                var spos = path.points[0], tpos = path.points[path.points.length-1];
                var near = bezier_point(path.points, 0.75);
                d.ports[age][p] = {
                    path: path,
                    orient: Math.atan2(tpos.y - near.y, tpos.x - near.x) + 'rad'
                };
            }
        }
        return d.ports[age][d.parallel].path;
    }

    function calc_old_edge_path(d) {
        calc_edge_path(d, 'old', d.source.prevX || d.source.cola.x, d.source.prevY || d.source.cola.y,
                         d.target.prevX || d.target.cola.x, d.target.prevY || d.target.cola.y);
    }

    function calc_new_edge_path(d) {
        var path = calc_edge_path(d, 'new', d.source.cola.x, d.source.cola.y, d.target.cola.x, d.target.cola.y);
        var spos = path.points[0], tpos = path.points[path.points.length-1];
        d.length = Math.hypot(tpos.x-spos.x, tpos.y-spos.y);
    }

    function render_edge_path(age) {
        return function(d) {
            var path = d.ports[age][d.parallel].path;
            return generate_path(path.points, path.bezDegree);
        };
    }

    // wait on multiple transitions, adapted from
    // http://stackoverflow.com/questions/10692100/invoke-a-callback-at-the-end-of-a-transition
    function endall(transitions, callback) {
        if (transitions.every(function(transition) { return transition.size() === 0; }))
            callback();
        var n = 0;
        transitions.forEach(function(transition) {
            transition
                .each(function() { ++n; })
                .each("end.all", function() { if (!--n) callback(); });
        });
    }
    function draw(node, nodeEnter, edge, edgeEnter, edgeHover, edgeHoverEnter, edgeLabels, edgeLabelsEnter) {
        console.assert(_running);
        console.assert(edge.data().every(has_source_and_target));

        var nodeEntered = {};
        nodeEnter
            .each(function(n) {
                nodeEntered[param(_chart.nodeKey())(n)] = true;
            })
            .attr("transform", function (d) {
                // start new nodes at their final position
                return "translate(" + d.cola.x + "," + d.cola.y + ")";
            });
        var ntrans = node
                .transition()
                .duration(transition_duration())
                .delay(function(n) {
                    return transition_delay(nodeEntered[param(_chart.nodeKey())(n)]);
                })
                .attr('opacity', '1')
                .attr("transform", function (d) {
                    return "translate(" + d.cola.x + "," + d.cola.y + ")";
                })
                .each("end.record", function(d) {
                    d.prevX = d.cola.x;
                    d.prevY = d.cola.y;
                });

        // reset edge ports
        edge.each(function(d) {
            d.ports.new = null;
            d.ports.old = null;
        });

        var edgeEntered = {};
        edgeEnter
            .each(function(e) {
                edgeEntered[param(_chart.edgeKey())(e)] = true;
            })
            .each(function(e) {
                // if staging transitions, just fade new edges in at new position
                // else start new edges at old positions of nodes, if any, else new positions
                var age;
                if(_chart.stageTransitions() === 'modins') {
                    calc_new_edge_path(e);
                    age = 'new';
                }
                else {
                    calc_old_edge_path(e);
                    age = 'old';
                }
                if(param(_chart.edgeArrowhead())(e))
                    d3.select('#' + _chart.arrowId(e, 'head'))
                    .attr('orient', function() {
                        return e.ports[age][e.parallel].orient;
                    });
            })
            .attr('d', render_edge_path(_chart.stageTransitions() === 'modins' ? 'new' : 'old'));

        var etrans = edge.each(calc_new_edge_path)
                .each(function(e) {
                    if(param(_chart.edgeArrowhead())(e)) {
                        d3.select('#' + _chart.arrowId(e, 'head'))
                            .transition().duration(transition_duration())
                            .delay(transition_delay(false))
                            .attr('orient', function() {
                                return e.ports.new[e.parallel].orient;
                            });
                    }
                })
              .transition()
                .duration(transition_duration())
                .delay(function(e) {
                    return transition_delay(edgeEntered[param(_chart.edgeKey())(e)]);
                })
                .attr('opacity', param(_chart.edgeOpacity()))
                .attr("d", function(e) {
                    var when = _chart.stageTransitions() === 'insmod' &&
                            edgeEntered[param(_chart.edgeKey())(e)] ? 'old' : 'new';
                    return render_edge_path(when)(e);
                });
        if(_chart.stageTransitions() === 'insmod') {
            // inserted edges transition twice in insmod mode
            etrans = etrans.transition()
                .duration(transition_duration())
                .attr("d", render_edge_path('new'));
            d3.timer.flush();
        }

        edge.each(function(d) {
            var id = _chart.textpathId(d);
            var path = d.ports.new[d.parallel].path;
            var points = d.target.cola.x < d.source.cola.x ?
                    path.points.slice(0).reverse() : path.points;
            d3.select('#' + id)
                .attr('d', function(d) {
                    return generate_path(points, path.bezDegree);
                });
        });
        // signal layout done when all transitions complete
        // because otherwise client might start another layout and lock the processor
        if(!_chart.showLayoutSteps())
            endall([ntrans, etrans], function() { layout_done(true); });

        edgeHover.attr('d', render_edge_path('new'));
    }

    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Erases any existing SVG elements and draws the diagram from scratch. `.render()`
     * must be called the first time, and `.redraw()` can be called after that.
     * @name render
     * @memberof dc_graph.diagram
     * @instance
     * @return {dc_graph.diagram}
     **/
    _chart.render = function () {
        if(!_chart.initLayoutOnRedraw())
            initLayout();
        _chart.resetSvg();
        _g = _svg.append('g').attr('class', 'dc-graph');
        _edgeLayer = _g.append('g');
        _nodeLayer = _g.append('g');

        if(_chart.legend())
            _chart.legend().render();
        return _chart.redraw();
    };

    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Attaches an event handler to the diagram. The currently supported events are
     * * `start()` - layout is starting
     * * `drawn(nodes, edges)` - the node and edge elements have been rendered to the screen
     * and can be modified through the passed d3 selections.
     * * `end()` - diagram layout has completed.
     * @name on
     * @memberof dc_graph.diagram
     * @instance
     * @param {String} [event] - the event to subscribe to
     * @param {Function} [f] - the event handler
     * @return {dc_graph.diagram}
     **/
    _chart.on = function(event, f) {
        _dispatch.on(event, f);
        return this;
    };

    /**
     * Returns an object with current statistics on graph layout.
     * * `nnodes` - number of nodes displayed
     * * `nedges` - number of edges displayed
     * @name getStats
     * @memberof dc_graph.diagram
     * @instance
     * @return {}
     * @return {dc_graph.diagram}
     **/
    _chart.getStats = function() {
        return _stats;
    };


    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Execute a d3 single selection in the diagram's scope using the given selector
     * and return the d3 selection. Roughly the same as
     * ```js
     * d3.select('#diagram-id').select(selector)
     * ```
     * Since this function returns a d3 selection, it is not chainable. (However, d3 selection
     * calls can be chained after it.)
     * @name select
     * @memberof dc_graph.diagram
     * @instance
     * @param {String} [selector]
     * @return {d3.selection}
     * @return {dc_graph.diagram}
     **/
    _chart.select = function (s) {
        return _chart.root().select(s);
    };

    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Selects all elements that match the d3 single selector in the diagram's scope,
     * and return the d3 selection. Roughly the same as

     * ```js
     * d3.select('#diagram-id').selectAll(selector)
     * ```

     * Since this function returns a d3 selection, it is not chainable. (However, d3 selection
     * calls can be chained after it.)
     * @name selectAll
     * @memberof dc_graph.diagram
     * @instance
     * @param {String} [selector]
     * @return {d3.selection}
     * @return {dc_graph.diagram}
     **/
    _chart.selectAll = function (s) {
        return _chart.root() ? _chart.root().selectAll(s) : null;
    };

    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Returns the top svg element for this specific chart. You can also pass in a new
     * svg element, but setting the svg element on a diagram may have unexpected consequences.
     * @name svg
     * @memberof dc_graph.diagram
     * @instance
     * @param {d3.selection} [selection]
     * @return {d3.selection}
     * @return {dc_graph.diagram}

     **/
    _chart.svg = function (_) {
        if (!arguments.length) {
            return _svg;
        }
        _svg = _;
        return _chart;
    };

    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Remove the diagram's SVG elements from the dom and recreate the container SVG
     * element.
     * @name resetSvg
     * @memberof dc_graph.diagram
     * @instance
     * @return {dc_graph.diagram}
     **/
    _chart.resetSvg = function () {
        _chart.select('svg').remove();
        return generateSvg();
    };

    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Causes all charts in the chart group to be redrawn.
     * @name redrawGroup
     * @memberof dc_graph.diagram
     * @instance
     * @return {dc_graph.diagram}
     **/
    _chart.redrawGroup = function () {
        dc.redrawAll(chartGroup);
    };

    /**
     * Standard dc.js
     * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}
     * method. Causes all charts in the chart group to be rendered.
     * @name renderGroup
     * @memberof dc_graph.diagram
     * @instance
     * @return {dc_graph.diagram}
     **/
    _chart.renderGroup = function () {
        dc.renderAll(chartGroup);
    };

    /**
     * Creates an svg marker definition for drawing edge arrow tails or heads. The `viewBox` of
     * the marker is `0 -5 10 10`, so the arrow should be drawn from (0, -5) to (10, 5); it
     * will be moved and sized based on the other parameters, and rotated based on the
     * orientation of the edge.

     * (If further customization is required, it is possible to append other `svg:defs` to
     * `chart.svg()` and use refer to them by `id`.)
     * @name defineArrow
     * @memberof dc_graph.diagram
     * @instance
     * @param {Number} name - the identifier to give the marker, to be used with
     * {@link #dc_graph.diagram+edgeArrowhead edgeArrowhead} or
     * {@link #dc_graph.diagram+edgeArrowtail edgeArrowtail}
     * @param {Number} width - the width, in pixels, to draw the marker
     * @param {Number} height - the height, in pixels, to draw the marker
     * @param {Number} refX - the X reference position, in marker coordinates, which will be
     * aligned to the endpoint of the edge
     * @param {Number} refY - the Y reference position
     * @param {Function} drawf - a function to draw the marker using d3 SVG primitives, which
     * takes the marker object as its parameter.
     * @example
     * // the built-in `vee` arrow is defined like so:
     * _chart.defineArrow('vee', 12, 12, 10, 0, function(marker) {
     *   marker.append('svg:path')
     *     .attr('d', 'M0,-5 L10,0 L0,5 L3,0')
     *     .attr('stroke-width', '0px');
     * });
     * @return {dc_graph.diagram}
     **/
    _chart.defineArrow = function(name, width, height, refX, refY, drawf) {
        _arrows[name] = {
            name: name,
            width: width,
            height: height,
            refX: refX,
            refY: refY,
            drawFunction: drawf
        };
        return _chart;
    };

    _chart.addOrRemoveDef = function(id, whether, tag) {
        var data = whether ? [0] : [];
        var sel = _defs.selectAll('#' + id).data(data);

        var selEnter = sel
            .enter().append(tag)
                .attr('id', id);
        sel.exit().remove();
        return selEnter;
    };

    function edgeArrow(d, kind, name) {
        var id = _chart.arrowId(d, kind),
            markerEnter = _chart.addOrRemoveDef(id, !!name, 'svg:marker');

        if(name) {
            markerEnter
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', _arrows[name].refX)
                .attr('refY', _arrows[name].refY)
                .attr('markerUnits', 'userSpaceOnUse')
                .attr('markerWidth', _arrows[name].width*param(_chart.edgeArrowSize())(d))
                .attr('markerHeight', _arrows[name].height*param(_chart.edgeArrowSize())(d))
                .attr('stroke', param(_chart.edgeStroke())(d))
                .attr('fill', param(_chart.edgeStroke())(d))
                .call(_arrows[name].drawFunction);
        }
        return name ? id : null;
    }

    function doZoom() {
        _g.attr("transform", "translate(" + d3.event.translate + ")" + " scale(" + d3.event.scale + ")");
    }

    function resizeSvg() {
        if(_svg) {
            _svg.attr('width', _chart.width())
                .attr('height', _chart.height());
        }
    }

    function generateSvg() {
        _svg = _chart.root().append('svg');
        resizeSvg();

        _defs = _svg.append('svg:defs');

        if(_chart.mouseZoomable())
            _svg.call(d3.behavior.zoom().on("zoom", doZoom));

        return _svg;
    }

    _chart.defineArrow('vee', 12, 12, 10, 0, function(marker) {
        marker.append('svg:path')
            .attr('d', 'M0,-5 L10,0 L0,5 L3,0')
            .attr('stroke-width', '0px');
    });
    _chart.defineArrow('dot', 7, 7, 0, 0, function(marker) {
        marker.append('svg:circle')
            .attr('r', 5)
            .attr('cx', 5)
            .attr('cy', 0)
            .attr('stroke-width', '0px');
    });

    _chart.root(d3.select(parent));

    dc.registerChart(_chart, chartGroup);
    return _chart;
};
