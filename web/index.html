<!DOCTYPE html>
<html>
<head>
  <title>Thing</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="graph.css"/>
</head>

<body>
<h1>Thing.</h1>
<p>An example of drawing a graph from crossfilter data.</p>

<div id="graph"></div>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crossfilter/1.3.11/crossfilter.js"></script>
<script type="text/javascript" src="http://dc-js.github.io/dc.js/js/dc.js"></script>

<!-- not right, need grunt web -->
<script type="text/javascript" src="cola.js"></script>
<script type="text/javascript" src="../dc.graph.js"></script>

<script type="text/javascript">
  var diagram = dc_graph.diagram('#graph');

  d3.json("qfs.json", function(error, data) {
      if(error) {
          console.log(error);
          return;
      }
      var edge_ndx = crossfilter(data.links),
          node_ndx = crossfilter(data.nodes);

      // these are just identity dimension/groups, with unique keys
      // more complex node/edge generation is possible, but it is more likely that
      // grouping will happen in other kinds of charts
      var nodeDim = node_ndx.dimension(function(d) { return d.name; }),
          edgeDim = edge_ndx.dimension(function(d) { return d.sourcename + '->' + d.targetname; }),
          nodeGroup = nodeDim.group().reduce(function(p, v) { return v; }, function() { return null; },function() { return null; }),
          edgeGroup = edgeDim.group().reduce(function(p, v) { return v; }, function() { return null; },function() { return null; });

      // reuse defaults out of laziness
      var constrainer = diagram.constrainer();
      constrainer.edge_enter = function(es, cs, nodes) {
          es.each(function(e) {
              var s = nodes[e.source], t = nodes[e.target];
              if(s.orig.value.class === 'Client' && t.orig.value.class === 'Metaserver') {
                  cs[e.orig.key] = {
                      left: e.source,
                      right: e.target,
                      axis: 'y',
                      gap: 100
                  }
                  // this one is just to untangle the diagram by putting metaserver left, client right
                  cs[e.orig.key+'-funny'] = {
                      left: e.target,
                      right: e.source,
                      axis: 'x',
                      gap: 650
                  }
              }
              else if(s.orig.value.class === 'Client' && t.orig.value.class === 'ChunkServer') {
                  cs[e.orig.key] = {
                      left: e.source,
                      right: e.target,
                      axis: 'y',
                      gap: 100
                  }
              }
              else if(s.orig.value.class === 'Metaserver' &&
                      (t.orig.value.class === 'Attached Volume' || t.orig.value.class === 'ChunkServer')) {
                  cs[e.orig.key] = {
                      left: e.source,
                      right: e.target,
                      axis: 'y',
                      gap: 300
                  }
              }
              else if(s.orig.value.class === 'ChunkServer' && t.orig.value.class === 'Attached Volume') {
                  cs[e.orig.key] = {
                      left: e.source,
                      right: e.target,
                      axis: 'y',
                      gap: 300
                  }
              }
          });
          return this;
      }

      diagram.width(960).height(1000)
          .nodeDim(nodeDim).nodeGroup(nodeGroup)
          .edgeDim(edgeDim).edgeGroup(edgeGroup)
          .sourceAccessor(function(e) { return e.value.sourcename; })
          .targetAccessor(function(e) { return e.value.targetname; })
          .constrainer(constrainer);

      diagram.render();
  });

</script>
</body>
</html>
