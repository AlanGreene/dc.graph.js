<!DOCTYPE html>
<html>
<head>
  <title>Network example</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="css/runner.css"/>
  <link rel="stylesheet" type="text/css" href="css/dc.graph.css"/>
  <link rel="stylesheet" type="text/css" href="css/dc.css"/>

  <script type="text/javascript" src="js/d3.js"></script>
  <script type="text/javascript" src="js/crossfilter.js"></script>
  <script type="text/javascript" src="js/dc.js"></script>

  <link rel="stylesheet" href="css/jquery-ui.css">
  <script type="text/javascript" src="js/jquery.js"></script>
  <script type="text/javascript" src="js/jquery-ui.js"></script>
  <script type="text/javascript" src="js/lodash.js"></script>

  <script type="text/javascript" src="js/cola.js"></script>
  <script type="text/javascript" src="js/dc.graph.js"></script>
  <script type="text/javascript" src="js/graphlib-dot.min.js"></script>

  <script type="text/javascript" src="qfs_constraints.js"></script>
</head>

<body>


<div id="graph" class="chart"></div>
<div id="controls" class="chart">
  <div id="time-range">
    <label id="now">&#x21e7;</label>
  </div>
  <div style="margin-top: 25px">
    <button onclick="start_stop()">stop/start</button>
    <div id="status"></div>
  </div>
  <div style="margin-top: 15px">
    <label><input type="checkbox" id="hierarchical" checked="true">Hierarchical</label>
  </div>
</div>


<script type="text/javascript">

  // http://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript
  var querystring = (function(a) {
      if (a == "") return {};
      var b = {};
      for (var i = 0; i < a.length; ++i)
      {
          var p=a[i].split('=', 2);
          if (p.length == 1)
              b[p[0]] = "";
          else
              b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
      }
      return b;
  })(window.location.search.substr(1).split('&'));

  var steptime = +querystring.interval || 1000, // ms per step
      pause = +querystring.pause || 2500, // pause at end of loop
      showSteps = +querystring.showsteps !== 0,
      file = querystring.file || null,
      generate = querystring.gen || null,
      doReinit = querystring.reinit==="0" ? false : true,
      doDisplacement = querystring.displace==="0" ? false : true,
      doAlignment = querystring.align==="0" ? false : true,
      isQFS = false,
      linkLength = querystring.linklength || 0,
      edgeColor = querystring.edgecolor || 'black',
      opacity = +querystring.opacity || 1,
      hierarchical = true;
  if('hier' in querystring) {
      hierarchical = !!+querystring.hier;
      $('#hierarchical').prop('checked', hierarchical);
  }
  if(edgeColor && /[0-9A-Fa-f]{6}/.test(edgeColor) || /[0-9A-Fa-f]{3}/.test(edgeColor))
      edgeColor = '#' + edgeColor;
  var min = 2, max = 12;
  var begin = min, end = 7, curr = begin;
  var timer = null, doRender = true;

  var diagram = dc_graph.diagram('#graph');

  function do_status() {
      $('#now').css('left', (curr-min)/(max-min)*100 + '%');
      $('#status').text('[' + begin + '..' + end + '] : ' + curr);
  }

  do_status();

  var source;
  if(!generate && !file)
      file = "qfs.json";
  isQFS = +querystring.qfs || file === 'qfs.json' && querystring.qfs !=="0";
  if(file)
      source = function(callback) {
          dc_graph.load_graph(file, callback);
      }
  else if(generate)
      source = function(callback) {
          var parts = /^([a-zA-Z]+)([0-9]*)/.exec(generate);
          if(!parts || !parts[0]) throw new Error("couldn't parse generator");
          var name = parts[1], N = +parts[2];
          dc_graph.generate(name, N, callback);
      }

  source(function(error, data) {
      if(error) {
          console.log(error);
          return;
      }
      var edge_ndx = crossfilter(data.links),
          node_ndx = crossfilter(data.nodes);

      // for this example we use simple identity dimension/groups, with unique keys
      // more complex node/edge generation is possible, but it is more likely that
      // grouping will happen in other kinds of charts

      // when there will be exactly one or zero items in a group, a reasonable reduction
      // is just to use the row or null
      function one_zero_reduce(group) {
          group.reduce(
              function(p, v) { return v; },
              function() { return null; },
              function() { return null; }
          );
      }
      var nodeDimension = node_ndx.dimension(function(d) { return d.name; }),
          edgeDimension = edge_ndx.dimension(function(d) { return d.sourcename + '-' + d.targetname; }),
          nodeGroup = nodeDimension.group(),
          edgeGroup = edgeDimension.group();

      one_zero_reduce(nodeGroup);
      one_zero_reduce(edgeGroup);

      function non_null(group) {
          return {
              all: function() {
                  return group.all().filter(function(kv) {
                      return kv.value !== null;
                  });
              }
          };
      }
      var nodeGroup1 = non_null(nodeGroup),
          edgeGroup1 = non_null(edgeGroup);

      var done = false, timedout = false;

      function start() {
          timedout = done = false;
          if(++curr>end) curr = begin;
          var t = curr < end ? steptime : pause;
          timer = setTimeout(function() {
              timedout = true;
              kontinue();
          }, t);
          tick();
      }
      function kontinue() {
          if(!done || !timedout)
              return;
          timer = null;
          if(!doStop)
              start();
          doStop = false;
      }

      function tick() {
          do_status();
          if(doReinit)
              diagram.initLayoutOnRedraw(hierarchical);
          startDim.filterRange([0, curr]);
          if(doRender) {
              dc.renderAll();
              doRender = false;
          }
          else
              dc.redrawAll();
          done = false;
      }
      var doStop = false;
      window.start_stop = function() {
          if(timer) {
              doStop = true;
          } else {
              start();
          }
      };

      function constrain(nodes, edges) {
          var constraints = [];
          if(doDisplacement && isQFS && hierarchical)
              constraints = qfs_edges(nodes, edges, constraints);
          if(doAlignment && isQFS && hierarchical)
              constraints = qfs_alignment(nodes, edges, constraints);

          var circles = {};
          nodes.forEach(function(n, i) {
              if(n.orig.value.circle) {
                  var circ = n.orig.value.circle;
                  if(!circles[circ]) circles[circ] = [];
                  circles[circ].push({node: i});
              }
          });
          for(var circ in circles)
              constraints.push({
                  type: 'circle',
                  nodes: circles[circ]
              });
          return constraints;
      }

      diagram
          .width($(window).width())
          .height($(window).height())
          .showLayoutSteps(showSteps)
          .nodeDimension(nodeDimension).nodeGroup(nodeGroup1)
          .edgeDimension(edgeDimension).edgeGroup(edgeGroup1)
          .sourceAccessor(function(e) { return e.value.sourcename; })
          .targetAccessor(function(e) { return e.value.targetname; })
          .nodeFillAccessor(isQFS ? qfs_color : 'white')
          .constrain(constrain)
          .lengthStrategy(generate ? 'individual' :
                          hierarchical ? 'none' :
                          'symmetric')
          .edgeArrowheadAccessor(function(kv) {
              return !kv.value.undirected;
          })
          .edgeOpacityAccessor(opacity)
          .edgeStrokeAccessor(edgeColor)
          .on('end', function() {
              done = true;
              kontinue();
          });
      if(linkLength)
          diagram.baseLength(linkLength)



      // this is kind of a brain-dead way to test transitions
      // i mean, you can cram the concept of adding and deleting stuff over time
      // into crossfilter data, but do you really want to do that?
      var startDim = node_ndx.dimension(function(d) { return d.start || 0; }),
          startGroup = startDim.group();


      $("#time-range").slider({
          range: true,
          min: min,
          max: max,
          values: [begin, end],
          slide: function( event, ui ) {
              begin = ui.values[0];
              end = ui.values[1];
              do_status();
          }
      });
      $('#hierarchical').change(function(val) {
          hierarchical = $(this).is(':checked');
          if(timer) // flag to do on timer
              doRender = true;
          else
              dc.renderAll();
      });

      // do not brush too fast
      dc.constants.EVENT_DELAY = 100;

      tick();
  });

</script>
</body>
</html>
