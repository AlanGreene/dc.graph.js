<!DOCTYPE html>
<html>
<head>
  <title>Network example</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="graph.css"/>
  <link rel="stylesheet" type="text/css" href="http://dc-js.github.io/dc.js/css/dc.css"/>
</head>

<body>

<div id="graph" class="chart"></div>
<div id="timeline" class="chart"></div>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crossfilter/1.3.11/crossfilter.js"></script>
<script type="text/javascript" src="http://dc-js.github.io/dc.js/js/dc.js"></script>

<!-- not right, need grunt web -->
<script type="text/javascript" src="cola.js"></script>
<script type="text/javascript" src="../dc.graph.js"></script>

<script type="text/javascript">

  var diagram = dc_graph.diagram('#graph');
  var timeline = dc.barChart('#timeline');


  d3.json("qfs.json", function(error, data) {
      if(error) {
          console.log(error);
          return;
      }
      var edge_ndx = crossfilter(data.links),
          node_ndx = crossfilter(data.nodes);

      // for this example we use simple identity dimension/groups, with unique keys
      // more complex node/edge generation is possible, but it is more likely that
      // grouping will happen in other kinds of charts

      // when there will be exactly one or zero items in a group, a reasonable reduction
      // is just to use the row or null
      function one_zero_reduce(group) {
          group.reduce(
              function(p, v) { return v; },
              function() { return null; },
              function() { return null; }
          );
      }
      var nodeDim = node_ndx.dimension(function(d) { return d.name; }),
          edgeDim = edge_ndx.dimension(function(d) { return d.sourcename + '->' + d.targetname; }),
          nodeGroup = nodeDim.group(),
          edgeGroup = edgeDim.group();

      one_zero_reduce(nodeGroup);
      one_zero_reduce(edgeGroup);

      function non_null(group) {
          return {
              all: function() {
                  return group.all().filter(function(kv) {
                      return kv.value !== null;
                  });
              }
          };
      }

      var nodeGroup1 = non_null(nodeGroup),
          edgeGroup1 = non_null(edgeGroup);

      function constrain(nodes, edges) {
          var constraints = [];
          edges.forEach(function(e) {
              var s = nodes[e.source], t = nodes[e.target];
              if(s.orig.value.class === 'Client' && t.orig.value.class === 'Metaserver') {
                  // vertical displacement for Client/Metaserver
                  constraints.push({
                      left: e.source,
                      right: e.target,
                      axis: 'y',
                      gap: 100
                  });
                  // this one is just to untangle the diagram by putting metaserver left, client right
                  constraints.push({
                      left: e.target,
                      right: e.source,
                      axis: 'x',
                      gap: 700
                  });
              }
              else if(s.orig.value.class === 'Client' && t.orig.value.class === 'ChunkServer') {
                  constraints.push({
                      left: e.source,
                      right: e.target,
                      axis: 'y',
                      gap: 100
                  });
              }
              else if(s.orig.value.class === 'Metaserver' &&
                      (t.orig.value.class === 'Attached Volume' || t.orig.value.class === 'ChunkServer')) {
                  constraints.push({
                      left: e.source,
                      right: e.target,
                      axis: 'y',
                      gap: 300
                  });
              }
              else if(s.orig.value.class === 'ChunkServer' && t.orig.value.class === 'Attached Volume') {
                  constraints.push({
                      left: e.source,
                      right: e.target,
                      axis: 'y',
                      gap: 200
                  });
              }
          });
          // put ChunkServers and Volumes in same levels
          function level_start() {
              return {
                  offsets: [],
                  type: 'alignment',
                  axis: 'y'
              };
          }
          var CSLevel = level_start(),
              VolLevel = level_start();
          nodes.forEach(function(n, i) {
              switch(n.orig.value.class) {
              case 'ChunkServer':
                  CSLevel.offsets.push({node: i, offset: 0});
                  break;
              case 'Attached Volume':
                  VolLevel.offsets.push({node: i, offset: 0});
              }
          });
          if(CSLevel.offsets.length)
              constraints.push(CSLevel);
          if(VolLevel.offsets.length)
              constraints.push(VolLevel);
          return constraints;
      };

      diagram.width(900).height(1000)
          .nodeDim(nodeDim).nodeGroup(nodeGroup1)
          .edgeDim(edgeDim).edgeGroup(edgeGroup1)
          .sourceAccessor(function(e) { return e.value.sourcename; })
          .targetAccessor(function(e) { return e.value.targetname; })
          .nodeColorAccessor(function(n) {
              var colors = {
                  ChunkServer: d3.rgb(152,251,152),
                  Metaserver: d3.rgb(135,255,255),
                  "Attached Volume": d3.rgb(255,180,0),
                  Client: d3.rgb(150,184,255)
              };
              return colors[n.value.class];
          })
          .constrain(constrain);

      // this is kind of a brain-dead way to test transitions
      // i mean, you can cram the concept of adding and deleting stuff over time
      // into crossfilter data, but do you really want to do that?
      var startDim = node_ndx.dimension(function(d) { return d.start; }),
          startGroup = startDim.group();

      timeline.width(400).height(200)
          .x(d3.scale.linear().domain([0,12]))
          .xUnits(dc.units.integers)
          //.elasticX(true)
          .elasticY(true)
          .brushOn(true)
          .dimension(startDim)
          .group(startGroup);

      timeline.filter(dc.filters.RangedFilter(0,2));

      // do not brush too fast
      dc.constants.EVENT_DELAY = 100;

      dc.renderAll();
  });

</script>
</body>
</html>
