<!DOCTYPE html>
<html>
<head>
  <title>Thing</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="graph.css"/>
</head>

<body>
<h1>Thing.</h1>
<p>An example of drawing a graph from crossfilter data.</p>

<div id="graph"></div>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crossfilter/1.3.11/crossfilter.js"></script>
<script type="text/javascript" src="http://dc-js.github.io/dc.js/js/dc.js"></script>

<!-- not right, need grunt web -->
<script type="text/javascript" src="cola.js"></script>
<script type="text/javascript" src="../dc.graph.js"></script>

<script type="text/javascript">
  var diagram = dc_graph.diagram('#graph');

  d3.json("qfs.json", function(error, data) {
      if(error) {
          console.log(error);
          return;
      }
      var edge_ndx = crossfilter(data.links),
          node_ndx = crossfilter(data.nodes);

      // for this example we use simple identity dimension/groups, with unique keys
      // more complex node/edge generation is possible, but it is more likely that
      // grouping will happen in other kinds of charts

      // when there will be exactly one or zero items in a group, a reasonable reduction
      // is just to use the row or null
      function one_zero_reduce(group) {
          group.reduce(
              function(p, v) { return v; },
              function() { return null; },
              function() { return null; }
          );
      }
      var nodeDim = node_ndx.dimension(function(d) { return d.name; }),
          edgeDim = edge_ndx.dimension(function(d) { return d.sourcename + '->' + d.targetname; }),
          nodeGroup = nodeDim.group(),
          edgeGroup = edgeDim.group();

      one_zero_reduce(nodeGroup);
      one_zero_reduce(edgeGroup);

      function constrain(nodes, edges) {
          var constraints = [];
          edges.forEach(function(e) {
              var s = nodes[e.source], t = nodes[e.target];
              if(s.orig.value.class === 'Client' && t.orig.value.class === 'Metaserver') {
                  // vertical displacement for Client/Metaserver
                  constraints.push({
                      left: e.source,
                      right: e.target,
                      axis: 'y',
                      gap: 100
                  });
                  // this one is just to untangle the diagram by putting metaserver left, client right
                  constraints.push({
                      left: e.target,
                      right: e.source,
                      axis: 'x',
                      gap: 650
                  });
              }
              else if(s.orig.value.class === 'Client' && t.orig.value.class === 'ChunkServer') {
                  constraints.push({
                      left: e.source,
                      right: e.target,
                      axis: 'y',
                      gap: 100
                  });
              }
              else if(s.orig.value.class === 'Metaserver' &&
                      (t.orig.value.class === 'Attached Volume' || t.orig.value.class === 'ChunkServer')) {
                  constraints.push({
                      left: e.source,
                      right: e.target,
                      axis: 'y',
                      gap: 300
                  });
              }
              else if(s.orig.value.class === 'ChunkServer' && t.orig.value.class === 'Attached Volume') {
                  constraints.push({
                      left: e.source,
                      right: e.target,
                      axis: 'y',
                      gap: 200
                  });
              }
          });
          // put ChunkServers and Volumes in same levels
          function level_start() {
              return {
                  offsets: [],
                  type: 'alignment',
                  axis: 'y'
              };
          }
          var CSLevel = level_start(),
              VolLevel = level_start();
          nodes.forEach(function(n, i) {
              switch(n.orig.value.class) {
              case 'ChunkServer':
                  CSLevel.offsets.push({node: i, offset: 0});
                  break;
              case 'Attached Volume':
                  VolLevel.offsets.push({node: i, offset: 0});
              }
          });
          constraints.push(CSLevel, VolLevel);
          return constraints;
      };

      diagram.width(960).height(1000)
          .nodeDim(nodeDim).nodeGroup(nodeGroup)
          .edgeDim(edgeDim).edgeGroup(edgeGroup)
          .sourceAccessor(function(e) { return e.value.sourcename; })
          .targetAccessor(function(e) { return e.value.targetname; })
          .constrain(constrain);

      diagram.render();
  });

</script>
</body>
</html>
