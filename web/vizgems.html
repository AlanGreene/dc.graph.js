<!DOCTYPE html>
<html>
<head>
  <title>Vizgems co-viewer</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="css/dc.graph.css"/>
  <link rel="stylesheet" type="text/css" href="css/vizgems.css"/>
  <link rel="stylesheet" type="text/css" href="css/dc.css"/>

  <script type="text/javascript" src="js/d3.js"></script>
  <script type="text/javascript" src="js/crossfilter.js"></script>
  <script type="text/javascript" src="js/dc.js"></script>

  <script type="text/javascript" src="js/queue.js"></script>
  <script type="text/javascript" src="js/jquery.js"></script>
  <script type="text/javascript" src="js/lodash.js"></script>

  <script type="text/javascript" src="js/cola.js"></script>
  <script type="text/javascript" src="js/dc.graph.js"></script>
  <script type="text/javascript" src="js/colorbrewer.js"></script>

  <script type="text/javascript" src="js/runner.js"></script>
</head>

<body>


<div id="graph" class="chart"></div>
<div id="controls" class="chart">
  <div id="graph-stats"></div>
</div>

<script type="text/javascript">
  var querystring = (function(a) {
      if (a == "") return {};
      var b = {};
      for (var i = 0; i < a.length; ++i)
      {
          var p=a[i].split('=', 2);
          if (p.length == 1)
              b[p[0]] = "";
          else
              b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
      }
      return b;
  })(window.location.search.substr(1).split('&'));

  var url = querystring.url, vertices_url = url + '/nodes.psv', edges_url = url + '/edges.psv';
  var interval = querystring.interval || 1000;

  var diagram = dc_graph.diagram('#graph');
  var node_inv = {}, edge_inv = {};

  function nocache_query() {
      return '?nocache=' + Date.now();
  }

  function load(get_inv, callback) {
      var psv = d3.dsv("|", "text/plain");
      var Q = queue()
          .defer(psv, vertices_url + nocache_query())
          .defer(psv, edges_url + nocache_query());
      if(get_inv) {
          var inv_nodes_url = url + '/inv-nodes.psv', inv_edges_url = url + '/inv-edges.psv';
          Q.defer(psv, inv_nodes_url + nocache_query())
              .defer(psv, inv_edges_url + nocache_query())
      }
      Q.await(function(error, vertices, edges, inv_vertices, inv_edges) {
          if(error)
              throw new Error(error);
          if(inv_vertices) {
              node_inv = {};
              inv_vertices.forEach(function(n) {
                  var nn = node_inv[n.id] = node_inv[n.id] || {};
                  nn[n.key] = n.val;
              });
              for(var id in node_inv) {
                  var n = node_inv[id];
                  // if it has a host field, alias that key
                  if('host' in n)
                      node_inv[n.host] = n;
                  // rename attribute that will collide with cache
                  n.itype = n.type;
                  delete n.type;
                  // remove ostype prefix from name
                  n.name = n.name.replace(/^[^:]*:/,'');
              };
          }
          if(inv_edges) {
              edge_inv = {};
              inv_edges.forEach(function(e) {
                  var id = e.id1 + '|' + e.id2;
                  var ee = edge_inv[e.id] = node_inv[e.id] || {};
                  ee[e.key] = e.val;
              });
          }

          // in cache, edges seems to be a superset of vertices, use that instead
          vertices = edges.filter(function(e) {
              return !e.id2;
          });
          edges = edges.filter(function(e) {
              return !!e.id2;
          });

          // populate vertex/edge properties from inventory, but warn about any problems
          var warnings = [];
          vertices.forEach(function(n) {
              var invn = node_inv[n.id1];
              if(!invn) {
                  warnings.push('node ' + n.id1 + ' not found in inventory');
                  return;
              }
              for(var a in n)
                  if(a in invn && n[a] !== invn[a])
                      warnings.push('attr ' + a + ' of node ' + n.id1 + ': ' + n[a] + ' is not ' + invn[a]);
              _.extend(n, invn);
          });
          edges.forEach(function(e) {
              var id = e.id1 + '|' + e.id2;
              var inve = edge_inv[id];
              if(!inve) {
                  warnings.push('edge ' + id + ' not found in inventory');
                  return;
              }
              for(var a in e)
                  if(a in inve && e[a] !== inve[a])
                      warnings.push('attr ' + a + ' of edge ' + id + ': ' + e[a] + ' is not ' + inve[a]);
              _.extend(e, inve);
          });
          if(warnings.length)
              console.log('inventory/cache warnings', warnings);
          callback(vertices, edges);
      });
  }

  function crossfilters(nodes, edges) {
      var edge_ndx = crossfilter(edges),
          node_ndx = crossfilter(nodes);

      // when there will be exactly one or zero items in a group, a reasonable reduction
      // is just to use the row or null
      function one_zero_reduce(group) {
          group.reduce(
              function(p, v) { return v; },
              function() { return null; },
              function() { return null; }
          );
      }

      var nodeDimension = node_ndx.dimension(function(d) { return d.id1; }),
          edgeDimension = edge_ndx.dimension(function(d) { return d.id1 + '-' + d.id2; }),
          nodeGroup = nodeDimension.group(),
          edgeGroup = edgeDimension.group(),
          badNodesFilter = node_ndx.dimension(function(d) { return d.id1; });

      badNodesFilter.filter(function(kv) { return kv != 'UNKNOWN'; });

      one_zero_reduce(nodeGroup);
      one_zero_reduce(edgeGroup);

      function non_null(group) {
          return {
              all: function() {
                  return group.all().filter(function(kv) {
                      return kv.value !== null && kv.value.name != 'demosub';
                  });
              }
          };
      }
      var nodeGroup1 = non_null(nodeGroup),
          edgeGroup1 = non_null(edgeGroup);
      return {nodeDimension: nodeDimension, nodeGroup: nodeGroup1,
              edgeDimension: edgeDimension, edgeGroup: edgeGroup1};
  }

  var ostypes = {
      CUS: "CUS",
      PRT: "PRT",
      NET: "NET",
      VM: "Virtual Machine",
      FS: "File System",
      IMG: "IMG",
      RTR: "Router",
      U: "User",
      SUB: "Subnet",
      undefined: 'Unknown'
  };

  function init() {
      load(true, function(vertices, edges) {
          var cfs = crossfilters(vertices, edges);
          // basic diagram setup
          diagram
              .width($(window).width())
              .height($(window).height())
              .showLayoutSteps(false)
              .lengthStrategy('jaccard')
              .baseLength(20)
              .nodeDimension(cfs.nodeDimension).nodeGroup(cfs.nodeGroup)
              .edgeDimension(cfs.edgeDimension).edgeGroup(cfs.edgeGroup)
              .sourceAccessor(function(e) { return e.value.id1; })
              .targetAccessor(function(e) { return e.value.id2; })
              .modLayout(function(cola) {
                  cola.flowLayout('y', 80);
              })
              .on('end', function() {
                  runner.endStep();
              });

          // respond to browser resize (not necessary if width/height is static)
          $(window).resize(function() {
              diagram
                  .width($(window).width())
                  .height($(window).height())
          });

          function isUUID(s) {
              return /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(s);
          }

          // aesthetics: look at kv.value for node/edge attributes and return appropriate values
          diagram
              .initLayoutOnRedraw(true)
              .nodeStrokeWidthAccessor(0) // turn off outlines
              .nodeRadiusAccessor(30)
              .induceNodes(true) // drop zero-degree nodes for now
              .nodeLabelAccessor(function(kv) {
                  return isUUID(kv.value.name) ? kv.key : kv.value.name;
              })
              .nodeFillScale(d3.scale.ordinal(_.keys(ostypes)).range(colorbrewer.Paired[12]))
              .nodeFillAccessor(function(kv) {
                  return kv.value.ostype;
              })
              .edgeArrowheadAccessor(function(kv) {
                  return kv.value._label === 'on_path' ? 'vee' : null;
              });

          var exs = {};
          for(var ost in ostypes)
              exs[ostypes[ost]] = {ostype: ost};
          diagram.legend(
              dc_graph.legend().nodeWidth(70).nodeHeight(70).exemplars(exs));

          diagram.render();
          show_stats({totnodes: vertices.length, totedges: edges.length}, diagram.getStats());
      });
  }
  function step() {
      load(false, function(vertices, edges) {
          if(!vertices.length || !edges.length)
              return; // cola sometimes dies on empty input; hope that next iteration will succeed
          var cfs = crossfilters(vertices, edges);
          diagram
              .nodeDimension(cfs.nodeDimension).nodeGroup(cfs.nodeGroup)
              .edgeDimension(cfs.edgeDimension).edgeGroup(cfs.edgeGroup)
              .redraw();
          show_stats({totnodes: vertices.length, totedges: edges.length}, diagram.getStats());
      })
  }

  function show_stats(data_stats, layout_stats) {
      $('#graph-stats').html('<table><tr><td>Showing</td><td>' + layout_stats.nnodes + '/' + data_stats.totnodes + ' nodes</td></tr><tr><td></td><td>' + layout_stats.nedges + '/' + data_stats.totedges + ' edges</td></tr></table>');
  }

  var runner = make_runner(init, step, interval);
  runner.start();

</script>
