<!DOCTYPE html>
<html>
<head>
  <title>Vizgems co-viewer</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="css/dc.graph.css"/>
  <link rel="stylesheet" type="text/css" href="css/vizgems.css"/>
  <link rel="stylesheet" type="text/css" href="css/dc.css"/>

  <script type="text/javascript" src="js/d3.js"></script>
  <script type="text/javascript" src="js/crossfilter.js"></script>
  <script type="text/javascript" src="js/dc.js"></script>

  <script type="text/javascript" src="js/queue.js"></script>
  <script type="text/javascript" src="js/jquery.js"></script>
  <script type="text/javascript" src="js/lodash.js"></script>

  <script type="text/javascript" src="js/cola.js"></script>
  <script type="text/javascript" src="js/dc.graph.js"></script>
  <script type="text/javascript" src="js/colorbrewer.js"></script>

  <script type="text/javascript" src="js/runner.js"></script>
  <script type="text/javascript" src="js/querystring.js"></script>
</head>

<body>


<div id="graph" class="chart"></div>
<div id="overlay">
  <div id="graph-stats"></div>
  <div id="options">
    <label><input type="checkbox" id="hide-unknown">Hide Unknown</label><br />
    <label><input type="checkbox" id="hide-subnets">Hide Subnets</label>
  </div>
</div>

<script type="text/javascript">
  var qs = querystring.parse();
  var url = qs.url, vertices_url = url + '/nodes.psv', edges_url = url + '/edges.psv';

  var options = {
      interval: {
          default: 1000
      },
      timeLimit: {
          default: 750,
          query: 'limit'
      },
      hide_unknown: {
          default: false,
          query: 'hideUnknown',
          selector: '#hide-unknown',
          change: function(val) {
              if(filters.filterIds) {
                  filters.filterIds.filter(val ?
                                           function(k) { return k != 'UNKNOWN'; } :
                                           null);
                  diagram.redraw();
              }
          }
      },
      hide_subnets: {
          default: false,
          query: 'hideSubnets',
          selector: '#hide-subnets',
          change: function(val) {
              if(filters.filterOSTypes) {
                  filters.filterOSTypes.filter(val ?
                                               function(k) { return k != 'SUB'; } :
                                               null);
                  diagram.redraw();
              }
          }
      }
  };

  var settings = {};
  function do_option(key, opt) {
      settings[key] = opt.default;
      var query = opt.query || key;
      if(query in qs) {
          switch(typeof opt.default) {
          case 'boolean':
              settings[key] = qs[query] === 'true';
              break;
          case 'number':
              settings[key] = +qs[query];
              break;
          default: throw new Error('unsupported query type ' + typeof opt.default);
          }
      }
      if(opt.selector) {
          switch(typeof opt.default) {
          case 'boolean':
              $(opt.selector)
                  .prop('checked', settings[key])
                  .change(function() {
                      var val = $(this).is(':checked');
                      if(opt.query) {
                          qs[opt.query] = '' + val;
                          querystring.update(qs);
                      }
                      if(opt.change)
                          opt.change(val);
                  });
              break;
          default: throw new Error('unsupported selector type ' + typeof opt.default);
          }
      }
  }
  for(var key in options)
      do_option(key, options[key]);

  var filters = {};
  var diagram = dc_graph.diagram('#graph');
  var node_inv = {}, edge_inv = {};

  function nocache_query() {
      return '?nocache=' + Date.now();
  }

  function load(get_inv, callback) {
      var psv = d3.dsv("|", "text/plain");
      var Q = queue()
          .defer(psv, vertices_url + nocache_query())
          .defer(psv, edges_url + nocache_query());
      if(get_inv) {
          var inv_nodes_url = url + '/inv-nodes.psv', inv_edges_url = url + '/inv-edges.psv';
          Q.defer(psv, inv_nodes_url + nocache_query())
              .defer(psv, inv_edges_url + nocache_query())
      }
      Q.await(function(error, vertices, edges, inv_vertices, inv_edges) {
          if(error)
              throw new Error(error);
          if(inv_vertices) {
              node_inv = {};
              inv_vertices.forEach(function(n) {
                  var nn = node_inv[n.id] = node_inv[n.id] || {};
                  nn[n.key] = n.val;
              });
              for(var id in node_inv) {
                  var n = node_inv[id];
                  // if it has a host field, alias that key
                  if('host' in n)
                      node_inv[n.host] = n;
                  // rename attribute that will collide with cache
                  n.itype = n.type;
                  delete n.type;
                  // remove ostype prefix from name
                  n.name = n.name.replace(/^[^:]*:/,'');
              };
          }
          if(inv_edges) {
              edge_inv = {};
              inv_edges.forEach(function(e) {
                  var id = e.id1 + '|' + e.id2;
                  var ee = edge_inv[e.id] = node_inv[e.id] || {};
                  ee[e.key] = e.val;
              });
          }

          // in cache, edges seems to be a superset of vertices, use that instead
          vertices = edges.filter(function(e) {
              return !e.id2;
          });
          edges = edges.filter(function(e) {
              return !!e.id2;
          });

          // populate vertex/edge properties from inventory, but warn about any problems
          var warnings = [];
          vertices.forEach(function(n) {
              var invn = node_inv[n.id1];
              if(!invn) {
                  warnings.push('node ' + n.id1 + ' not found in inventory');
                  return;
              }
              for(var a in n)
                  if(a in invn && n[a] !== invn[a])
                      warnings.push('attr ' + a + ' of node ' + n.id1 + ': ' + n[a] + ' is not ' + invn[a]);
              _.extend(n, invn);
          });
          edges.forEach(function(e) {
              var id = e.id1 + '|' + e.id2;
              var inve = edge_inv[id];
              if(!inve) {
                  warnings.push('edge ' + id + ' not found in inventory');
                  return;
              }
              for(var a in e)
                  if(a in inve && e[a] !== inve[a])
                      warnings.push('attr ' + a + ' of edge ' + id + ': ' + e[a] + ' is not ' + inve[a]);
              _.extend(e, inve);
          });
          if(warnings.length)
              console.log('inventory/cache warnings', warnings);
          callback(vertices, edges);
      });
  }

  function crossfilters(nodes, edges) {
      var edge_ndx = crossfilter(edges),
          node_ndx = crossfilter(nodes);

      // when there will be exactly one or zero items in a group, a reasonable reduction
      // is just to use the row or null
      function one_zero_reduce(group) {
          group.reduce(
              function(p, v) { return v; },
              function() { return null; },
              function() { return null; }
          );
      }

      var nodeDimension = node_ndx.dimension(function(d) { return d.id1; }),
          edgeDimension = edge_ndx.dimension(function(d) { return d.id1 + '-' + d.id2; }),
          nodeGroup = nodeDimension.group(),
          edgeGroup = edgeDimension.group(),
          filterIds = node_ndx.dimension(function(d) { return d.id1; }),
          filterOSTypes = node_ndx.dimension(function(d) { return d.ostype; });

      if(settings.hide_unknown)
          filterIds.filter(function(k) { return k != 'UNKNOWN'; });
      if(settings.hide_subnets)
          filterOSTypes.filter(function(k) { return k != 'SUB'; });

      one_zero_reduce(nodeGroup);
      one_zero_reduce(edgeGroup);

      function non_null(group) {
          return {
              all: function() {
                  return group.all().filter(function(kv) {
                      return kv.value !== null;
                  });
              }
          };
      }
      var nodeGroup1 = non_null(nodeGroup),
          edgeGroup1 = non_null(edgeGroup);
      return {nodeDimension: nodeDimension, nodeGroup: nodeGroup1,
              edgeDimension: edgeDimension, edgeGroup: edgeGroup1,
              filterIds: filterIds, filterOSTypes: filterOSTypes};
  }

  var ostypes = {
      CUS: "Customer",
      PRT: "Port",
      NET: "Network",
      VM: "Virtual Machine",
      FS: "File System",
      IMG: "Image",
      RTR: "Router",
      U: "User",
      SUB: "Subnet",
      undefined: 'Other'
  };

  function init() {
      load(true, function(vertices, edges) {
          filters = crossfilters(vertices, edges);
          // basic diagram setup
          diagram
              .width($(window).width())
              .height($(window).height())
              .showLayoutSteps(false)
              .timeLimit(settings.timeLimit)
              .lengthStrategy('jaccard')
              .baseLength(20)
              //.nodeFitLabelAccessor(false)
              .nodeDimension(filters.nodeDimension).nodeGroup(filters.nodeGroup)
              .edgeDimension(filters.edgeDimension).edgeGroup(filters.edgeGroup)
              .sourceAccessor(function(e) { return e.value.id1; })
              .targetAccessor(function(e) { return e.value.id2; })
              .modLayout(function(cola) {
                  cola.flowLayout('y', 80);
              })
              .on('end', function() {
                  runner.endStep();
              });

          // respond to browser resize (not necessary if width/height is static)
          $(window).resize(function() {
              diagram
                  .width($(window).width())
                  .height($(window).height())
          });

          function isUUID(s) {
              return /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(s);
          }

          // aesthetics: look at kv.value for node/edge attributes and return appropriate values
          diagram
              .initLayoutOnRedraw(true)
              .nodeStrokeWidthAccessor(0) // turn off outlines
              .nodeRadiusAccessor(30)
              .induceNodes(true) // drop zero-degree nodes for now
              .nodeLabelAccessor(function(kv) {
                  return isUUID(kv.value.name) ? kv.key : kv.value.name;
              })
              .nodeFillScale(d3.scale.ordinal(_.keys(ostypes)).range(colorbrewer.Paired[12]))
              .nodeFillAccessor(function(kv) {
                  return kv.value.ostype;
              })
              .edgeArrowheadAccessor(function(kv) {
                  return kv.value._label === 'on_path' ? 'vee' : null;
              });

          var exs = {};
          for(var ost in ostypes)
              exs[ostypes[ost]] = {ostype: ost};
          diagram.legend(
              dc_graph.legend().nodeWidth(70).nodeHeight(70).exemplars(exs));

          diagram.render();
          show_stats({totnodes: vertices.length, totedges: edges.length}, diagram.getStats());
      });
  }
  function step() {
      load(false, function(vertices, edges) {
          if(!vertices.length || !edges.length) {
              runner.endStep();
              return; // cola sometimes dies on empty input; hope that next iteration will succeed
          }
          filters = crossfilters(vertices, edges);
          diagram
              .nodeDimension(filters.nodeDimension).nodeGroup(filters.nodeGroup)
              .edgeDimension(filters.edgeDimension).edgeGroup(filters.edgeGroup)
              .redraw();
          show_stats({totnodes: vertices.length, totedges: edges.length}, diagram.getStats());
      })
  }

  function show_stats(data_stats, layout_stats) {
      $('#graph-stats').html('<table><tr><td>Showing</td><td>' + layout_stats.nnodes + '/' + data_stats.totnodes + ' nodes</td></tr><tr><td></td><td>' + layout_stats.nedges + '/' + data_stats.totedges + ' edges</td></tr></table>');
  }

  var runner = make_runner(init, step, settings.interval);
  runner.start();

</script>
