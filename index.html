<!DOCTYPE html>
<html>
<head>
  <title>Network example</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="css/runner.css"/>
  <link rel="stylesheet" type="text/css" href="css/dc.graph.css"/>
  <link rel="stylesheet" type="text/css" href="css/dc.css"/>

  <script type="text/javascript" src="js/d3.js"></script>
  <script type="text/javascript" src="js/crossfilter.js"></script>
  <script type="text/javascript" src="js/dc.js"></script>

  <link rel="stylesheet" href="css/jquery-ui.css">
  <script src="js/jquery.js"></script>
  <script src="js/jquery-ui.js"></script>

  <script type="text/javascript" src="js/cola.js"></script>
  <script type="text/javascript" src="js/dc.graph.js"></script>
  <script type="text/javascript" src="js/graphlib-dot.min.js"></script>
</head>

<body>


<div id="graph" class="chart"></div>
<div id="controls" class="chart" style="width: 400px">
  <div id="time-range">
    <label id="now">&#x21e7;</label>
  </div>
  <div style="margin-top: 25px">
    <button onclick="start_stop()">stop/start</button>
    <div id="status"></div>
  </div>
  <div style="margin-top: 15px">
    <label><input type="checkbox" id="hierarchical" checked="true">Hierarchical</label>
  </div>
</div>


<script type="text/javascript">

  // http://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript
  var querystring = (function(a) {
      if (a == "") return {};
      var b = {};
      for (var i = 0; i < a.length; ++i)
      {
          var p=a[i].split('=', 2);
          if (p.length == 1)
              b[p[0]] = "";
          else
              b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
      }
      return b;
  })(window.location.search.substr(1).split('&'));

  function load_graph(file, callback) {
      if(/\.json$/.test(file))
          d3.json(file, callback);
      else if(/\.gv|\.dot$/.test(file))
        d3.text(file, function (error, f) {
            if(error) {
                callback(error, null);
                return;
            }
            var digraph = graphlibDot.parse(f);

            var nodeNames = digraph.nodes();
            var nodes = new Array(nodeNames.length);
            nodeNames.forEach(function (name, i) {
                var v = nodes[i] = digraph._nodes[nodeNames[i]];
                v.id = i;
                v.name = name;
            });

            var edges = [];
            for (var e in digraph._edges) {
                var edge = digraph._edges[e];
                edges.push({ source: digraph._nodes[edge.u].id, target: digraph._nodes[edge.v].id });
            }
            var graph = {nodes: nodes, links: edges};
            callback(null, graph);
        })
  }

  var diagram = dc_graph.diagram('#graph');

  var steptime = +querystring.interval || 1000, // ms per step
      pause = +querystring.pause || 2500; // pause at end of loop
  var min = 2, max = 12;
  var begin = min, end = 7, curr = begin;
  var timer = null, doRender = true;
  var hierarchical = true;

  function do_status() {
      $('#now').css('left', (curr-min)/(max-min)*100 + '%');
      $('#status').text('[' + begin + '..' + end + '] : ' + curr);
  }

  do_status();

  var file = querystring.file || "qfs.json";

  load_graph(file, function(error, data) {
      if(error) {
          console.log(error);
          return;
      }
      var edge_ndx = crossfilter(data.links),
          node_ndx = crossfilter(data.nodes);

      // for this example we use simple identity dimension/groups, with unique keys
      // more complex node/edge generation is possible, but it is more likely that
      // grouping will happen in other kinds of charts

      // when there will be exactly one or zero items in a group, a reasonable reduction
      // is just to use the row or null
      function one_zero_reduce(group) {
          group.reduce(
              function(p, v) { return v; },
              function() { return null; },
              function() { return null; }
          );
      }
      var nodeDim = node_ndx.dimension(function(d) { return d.name; }),
          edgeDim = edge_ndx.dimension(function(d) { return d.sourcename + '->' + d.targetname; }),
          nodeGroup = nodeDim.group(),
          edgeGroup = edgeDim.group();

      one_zero_reduce(nodeGroup);
      one_zero_reduce(edgeGroup);

      function non_null(group) {
          return {
              all: function() {
                  return group.all().filter(function(kv) {
                      return kv.value !== null;
                  });
              }
          };
      }

      var nodeGroup1 = non_null(nodeGroup),
          edgeGroup1 = non_null(edgeGroup);
      var doReinit = querystring.reinit==="0" ? false : true,
          doDisplacement = querystring.displace==="0" ? false : true,
          doAlignment = querystring.align==="0" ? false : true,
          doLinkLength = false;
      var linkLength = 40;

      var done = false, timedout = false;
      function start() {
          timedout = done = false;
          if(++curr>end) curr = begin;
          tick();
          var t = curr < end ? steptime : pause;
          timer = setTimeout(function() {
              timedout = true;
              kontinue();
          }, t);
      }
      function kontinue() {
          if(!done || !timedout)
              return;
          timer = null;
          if(!doStop)
              start();
          doStop = false;
      }

      if(querystring.linklength) {
          doLinkLength = true;
          linklength = +querystring.linklength;
      }

      function constrain(nodes, edges) {
          var constraints = [];
          if(!hierarchical)
              return constraints;
          if(doDisplacement) {
              edges.forEach(function(e) {
                  var s = nodes[e.source], t = nodes[e.target];
                  if(s.orig.value.class === 'Client' && t.orig.value.class === 'Metaserver') {
                      // vertical displacement for Client/Metaserver
                      constraints.push({
                          left: e.source,
                          right: e.target,
                          axis: 'y',
                          gap: 50
                      });
                      // this one is just to untangle the diagram by putting metaserver left, client right
                      constraints.push({
                          left: e.target,
                          right: e.source,
                          axis: 'x',
                          gap: 200
                      });
                  }
                  else if(s.orig.value.class === 'Client' && t.orig.value.class === 'ChunkServer') {
                      constraints.push({
                          left: e.source,
                          right: e.target,
                          axis: 'y',
                          gap: 50
                      });
                  }
                  else if(s.orig.value.class === 'Metaserver' &&
                          (t.orig.value.class === 'Attached Volume' || t.orig.value.class === 'ChunkServer')) {
                      constraints.push({
                          left: e.source,
                          right: e.target,
                          axis: 'y',
                          gap: 100
                      });
                  }
                  else if(s.orig.value.class === 'ChunkServer' && t.orig.value.class === 'Attached Volume') {
                      constraints.push({
                          left: e.source,
                          right: e.target,
                          axis: 'y',
                          gap: 100
                      });
                  }
              });
          }
          if(doAlignment) {
              // put ChunkServers and Volumes in same levels
              function level_start() {
                  return {
                      offsets: [],
                      type: 'alignment',
                      axis: 'y'
                  };
              }
              var CSLevel = level_start(),
                  VolLevel = level_start();
              nodes.forEach(function(n, i) {
                  switch(n.orig.value.class) {
                  case 'ChunkServer':
                      CSLevel.offsets.push({node: i, offset: 0});
                      break;
                  case 'Attached Volume':
                      VolLevel.offsets.push({node: i, offset: 0});
                  }
              });
              if(CSLevel.offsets.length)
                  constraints.push(CSLevel);
              if(VolLevel.offsets.length)
                  constraints.push(VolLevel);
          }
          return constraints;
      };

      diagram.width(900).height(1000)
          .nodeDim(nodeDim).nodeGroup(nodeGroup1)
          .edgeDim(edgeDim).edgeGroup(edgeGroup1)
          .sourceAccessor(function(e) { return e.value.sourcename; })
          .targetAccessor(function(e) { return e.value.targetname; })
          .nodeColorAccessor(function(n) {
              var colors = {
                  ChunkServer: d3.rgb(152,251,152),
                  Metaserver: d3.rgb(135,255,255),
                  "Attached Volume": d3.rgb(255,180,0),
                  Client: d3.rgb(150,184,255)
              };
              return colors[n.value.class];
          })
          .constrain(constrain)
          .modLayout(function(layout) {
              if(!hierarchical || doLinkLength)
                  layout.symmetricDiffLinkLengths(linklength)
          })
          .on('end', function() {
              done = true;
              kontinue();
          });


      // this is kind of a brain-dead way to test transitions
      // i mean, you can cram the concept of adding and deleting stuff over time
      // into crossfilter data, but do you really want to do that?
      var startDim = node_ndx.dimension(function(d) { return d.start; }),
          startGroup = startDim.group();


      $("#time-range").slider({
          range: true,
          min: min,
          max: max,
          values: [begin, end],
          slide: function( event, ui ) {
              begin = ui.values[0];
              end = ui.values[1];
              do_status();
          }
      });
      $('#hierarchical').change(function(val) {
          hierarchical = $(this).is(':checked');
          if(timer) // flag to do on timer
              doRender = true;
          else
              dc.renderAll();
      });

      function tick() {
          do_status();
          if(doReinit)
              diagram.initLayoutOnRedraw(hierarchical);
          startDim.filterRange([0, curr]);
          if(doRender) {
              dc.renderAll();
              doRender = false;
          }
          else
              dc.redrawAll();
          done = false;
      }

      var doStop = false;
      window.start_stop = function() {
          if(timer) {
              doStop = true;
          } else {
              start();
          }
      };

      // do not brush too fast
      dc.constants.EVENT_DELAY = 100;

      tick();
  });

</script>
</body>
</html>
