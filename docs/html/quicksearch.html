<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"diagram.js.html":{"id":"diagram.js.html","title":"Source: diagram.js","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Source: diagram.js /** * `dc_graph.diagram` is a dc.js-compatible network visualization component. It registers in * the dc.js chart registry and its nodes and edges are generated from crossfilter groups. It * logically derives from the dc.js * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin}, * but it does not physically derive from it since so much is different about network * visualization versus conventional charts. * @class diagram * @memberof dc_graph * @param {String|node} parent - Any valid * {@link https://github.com/mbostock/d3/wiki/Selections#selecting-elements d3 single selector} * specifying a dom block element such as a div; or a dom element. * @param {String} [chartGroup] - The name of the dc.js chart group this diagram instance * should be placed in. Filter interaction with a diagram will only trigger events and redraws * within the diagram's group. * @return {dc_graph.diagram} **/ dc_graph.diagram = function (parent, chartGroup) { // different enough from regular dc charts that we don't use dc.baseMixin // but attempt to implement most of that interface, copying some of the most basic stuff var _diagram = dc.marginMixin({}); _diagram.__dcFlag__ = dc.utils.uniqueId(); _diagram.margins({left: 10, top: 10, right: 10, bottom: 10}); var _svg = null, _defs = null, _g = null, _nodeLayer = null, _edgeLayer = null; var _dispatch = d3.dispatch('preDraw', 'data', 'end', 'start', 'render', 'drawn', 'receivedLayout', 'transitionsStarted', 'zoomed', 'reset'); var _nodes = {}, _edges = {}; // hold state between runs var _ports = {}; // id = node|edge/id/name var _nodePorts; // ports sorted by node id var _stats = {}; var _nodes_snapshot, _edges_snapshot; var _arrows = {}; var _running = false; // for detecting concurrency issues var _translate = [0,0], _scale = 1; var _zoom, _animateZoom; var _anchor, _chartGroup; var _animating = false; // do not refresh during animations var _minWidth = 200; var _defaultWidthCalc = function (element) { var width = element &amp;&amp; element.getBoundingClientRect &amp;&amp; element.getBoundingClientRect().width; return (width &amp;&amp; width &gt; _minWidth) ? width : _minWidth; }; var _widthCalc = _defaultWidthCalc; var _minHeight = 200; var _defaultHeightCalc = function (element) { var height = element &amp;&amp; element.getBoundingClientRect &amp;&amp; element.getBoundingClientRect().height; return (height &amp;&amp; height &gt; _minHeight) ? height : _minHeight; }; var _heightCalc = _defaultHeightCalc; var _width, _height, _lastWidth, _lastHeight; function deprecate_layout_algo_parameter(name) { return function(value) { if(!_diagram.layoutEngine()) _diagram.layoutAlgorithm('cola', true); var engine = _diagram.layoutEngine(); if(engine.getEngine) engine = engine.getEngine(); if(engine[name]) { console.warn('property is deprecated, call on layout engine instead: dc_graph.diagram.%c' + name, 'font-weight: bold'); if(!arguments.length) return engine[name](); engine[name](value); } else { console.warn('property is deprecated, and is not supported for Warning: dc_graph.diagram.&lt;b&gt;' + name + '&lt;/b&gt; is deprecated, and it is not supported for the &quot;' + engine.layoutAlgorithm() + '&quot; layout algorithm: ignored.'); if(!arguments.length) return null; } return this; }; } /** * Set or get the height attribute of the diagram. If a value is given, then the diagram is * returned for method chaining. If no value is given, then the current value of the height * attribute will be returned. * * The width and height are applied to the SVG element generated by the diagram on render, or * when `resizeSvg` is called. * * If the value is falsy or a function, the height will be calculated the first time it is * needed, using the provided function or default height calculator, and then cached. The * default calculator uses the client rect of the element specified when constructing the chart, * with a minimum of `minHeight`. A custom calculator will be passed the element. * * If the value is `'auto'`, the height will be calculated every time the diagram is drawn, and * it will not be set on the `&lt;svg&gt;` element. Instead, the element will be pinned to the same * rectangle as its containing div using CSS. * * @method height * @memberof dc_graph.diagram * @instance * @param {Number} [height=200] * @return {Number} * @return {dc_graph.diagram} **/ _diagram.height = function (height) { if (!arguments.length) { if (!dc.utils.isNumber(_height)) { _lastHeight = _heightCalc(_diagram.root().node()); if(_height === 'auto') // 'auto' =&gt; calculate every time return _lastHeight; // null/undefined =&gt; calculate once only _height = _lastHeight; } return _height; } if(dc.utils.isNumber(height) || !height || height === 'auto') _height = height; else if(typeof height === 'function') { _heightCalc = height; _height = undefined; } else throw new Error(&quot;don't know what to do with height type &quot; + typeof height + &quot; value &quot; + height); return _diagram; }; _diagram.minHeight = function(height) { if(!arguments.length) return _minHeight; _minHeight = height; return _diagram; }; /** * Set or get the width attribute of the diagram. If a value is given, then the diagram is * returned for method chaining. If no value is given, then the current value of the width * attribute will be returned. * * The width and height are applied to the SVG element generated by the diagram on render, or * when `resizeSvg` is called. * * If the value is falsy or a function, the width will be calculated the first time it is * needed, using the provided function or default width calculator, and then cached. The default * calculator uses the client rect of the element specified when constructing the chart, with a * minimum of `minWidth`. A custom calculator will be passed the element. * * If the value is `'auto'`, the width will be calculated every time the diagram is drawn, and * it will not be set on the `&lt;svg&gt;` element. Instead, the element will be pinned to the same * rectangle as its containing div using CSS. * * @method width * @memberof dc_graph.diagram * @instance * @param {Number} [width=200] * @return {Number} * @return {dc_graph.diagram} **/ _diagram.width = function (width) { if (!arguments.length) { if (!dc.utils.isNumber(_width)) { _lastWidth = _widthCalc(_diagram.root().node()); if(_width === 'auto') // 'auto' =&gt; calculate every time return _lastWidth; // null/undefined =&gt; calculate once only _width = _lastWidth; } return _width; } if(dc.utils.isNumber(width) || !width || width === 'auto') _width = width; else if(typeof width === 'function') { _widthCalc = width; _width = undefined; } else throw new Error(&quot;don't know what to do with width type &quot; + typeof width + &quot; value &quot; + width); return _diagram; }; _diagram.minWidth = function(width) { if(!arguments.length) return _minWidth; _minWidth = width; return _diagram; }; /** * Get or set the root element, which is usually the parent div. Normally the root is set * when the diagram is constructed; setting it later may have unexpected consequences. * @method root * @memberof dc_graph.diagram * @instance * @param {node} [root=null] * @return {node} * @return {dc_graph.diagram} **/ _diagram.root = property(null).react(function(e) { if(e.empty()) console.log('Warning: parent selector ' + parent + &quot; doesn't seem to exist&quot;); }); /** * Get or set whether mouse wheel rotation or touchpad gestures will zoom the diagram, and * whether dragging on the background pans the diagram. * @method mouseZoomable * @memberof dc_graph.diagram * @instance * @param {Boolean} [mouseZoomable=true] * @return {Boolean} * @return {dc_graph.diagram} **/ _diagram.mouseZoomable = property(true); _diagram.zoomExtent = property([.1, 2]); /** * Whether zooming should only be enabled when the alt key is pressed. * @method altKeyZoom * @memberof dc_graph.diagram * @instance * @param {Boolean} [altKeyZoom=true] * @return {Boolean} * @return {dc_graph.diagram} **/ _diagram.modKeyZoom = _diagram.altKeyZoom = property(false); /** * Set or get the fitting strategy for the canvas, which affects how the translate * and scale get calculated when `autoZoom` is triggered. * * * `'default'` - simulates the preserveAspectRatio behavior of `xMidYMid meet`, but * with margins - the content is stretched or squished in the more constrained * direction, and centered in the other direction * * `'vertical'` - fits the canvas vertically (with vertical margins) and centers * it horizontally. If the canvas is taller than the viewport, it will meet * vertically and there will be blank areas to the left and right. If the canvas * is wider than the viewport, it will be sliced. * * `'horizontal'` - fits the canvas horizontally (with horizontal margins) and * centers it vertically. If the canvas is wider than the viewport, it will meet * horizontally and there will be blank areas above and below. If the canvas is * taller than the viewport, it will be sliced. * * Other options * * `null` - no attempt is made to fit the content in the viewport * * `'zoom'` - does not scale the content, but attempts to bring as much content * into view as possible, using using the same algorithm as `restrictPan` * * `'align_{tlbrc}[2]'` - does not scale; aligns up to two sides or centers them * @method fitStrategy * @memberof dc_graph.diagram * @instance * @param {String} [fitStrategy='default'] * @return {String} * @return {dc_graph.diagram} **/ _diagram.fitStrategy = property('default'); /** * Do not allow panning (scrolling) to push the diagram out of the viewable area, if there * is space for it to be shown. */ _diagram.restrictPan = property(false); /** * Auto-zoom behavior. * * `'always'` - zoom every time layout happens * * `'once'` - zoom the next time layout happens * * `null` - manual, call `zoomToFit` to fit * @method autoZoom * @memberof dc_graph.diagram * @instance * @param {String} [autoZoom=null] * @return {String} * @return {dc_graph.diagram} **/ _diagram.autoZoom = property(null); _diagram.zoomToFit = function(animate) { if(!(_nodeLayer &amp;&amp; _edgeLayer)) return; var node = _diagram.selectAllNodes(), edge = _diagram.selectAllEdges(); auto_zoom(node, edge, animate); }; _diagram.zoomDuration = property(500); /** * Set or get the crossfilter dimension which represents the nodes (vertices) in the * diagram. Typically there will be a crossfilter instance for the nodes, and another for * the edges. * * *Dimensions are included on the diagram for similarity to dc.js, however the diagram * itself does not use them - but {@link dc_graph.filter_selection filter_selection} will.* * @method nodeDimension * @memberof dc_graph.diagram * @instance * @param {crossfilter.dimension} [nodeDimension] * @return {crossfilter.dimension} * @return {dc_graph.diagram} **/ _diagram.nodeDimension = property(); /** * Set or get the crossfilter group which is the data source for the nodes in the * diagram. The diagram will use the group's `.all()` method to get an array of `{key, * value}` pairs, where the key is a unique identifier, and the value is usually an object * containing the node's attributes. All accessors work with these key/value pairs. * * If the group is changed or returns different values, the next call to `.redraw()` will * reflect the changes incrementally. * * It is possible to pass another object with the same `.all()` interface instead of a * crossfilter group. * @method nodeGroup * @memberof dc_graph.diagram * @instance * @param {crossfilter.group} [nodeGroup] * @return {crossfilter.group} * @return {dc_graph.diagram} **/ _diagram.nodeGroup = property(); /** * Set or get the crossfilter dimension which represents the edges in the * diagram. Typically there will be a crossfilter instance for the nodes, and another for * the edges. * * *Dimensions are included on the diagram for similarity to dc.js, however the diagram * itself does not use them - but {@link dc_graph.filter_selection filter_selection} will.* * @method edgeDimension * @memberof dc_graph.diagram * @instance * @param {crossfilter.dimension} [edgeDimension] * @return {crossfilter.dimension} * @return {dc_graph.diagram} **/ _diagram.edgeDimension = property(); /** * Set or get the crossfilter group which is the data source for the edges in the * diagram. See `.nodeGroup` above for the way data is loaded from a crossfilter group. * * The values in the key/value pairs returned by `diagram.edgeGroup().all()` need to * support, at a minimum, the {@link dc_graph.diagram#nodeSource nodeSource} and * {@link dc_graph.diagram#nodeTarget nodeTarget}, which should return the same * keys as the {@link dc_graph.diagram#nodeKey nodeKey} * * @method edgeGroup * @memberof dc_graph.diagram * @instance * @param {crossfilter.group} [edgeGroup] * @return {crossfilter.group} * @return {dc_graph.diagram} **/ _diagram.edgeGroup = property(); _diagram.edgesInFront = property(false); /** * Set or get the function which will be used to retrieve the unique key for each node. By * default, this accesses the `key` field of the object passed to it. The keys should match * the keys returned by the {@link dc_graph.diagram#edgeSource edgeSource} and * {@link dc_graph.diagram#edgeTarget edgeTarget}. * * @method nodeKey * @memberof dc_graph.diagram * @instance * @param {Function} [nodeKey=function(kv) { return kv.key }] * @return {Function} * @return {dc_graph.diagram} **/ _diagram.nodeKey = _diagram.nodeKeyAccessor = property(function(kv) { return kv.key; }); /** * Set or get the function which will be used to retrieve the unique key for each edge. By * default, this accesses the `key` field of the object passed to it. * * @method edgeKey * @memberof dc_graph.diagram * @instance * @param {Function} [edgeKey=function(kv) { return kv.key }] * @return {Function} * @return {dc_graph.diagram} **/ _diagram.edgeKey = _diagram.edgeKeyAccessor = property(function(kv) { return kv.key; }); /** * Set or get the function which will be used to retrieve the source (origin/tail) key of * the edge objects. The key must equal the key returned by the `.nodeKey` for one of the * nodes; if it does not, or if the node is currently filtered out, the edge will not be * displayed. By default, looks for `.value.sourcename`. * * @method edgeSource * @memberof dc_graph.diagram * @instance * @param {Function} [edgeSource=function(kv) { return kv.value.sourcename; }] * @return {Function} * @return {dc_graph.diagram} **/ _diagram.edgeSource = _diagram.sourceAccessor = property(function(kv) { return kv.value.sourcename; }); /** * Set or get the function which will be used to retrieve the target (destination/head) key * of the edge objects. The key must equal the key returned by the * {@link dc_graph.diagram#nodeKey nodeKey} for one of the nodes; if it does not, or if the node * is currently filtered out, the edge will not be displayed. By default, looks for * `.value.targetname`. * @method edgeTarget * @memberof dc_graph.diagram * @instance * @param {Function} [edgeTarget=function(kv) { return kv.value.targetname; }] * @return {Function} * @return {dc_graph.diagram} **/ _diagram.edgeTarget = _diagram.targetAccessor = property(function(kv) { return kv.value.targetname; }); _diagram.portDimension = property(null); _diagram.portGroup = property(null); _diagram.portNodeKey = property(null); _diagram.portEdgeKey = property(null); _diagram.portName = property(null); _diagram.portStyleName = property(null); _diagram.portElastic = property(true); _diagram.portStyle = named_children(); _diagram.portBounds = property(null); // position limits, in radians _diagram.edgeSourcePortName = property(null); _diagram.edgeTargetPortName = property(null); /** * Set or get the function which will be used to retrieve the radius, in pixels, for each * node. This determines the height of nodes,and if `nodeFitLabel` is false, the width too. * @method nodeRadius * @memberof dc_graph.diagram * @instance * @param {Function|Number} [nodeRadius=25] * @return {Function|Number} * @return {dc_graph.diagram} **/ _diagram.nodeRadius = _diagram.nodeRadiusAccessor = property(25); /** * Set or get the function which will be used to retrieve the stroke width, in pixels, for * drawing the outline of each node. According to the SVG specification, the outline will * be drawn half on top of the fill, and half outside. Default: 1 * @method nodeStrokeWidth * @memberof dc_graph.diagram * @instance * @param {Function|Number} [nodeStrokeWidth=1] * @return {Function|Number} * @return {dc_graph.diagram} **/ _diagram.nodeStrokeWidth = _diagram.nodeStrokeWidthAccessor = property(1); /** * Set or get the function which will be used to retrieve the stroke color for the outline * of each node. * @method nodeStroke * @memberof dc_graph.diagram * @instance * @param {Function|String} [nodeStroke='black'] * @return {Function|String} * @return {dc_graph.diagram} **/ _diagram.nodeStroke = _diagram.nodeStrokeAccessor = property('black'); _diagram.nodeStrokeDashArray = property(null); /** * If set, the value returned from `nodeFill` will be processed through this * {@link https://github.com/mbostock/d3/wiki/Scales d3.scale} * to return the fill color. If falsy, uses the identity function (no scale). * @method nodeFillScale * @memberof dc_graph.diagram * @instance * @param {Function|d3.scale} [nodeFillScale] * @return {Function|d3.scale} * @return {dc_graph.diagram} **/ _diagram.nodeFillScale = property(null); /** * Set or get the function which will be used to retrieve the fill color for the body of each * node. * @method nodeFill * @memberof dc_graph.diagram * @instance * @param {Function|String} [nodeFill='white'] * @return {Function|String} * @return {dc_graph.diagram} **/ _diagram.nodeFill = _diagram.nodeFillAccessor = property('white'); /** * Set or get the function which will be used to retrieve the opacity of each node. * @method nodeOpacity * @memberof dc_graph.diagram * @instance * @param {Function|Number} [nodeOpacity=1] * @return {Function|Number} * @return {dc_graph.diagram} **/ _diagram.nodeOpacity = property(1); /** * Set or get the padding or minimum distance, in pixels, for a node. (Will be distributed * to both sides of the node.) * @method nodePadding * @memberof dc_graph.diagram * @instance * @param {Function|Number} [nodePadding=6] * @return {Function|Number} * @return {dc_graph.diagram} **/ _diagram.nodePadding = property(6); /** * Set or get the padding, in pixels, for a node's label. If an object, should contain fields * `x` and `y`. If a number, will be applied to both x and y. * @method nodeLabelPadding * @memberof dc_graph.diagram * @instance * @param {Function|Number|Object} [nodeLabelPadding=0] * @return {Function|Number} * @return {dc_graph.diagram} **/ _diagram.nodeLabelPadding = property(0); /** * Set or get the line height for nodes with multiple lines of text, in ems. * @method nodeLineHeight * @memberof dc_graph.diagram * @instance * @param {Function|Number} [nodeLineHeight=1] * @return {Function|Number} * @return {dc_graph.diagram} **/ _diagram.nodeLineHeight = property(1); /** * Set or get the function which will be used to retrieve the label text to display in each * node. By default, looks for a field `label` or `name` inside the `value` field. * @method nodeLabel * @memberof dc_graph.diagram * @instance * @param {Function|String} [nodeLabel] * @return {Function|String} * @example * // Default behavior * diagram.nodeLabel(function(kv) { * return kv.value.label || kv.value.name; * }); * @return {dc_graph.diagram} **/ _diagram.nodeLabel = _diagram.nodeLabelAccessor = property(function(kv) { return kv.value.label || kv.value.name; }); _diagram.nodeLabelAlignment = property('center'); _diagram.nodeLabelDecoration = property(null); /** * Set or get the function which will be used to retrieve the label fill color. Default: null * @method nodeLabelFill * @memberof dc_graph.diagram * @instance * @param {Function|String} [nodeLabelFill=null] * @return {Function|String} * @return {dc_graph.diagram} **/ _diagram.nodeLabelFill = _diagram.nodeLabelFillAccessor = property(null); /** * Whether to fit the node shape around the label * @method nodeFitLabel * @memberof dc_graph.diagram * @instance * @param {Function|Boolean} [nodeFitLabel=true] * @return {Function|Boolean} * @return {dc_graph.diagram} **/ _diagram.nodeFitLabel = _diagram.nodeFitLabelAccessor = property(true); /** * The shape to use for drawing each node, specified as an object with at least the field * `shape`. The names of shapes are mostly taken * [from graphviz](http://www.graphviz.org/doc/info/shapes.html); currently ellipse, egg, * triangle, rectangle, diamond, trapezium, parallelogram, pentagon, hexagon, septagon, octagon, * invtriangle, invtrapezium, square, polygon are supported. * * If `shape = polygon`: * * `sides`: number of sides for a polygon * @method nodeShape * @memberof dc_graph.diagram * @instance * @param {Function|Object} [nodeShape={shape: 'ellipse'}] * @return {Function|Object} * @return {dc_graph.diagram} * @example * // set shape to diamond or parallelogram based on flag * diagram.nodeShape(function(kv) { * return {shape: kv.value.flag ? 'diamond' : 'parallelogram'}; * }); **/ _diagram.nodeShape = property(default_shape); // for defining custom (and standard) shapes _diagram.shape = named_children(); _diagram.shape('nothing', dc_graph.no_shape()); _diagram.shape('ellipse', dc_graph.ellipse_shape()); _diagram.shape('polygon', dc_graph.polygon_shape()); _diagram.shape('rounded-rect', dc_graph.rounded_rectangle_shape()); _diagram.shape('elaborated-rect', dc_graph.elaborated_rectangle_shape()); _diagram.nodeContent = property('text'); _diagram.content = named_children(); _diagram.content('text', dc_graph.text_contents()); // really looks like these should reside in an open namespace - this used only by an extension // but it's no less real than any other computed property _diagram.nodeIcon = property(null); /** * Set or get the function which will be used to retrieve the node title, usually rendered * as a tooltip. By default, uses the key of the node. * @method nodeTitle * @memberof dc_graph.diagram * @instance * @param {Function|String} [nodeTitle] * @return {Function|String} * @example * // Default behavior * diagram.nodeTitle(function(kv) { * return _diagram.nodeKey()(kv); * }); * @return {dc_graph.diagram} **/ _diagram.nodeTitle = _diagram.nodeTitleAccessor = property(function(kv) { return _diagram.nodeKey()(kv); }); /** * By default, nodes are added to the layout in the order that `.nodeGroup().all()` returns * them. If specified, `.nodeOrdering` provides an accessor that returns a key to sort the * nodes on. *It would be better not to rely on ordering to affect layout, but it may * affect the layout in some cases.* * @method nodeOrdering * @memberof dc_graph.diagram * @instance * @param {Function} [nodeOrdering=null] * @return {Function} * @return {dc_graph.diagram} **/ _diagram.nodeOrdering = property(null); /** * Specify an accessor that returns an {x,y} coordinate for a node that should be * {@link https://github.com/tgdwyer/WebCola/wiki/Fixed-Node-Positions fixed in place}, * and returns falsy for other nodes. * @method nodeFixed * @memberof dc_graph.diagram * @instance * @param {Function|Object} [nodeFixed=null] * @return {Function|Object} * @return {dc_graph.diagram} **/ _diagram.nodeFixed = _diagram.nodeFixedAccessor = property(null); /** * Set or get the function which will be used to retrieve the stroke color for the edges. * @method edgeStroke * @memberof dc_graph.diagram * @instance * @param {Function|String} [edgeStroke='black'] * @return {Function|String} * @return {dc_graph.diagram} **/ _diagram.edgeStroke = _diagram.edgeStrokeAccessor = property('black'); /** * Set or get the function which will be used to retrieve the stroke width for the edges. * @method edgeStrokeWidth * @memberof dc_graph.diagram * @instance * @param {Function|Number} [edgeStrokeWidth=1] * @return {Function|Number} * @return {dc_graph.diagram} **/ _diagram.edgeStrokeWidth = _diagram.edgeStrokeWidthAccessor = property(1); _diagram.edgeStrokeDashArray = property(null); /** * Set or get the function which will be used to retrieve the edge opacity, a number from 0 * to 1. * @method edgeOpacity * @memberof dc_graph.diagram * @instance * @param {Function|Number} [edgeOpacity=1] * @return {Function|Number} * @return {dc_graph.diagram} **/ _diagram.edgeOpacity = _diagram.edgeOpacityAccessor = property(1); /** * Set or get the function which will be used to retrieve the edge label text. The label is * displayed when an edge is hovered over. By default, uses the `edgeKey`. * @method edgeLabel * @memberof dc_graph.diagram * @instance * @param {Function|String} [edgeLabel] * @example * // Default behavior * diagram.edgeLabel(function(e) { * return _diagram.edgeKey()(e); * }); * @return {Function|String} * @return {dc_graph.diagram} **/ _diagram.edgeLabel = _diagram.edgeLabelAccessor = property(function(e) { return _diagram.edgeKey()(e); }); // vertical spacing when there are multiple lines of edge label _diagram.edgeLabelSpacing = property(12); /** * Set or get the function which will be used to retrieve the name of the arrowhead to use * for the target/ head/destination of the edge. Arrow symbols can be specified with * `.defineArrow()`. Return null to display no arrowhead. * @method edgeArrowhead * @memberof dc_graph.diagram * @instance * @param {Function|String} [edgeArrowhead='vee'] * @return {Function|String} * @return {dc_graph.diagram} **/ _diagram.edgeArrowhead = _diagram.edgeArrowheadAccessor = property('vee'); /** * Set or get the function which will be used to retrieve the name of the arrow tail to use * for the tail/source of the edge. Arrow symbols can be specified with * `.defineArrow()`. Return null to display no arrowtail. * @method edgeArrowtail * @memberof dc_graph.diagram * @instance * @param {Function|String} [edgeArrowtail=null] * @return {Function|String} * @return {dc_graph.diagram} **/ _diagram.edgeArrowtail = _diagram.edgeArrowtailAccessor = property(null); /** * Multiplier for arrow size. * @method edgeArrowSize * @memberof dc_graph.diagram * @instance * @param {Function|Number} [edgeArrowSize=1] * @return {Function|Number} * @return {dc_graph.diagram} **/ _diagram.edgeArrowSize = property(1); /** * To draw an edge but not have it affect the layout, specify a function which returns * false for that edge. By default, will return false if the `notLayout` field of the edge * value is truthy, true otherwise. * @method edgeIsLayout * @memberof dc_graph.diagram * @instance * @param {Function|Boolean} [edgeIsLayout] * @example * // Default behavior * diagram.edgeIsLayout(function(kv) { * return !kv.value.notLayout; * }); * @return {Function|Boolean} * @return {dc_graph.diagram} **/ _diagram.edgeIsLayout = _diagram.edgeIsLayoutAccessor = property(function(kv) { return !kv.value.notLayout; }); // if false, don't draw or layout the edge. this is not documented because it seems like // the interface could be better and this combined with edgeIsLayout. (currently there is // no way to layout but not draw an edge.) _diagram.edgeIsShown = property(true); /** * Currently, three strategies are supported for specifying the lengths of edges: * * 'individual' - uses the `edgeLength` for each edge. If it returns falsy, uses the * `baseLength` * * 'symmetric', 'jaccard' - compute the edge length based on the graph structure around * the edge. See * {@link https://github.com/tgdwyer/WebCola/wiki/link-lengths the cola.js wiki} * for more details. * 'none' - no edge lengths will be specified * * **Deprecated**: Use {@link dc_graph.cola_layout#lengthStrategy cola_layout.lengthStrategy} instead. * @method lengthStrategy * @memberof dc_graph.diagram * @instance * @param {Function|String} [lengthStrategy='symmetric'] * @return {Function|String} * @return {dc_graph.diagram} **/ _diagram.lengthStrategy = deprecate_layout_algo_parameter('lengthStrategy'); /** * When the `.lengthStrategy` is 'individual', this accessor will be used to read the * length of each edge. By default, reads the `distance` field of the edge. If the * distance is falsy, uses the `baseLength`. * @method edgeLength * @memberof dc_graph.diagram * @instance * @param {Function|Number} [edgeLength] * @example * // Default behavior * diagram.edgeLength(function(kv) { * return kv.value.distance; * }); * @return {Function|Number} * @return {dc_graph.diagram} **/ _diagram.edgeLength = _diagram.edgeDistanceAccessor = property(function(kv) { return kv.value.distance; }); /** * This should be equivalent to rankdir and ranksep in the dagre/graphviz nomenclature, but for * now it is separate. * * **Deprecated**: use {@link dc_graph.cola_layout#flowLayout cola_layout.flowLayout} instead. * @method flowLayout * @memberof dc_graph.diagram * @instance * @param {Object} [flowLayout] * @example * // No flow (default) * diagram.flowLayout(null) * // flow in x with min separation 200 * diagram.flowLayout({axis: 'x', minSeparation: 200}) **/ _diagram.flowLayout = deprecate_layout_algo_parameter('flowLayout'); /** * Direction to draw ranks. Currently for dagre and expand_collapse, but I think cola could be * generated from graphviz-style since it is more general. * * **Deprecated**: use {@link dc_graph.dagre_layout#rankdir dagre_layout.rankdir} instead. * @method rankdir * @memberof dc_graph.diagram * @instance * @param {String} [rankdir] **/ _diagram.rankdir = deprecate_layout_algo_parameter('rankdir'); /** * Gets or sets the default edge length (in pixels) when the `.lengthStrategy` is * 'individual', and the base value to be multiplied for 'symmetric' and 'jaccard' edge * lengths. * * **Deprecated**: use {@link dc_graph.cola_layout#baseLength cola_layout.baseLength} instead. * @method baseLength * @memberof dc_graph.diagram * @instance * @param {Number} [baseLength] * @return {Number} * @return {dc_graph.diagram} **/ _diagram.baseLength = deprecate_layout_algo_parameter('baseLength'); /** * Gets or sets the transition duration, the length of time each change to the diagram will * be animated. * @method transitionDuration * @memberof dc_graph.diagram * @instance * @param {Number} [transitionDuration=500] * @return {Number} * @return {dc_graph.diagram} **/ _diagram.transitionDuration = property(500); /** * How transitions should be split into separate animations to emphasize * the delete, modify, and insert operations: * * `none`: modify and insert operations animate at the same time * * `modins`: modify operations happen before inserts * * `insmod`: insert operations happen before modifies * * Deletions always happen before/during layout computation. * @method stageTransitions * @memberof dc_graph.diagram * @instance * @param {String} [stageTransitions='none'] * @return {String} * @return {dc_graph.diagram} **/ _diagram.stageTransitions = property('none'); /** * The delete transition happens simultaneously with layout, which can take longer * than the transition duration. Delaying it can bring it closer to the other * staged transitions. * @method deleteDelay * @memberof dc_graph.diagram * @instance * @param {Number} [deleteDelay=0] * @return {Number} * @return {dc_graph.diagram} **/ _diagram.deleteDelay = property(0); /** * Whether to put connected components each in their own group, to stabilize layout. * @method groupConnected * @memberof dc_graph.diagram * @instance * @param {String} [stageTransitions=false] * @return {String} * @return {dc_graph.diagram} **/ _diagram.groupConnected = deprecate_layout_algo_parameter('groupConnected'); /** * Gets or sets the maximum time spent doing layout for a render or redraw. Set to 0 for no * limit. * @method timeLimit * @memberof dc_graph.diagram * @instance * @param {Function|Number} [timeLimit=0] * @return {Function|Number} * @return {dc_graph.diagram} **/ _diagram.timeLimit = property(0); /** * Gets or sets a function which will be called with the current nodes and edges on each * redraw in order to derive new layout constraints. The constraints are built from scratch * on each redraw. * * This can be used to generate alignment (rank) or axis constraints. By default, no * constraints will be added, although cola.js uses constraints internally to implement * flow and overlap prevention. See * {@link https://github.com/tgdwyer/WebCola/wiki/Constraints the cola.js wiki} * for more details. * * For convenience, dc.graph.js implements a other constraints on top of those implemented * by cola.js: * * 'ordering' - the nodes will be ordered on the specified `axis` according to the keys * returned by the `ordering` function, by creating separation constraints using the * specified `gap`. * * 'circle' - (experimental) the nodes will be placed in a circle using &quot;wheel&quot; * edge lengths similar to those described in * {@link http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf Scalable, Versatile, and Simple Constrained Graph Layout} * *Although this is not as performant or stable as might be desired, it may work for * simple cases. In particular, it should use edge length *constraints*, which don't yet * exist in cola.js.* * * Because it is tedious to write code to generate constraints for a graph, **dc.graph.js** * also includes a {@link #dc_graph+constraint_pattern constraint generator} to produce * this constrain function, specifying the constraints themselves in a graph. * @method constrain * @memberof dc_graph.diagram * @instance * @param {Function} [constrain] * @return {Function} * @return {dc_graph.diagram} **/ _diagram.constrain = property(function(nodes, edges) { return []; }); /** * If there are multiple edges between the same two nodes, start them this many pixels away * from the original so they don't overlap. * @method parallelEdgeOffset * @memberof dc_graph.diagram * @instance * @param {Number} [parallelEdgeOffset=10] * @return {Number} * @return {dc_graph.diagram} **/ _diagram.parallelEdgeOffset = property(10); /** * By default, edges are added to the layout in the order that `.edgeGroup().all()` returns * them. If specified, `.edgeOrdering` provides an accessor that returns a key to sort the * edges on. * * *It would be better not to rely on ordering to affect layout, but it may affect the * layout in some cases. (Probably less than node ordering, but it does affect which * parallel edge is which.)* * @method edgeOrdering * @memberof dc_graph.diagram * @instance * @param {Function} [edgeOrdering=null] * @return {Function} * @return {dc_graph.diagram} **/ _diagram.edgeOrdering = property(null); _diagram.edgeSort = property(null); _diagram.cascade = cascade(_diagram); /** * Currently there are some bugs when the same instance of cola.js is used multiple * times. (In particular, overlaps between nodes may not be eliminated * {@link https://github.com/tgdwyer/WebCola/issues/118 if cola is not reinitialized} * This flag can be set true to construct a new cola layout object on each redraw. However, * layout seems to be more stable if this is set false, so hopefully this will be fixed * soon. * @method initLayoutOnRedraw * @memberof dc_graph.diagram * @instance * @param {Boolean} [initLayoutOnRedraw=false] * @return {Boolean} * @return {dc_graph.diagram} **/ _diagram.initLayoutOnRedraw = property(false); /** * Whether to perform layout when the data is unchanged from the last redraw. * @method layoutUnchanged * @memberof dc_graph.diagram * @instance * @param {Boolean} [layoutUnchanged=false] * @return {Boolean} * @return {dc_graph.diagram} **/ _diagram.layoutUnchanged = property(false); /** * When `layoutUnchanged` is false, this will force layout to happen again. This may be needed * when changing a parameter but not changing the topology of the graph. (Yes, probably should * not be necessary.) * @method relayout * @memberof dc_graph.diagram * @instance * @return {dc_graph.diagram} **/ _diagram.relayout = function() { _nodes_snapshot = _edges_snapshot = null; return this; }; /** * Function to call to generate an initial layout. Takes (diagram, nodes, edges) * * **Deprecated**: The only layout that was using this was `tree_positions` and it never * worked as an initialization step for cola, as was originally intended. Now that * `tree_layout` is a layout algorithm, this should go away. * * In the future, there will be support for chaining layout algorithms. But that will be a * matter of composing them into a super-algorithm, not a special step like this was. * @method initialLayout * @memberof dc_graph.diagram * @instance * @param {Function} [initialLayout=null] * @return {Function} * @return {dc_graph.diagram} **/ _diagram.initialLayout = deprecated_property('initialLayout is deprecated - use layout algorithms instead', null); _diagram.initialOnly = deprecated_property('initialOnly is deprecated - see the initialLayout deprecation notice in the documentation', false); /** * By default, all nodes are included, and edges are only included if both end-nodes are * visible. If `.induceNodes` is set, then only nodes which have at least one edge will be * shown. * @method induceNodes * @memberof dc_graph.diagram * @instance * @param {Boolean} [induceNodes=false] * @return {Boolean} * @return {dc_graph.diagram} **/ _diagram.induceNodes = property(false); /** * If this flag is true, the positions of nodes and will be updated while layout is * iterating. If false, the positions will only be updated once layout has * stabilized. Note: this may not be compatible with transitionDuration. * @method showLayoutSteps * @memberof dc_graph.diagram * @instance * @param {Boolean} [showLayoutSteps=false] * @return {Boolean} * @return {dc_graph.diagram} **/ _diagram.showLayoutSteps = property(false); /** * Assigns a legend object which will be displayed within the same SVG element and * according to the visual encoding of this diagram. * @method legend * @memberof dc_graph.diagram * @instance * @param {Object} [legend=null] * @return {Object} * @return {dc_graph.diagram} **/ // (pre-deprecated; see below) /** * Specifies another kind of child layer or interface. For example, this can * be used to display tooltips on nodes using `dc_graph.tip`. * The child needs to support a `parent` method, the diagram to modify. * @method child * @memberof dc_graph.diagram * @instance * @param {String} [id] - the name of the child to modify or add * @param {Object} [object] - the child object to add, or null to remove * @example * // Display tooltips on node hover, via the d3-tip library * var tip = dc_graph.tip() * tip.content(function(n, k) { * // you can do an asynchronous call here, e.g. d3.json, if you need * // to fetch data to show the tooltip - just call k() with the content * k(&quot;This is &lt;em&gt;&quot; + n.orig.value.name + &quot;&lt;/em&gt;&quot;); * }); * diagram.child('tip', tip); * @return {dc_graph.diagram} **/ _diagram.mode = _diagram.child = named_children(); // for backward compatibility; use .child() for more control &amp; multiple legends _diagram.legend = function(_) { if(!arguments.length) return _diagram.child('node-legend'); _diagram.child('node-legend', _); return _diagram; }; /** * Specify 'cola' (the default) or 'dagre' as the Layout Algorithm and it will replace the * back-end. * * **Deprecated**: use {@link dc_graph.diagram#layoutEngine diagram.layoutEngine} with the engine * object instead * @method layoutAlgorithm * @memberof dc_graph.diagram * @instance * @param {String} [algo='cola'] - the name of the layout algorithm to use * @example * // use dagre for layout * diagram.layoutAlgorithm('dagre'); * @return {dc_graph.diagram} **/ _diagram.layoutAlgorithm = function(value, skipWarning) { if(!arguments.length) return _diagram.layoutEngine() ? _diagram.layoutEngine().layoutAlgorithm() : 'cola'; if(!skipWarning) console.warn('dc.graph.diagram.layoutAlgorithm is depecrated - pass the layout engine object to dc_graph.diagram.layoutEngine instead'); var engine; switch(value) { case 'cola': engine = dc_graph.cola_layout(); break; case 'dagre': engine = dc_graph.dagre_layout(); } engine = dc_graph.webworker_layout(engine); _diagram.layoutEngine(engine); return this; }; /** * The layout engine determines how to draw things! * @method layoutEngine * @memberof dc_graph.diagram * @instance * @param {Object} [engine=null] - the layout engine to use * @example * // use cola with no webworker * diagram.layoutEngine(dc_graph.cola_layout()); * // use dagre with a webworker * diagram.layoutEngine(dc_graph.webworker_layout(dc_graph.dagre_layout())); **/ _diagram.layoutEngine = property(null).react(function(val) { if(val &amp;&amp; val.parent) val.parent(_diagram); if(_g) { // already rendered // remove any calculated points, if engine did that Object.keys(_edges).forEach(function(k) { _edges[k].cola.points = null; }); // initialize engine initLayout(val); } }); // S-spline any edges that are not going in this direction _diagram.enforceEdgeDirection = property(null); _diagram.tickSize = deprecate_layout_algo_parameter('tickSize'); _diagram.uniqueId = function() { return _diagram.anchorName().replace(/[ .#=\\[\\]&quot;]/g, '-'); }; _diagram.edgeId = function(e) { return 'edge-' + _diagram.edgeKey.eval(e).replace(/[^\\w-_]/g, '-'); }; _diagram.arrowId = function(e, kind) { return 'arrow-' + kind + '-' + _diagram.uniqueId() + '-' + _diagram.edgeId(e); }; _diagram.textpathId = function(e) { return 'textpath-' + _diagram.uniqueId() + '-' + _diagram.edgeId(e); }; // this kind of begs a (meta)graph ADT // instead of munging this into the diagram _diagram.getNode = function(id) { return _nodes[id] ? _nodes[id].orig : null; }; _diagram.getWholeNode = function(id) { return _nodes[id] ? _nodes[id] : null; }; _diagram.getEdge = function(id) { return _edges[id] ? _edges[id].orig : null; }; _diagram.getWholeEdge = function(id) { return _edges[id] ? _edges[id] : null; }; // again, awful, we need an ADT _diagram.getPort = function(nid, eid, name) { return _ports[port_name(nid, eid, name)]; }; _diagram.nodePorts = function() { return _nodePorts; }; /** * Instructs cola.js to fit the connected components. * * **Deprecated**: Use * {@link dc_graph.cola_layout#handleDisconnected cola_layout.handleDisconnected} instead. * @method handleDisconnected * @memberof dc_graph.diagram * @instance * @param {Boolean} [handleDisconnected=true] * @return {Boolean} * @return {dc_graph.diagram} **/ _diagram.handleDisconnected = deprecate_layout_algo_parameter('handleDisconnected'); function initLayout(engine) { if(!_diagram.layoutEngine()) _diagram.layoutAlgorithm('cola', true); (engine || _diagram.layoutEngine()).init({ width: _diagram.width(), height: _diagram.height() }); } _diagram.forEachChild = function(node, children, idf, f) { children.enum().forEach(function(key) { f(children(key), node.filter(function(n) { return idf(n) === key; })); }); }; _diagram.forEachShape = function(node, f) { _diagram.forEachChild(node, _diagram.shape, function(n) { return n.dcg_shape.shape; }, f); }; _diagram.forEachContent = function(node, f) { _diagram.forEachChild(node, _diagram.content, _diagram.nodeContent.eval, f); }; _diagram.renderNode = _diagram._enterNode = function(nodeEnter) { if(_diagram.nodeTitle()) nodeEnter.append('title'); nodeEnter.each(infer_shape(_diagram)); _diagram.forEachShape(nodeEnter, function(shape, node) { node.call(shape.create); }); return _diagram; }; _diagram.redrawNode = _diagram._updateNode = function(node) { var changedShape = node.filter(shape_changed(_diagram)); changedShape.selectAll('.node-shape').remove(); changedShape.each(infer_shape(_diagram)); _diagram.forEachShape(changedShape, function(shape, node) { node.call(shape.create); }); node.select('title') .text(_diagram.nodeTitle.eval); _diagram.forEachContent(node, function(contentType, node) { node.call(contentType.update); _diagram.forEachShape(contentType.selectContent(node), function(shape, content) { content .call(fit_shape(shape, _diagram)); }); }); _diagram.forEachShape(node, function(shape, node) { node.call(shape.update); }); node.select('.node-shape') .attr({ stroke: _diagram.nodeStroke.eval, 'stroke-width': _diagram.nodeStrokeWidth.eval, 'stroke-dasharray': _diagram.nodeStrokeDashArray.eval, fill: compose(_diagram.nodeFillScale() || identity, _diagram.nodeFill.eval) }); return _diagram; }; _diagram.redrawEdge = _diagram._updateEdge = function(edge) { edge .attr('stroke', _diagram.edgeStroke.eval) .attr('stroke-width', _diagram.edgeStrokeWidth.eval) .attr('stroke-dasharray', _diagram.edgeStrokeDashArray.eval) .attr('marker-end', function(e) { var name = _diagram.edgeArrowhead.eval(e), id = edgeArrow(_diagram, _arrows, e, 'head', name); return id ? 'url(#' + id + ')' : null; }) .attr('marker-start', function(e) { var name = _diagram.edgeArrowtail.eval(e), arrow_id = edgeArrow(_diagram, _arrows, e, 'tail', name); return name ? 'url(#' + arrow_id + ')' : null; }) .each(function(e) { var fillEdgeStroke = _diagram.edgeStroke.eval(e); d3.selectAll('#' + _diagram.arrowId(e, 'head')) .attr('fill', _diagram.edgeStroke.eval(e)); d3.selectAll('#' + _diagram.arrowId(e, 'tail')) .attr('fill', _diagram.edgeStroke.eval(e)); }); }; function has_source_and_target(e) { return !!e.source &amp;&amp; !!e.target; } // three stages: delete before layout, and modify &amp; insert split the transitionDuration _diagram.stagedDuration = function() { return (_diagram.stageTransitions() !== 'none') ? _diagram.transitionDuration() / 2 : _diagram.transitionDuration(); }; _diagram.stagedDelay = function(is_enter) { return _diagram.stageTransitions() === 'none' || _diagram.stageTransitions() === 'modins' === !is_enter ? 0 : _diagram.transitionDuration() / 2; }; _diagram.selectAllNodes = function(selector) { selector = selector || '.node'; return _nodeLayer &amp;&amp; _nodeLayer.selectAll(selector).filter(function(n) { return !n.deleted; }) || d3.selectAll('.foo-this-does-not-exist'); }; _diagram.selectAllEdges = function(selector) { selector = selector || '.edge'; return _edgeLayer &amp;&amp; _edgeLayer.selectAll(selector).filter(function(e) { return !e.deleted; }) || d3.selectAll('.foo-this-does-not-exist'); }; _diagram.selectAllDefs = function(selector) { return _defs &amp;&amp; _defs.selectAll(selector).filter(function(def) { return !def.deleted; }) || d3.selectAll('.foo-this-does-not-exist'); }; _diagram.isRunning = function() { return _running; }; /** * Standard dc.js * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin} * method. Computes a new layout based on the nodes and edges in the edge groups, and * displays the diagram. To the extent possible, the diagram will minimize changes in * positions from the previous layout. `.render()` must be called the first time, and * `.redraw()` can be called after that. * * `.redraw()` will be triggered by changes to the filters in any other charts in the same * dc.js chart group. * * Unlike in dc.js, `redraw` executes asynchronously, because drawing can be computationally * intensive, and the diagram will be drawn multiple times if * {@link #dc_graph.diagram+showLayoutSteps showLayoutSteps} * is enabled. Watch the {@link #dc_graph.diagram+on 'end'} event to know when layout is * complete. **/ var _needsRedraw = false; _diagram.redraw = function () { // since dc.js can receive UI events and trigger redraws whenever it wants, // and cola absolutely will not tolerate being poked while it's doing layout, // we need to guard the startLayout call. if(_running) { _needsRedraw = true; return this; } else return _diagram.startLayout(); }; function detect_size_change() { var oldWidth = _lastWidth, oldHeight = _lastHeight; var newWidth = _diagram.width(), newHeight = _diagram.height(); if(oldWidth !== newWidth || oldHeight !== newHeight) { var scale = _zoom.scale(), translate = _zoom.translate(); _zoom.scale(1).translate([0,0]); var xDomain = _diagram.x().domain(), yDomain = _diagram.y().domain(); _diagram.x() .domain([xDomain[0], xDomain[0] + (xDomain[1] - xDomain[0])*newWidth/oldWidth]) .range([0, newWidth]); _diagram.y() .domain([yDomain[0], yDomain[0] + (yDomain[1] - yDomain[0])*newHeight/oldHeight]) .range([0, newHeight]); _zoom .x(_diagram.x()).y(_diagram.y()) .translate(translate).scale(scale); } } _diagram.startLayout = function () { var nodes = _diagram.nodeGroup().all(); var edges = _diagram.edgeGroup().all(); var ports = _diagram.portGroup() ? _diagram.portGroup().all() : []; if(_running) { throw new Error('dc_graph.diagram.redraw already running!'); } _running = true; if(_width === 'auto' || _height === 'auto') detect_size_change(); else _diagram.resizeSvg(); if(_diagram.initLayoutOnRedraw()) initLayout(); _diagram.layoutEngine().stop(); _dispatch.preDraw(); // ordering shouldn't matter, but we support ordering in case it does if(_diagram.nodeOrdering()) { nodes = crossfilter.quicksort.by(_diagram.nodeOrdering())(nodes.slice(0), 0, nodes.length); } if(_diagram.edgeOrdering()) { edges = crossfilter.quicksort.by(_diagram.edgeOrdering())(edges.slice(0), 0, edges.length); } var wnodes = regenerate_objects(_nodes, nodes, null, function(v) { return _diagram.nodeKey()(v); }, function(v1, v) { v1.orig = v; v1.cola = v1.cola || {}; v1.cola.dcg_nodeKey = _diagram.nodeKey.eval(v1); _diagram.layoutEngine().populateLayoutNode(v1.cola, v1); }); var wedges = regenerate_objects(_edges, edges, null, function(e) { return _diagram.edgeKey()(e); }, function(e1, e) { e1.orig = e; e1.cola = e1.cola || {}; e1.cola.dcg_edgeKey = _diagram.edgeKey.eval(e1); e1.cola.dcg_edgeSource = _diagram.edgeSource.eval(e1); e1.cola.dcg_edgeTarget = _diagram.edgeTarget.eval(e1); e1.source = _nodes[e1.cola.dcg_edgeSource]; e1.target = _nodes[e1.cola.dcg_edgeTarget]; e1.cola.dcg_edgeLength = _diagram.edgeLength.eval(e1); e1.sourcePort = e1.sourcePort || {}; e1.targetPort = e1.targetPort || {}; _diagram.layoutEngine().populateLayoutEdge(e1.cola, e1); }); // remove edges that don't have both end nodes wedges = wedges.filter(has_source_and_target); // remove self-edges (since we can't draw them - will be option later) wedges = wedges.filter(function(e) { return e.source !== e.target; }); wedges = wedges.filter(_diagram.edgeIsShown.eval); // now we know which ports should exist var needports = wedges.map(function(e) { if(_diagram.edgeSourcePortName.eval(e)) return port_name(_diagram.edgeSource.eval(e), null, _diagram.edgeSourcePortName.eval(e)); else return port_name(null, _diagram.edgeKey.eval(e), 'source'); }); needports = needports.concat(wedges.map(function(e) { if(_diagram.edgeTargetPortName.eval(e)) return port_name(_diagram.edgeTarget.eval(e), null, _diagram.edgeTargetPortName.eval(e)); else return port_name(null, _diagram.edgeKey.eval(e), 'target'); })); // remove any invalid ports so they don't crash in confusing ways later ports = ports.filter(function(p) { return _diagram.portNodeKey() &amp;&amp; _diagram.portNodeKey()(p) || _diagram.portEdgeKey() &amp;&amp; _diagram.portEdgeKey()(p); }); var wports = regenerate_objects(_ports, ports, needports, function(p) { return port_name(_diagram.portNodeKey() &amp;&amp; _diagram.portNodeKey()(p), _diagram.portEdgeKey() &amp;&amp; _diagram.portEdgeKey()(p), _diagram.portName()(p)); }, function(p1, p) { p1.orig = p; if(p1.named) p1.edges = []; }, function(k, p) { console.assert(k, 'should have screened out invalid ports'); // it's dumb to parse the id we just created. as usual, i blame the lack of metagraphs var parse = split_port_name(k); if(parse.nodeKey) { p.node = _nodes[parse.nodeKey]; p.named = true; } else { var e = _edges[parse.edgeKey]; p.node = e[parse.name]; p.edges = [e]; p.named = false; } p.name = parse.name; }); // remove any ports where the end-node was not found, to avoid crashing elsewhere wports = wports.filter(function(p) { return p.node; }); // find all edges for named ports wedges.forEach(function(e) { var name = _diagram.edgeSourcePortName.eval(e); if(name) _ports[port_name(_diagram.nodeKey.eval(e.source), null, name)].edges.push(e); name = _diagram.edgeTargetPortName.eval(e); if(name) _ports[port_name(_diagram.nodeKey.eval(e.target), null, name)].edges.push(e); }); // optionally, delete nodes that have no edges if(_diagram.induceNodes()) { var keeps = {}; wedges.forEach(function(e) { keeps[e.cola.dcg_edgeSource] = true; keeps[e.cola.dcg_edgeTarget] = true; }); wnodes = wnodes.filter(function(n) { return keeps[n.cola.dcg_nodeKey]; }); for(var k in _nodes) if(!keeps[k]) delete _nodes[k]; } wnodes.forEach(function(v, i) { v.index = i; }); // announce new data _dispatch.data(_diagram, _nodes, wnodes, _edges, wedges, _ports, wports); _stats = {nnodes: wnodes.length, nedges: wedges.length}; // fixed nodes may have been affected by .data() so calculate now wnodes.forEach(function(v) { if(_diagram.nodeFixed()) v.cola.dcg_nodeFixed = _diagram.nodeFixed.eval(v); }); // annotate parallel edges so we can draw them specially if(_diagram.parallelEdgeOffset()) { var em = new Array(wnodes.length); for(var i = 0; i &lt; wnodes.length; ++i) em[i] = new Array(i); wedges.forEach(function(e) { e.pos = e.pos || {}; var min, max, minattr, maxattr; if(e.source.index &lt; e.target.index) { min = e.source.index; max = e.target.index; minattr = 'edgeSourcePortName'; maxattr = 'edgeTargetPortName'; } else { max = e.source.index; min = e.target.index; maxattr = 'edgeSourcePortName'; minattr = 'edgeTargetPortName'; } var minport = _diagram[minattr].eval(e) || 'no port', maxport = _diagram[maxattr].eval(e) || 'no port'; em[max][min] = em[max][min] || {}; em[max][min][maxport] = em[max][min][maxport] || {}; e.parallel = em[max][min][maxport][minport] = em[max][min][maxport][minport] || { rev: [], edges: [] }; e.parallel.edges.push(e); e.parallel.rev.push(min !== e.source.index); }); } // create edge SVG elements var edge = _edgeLayer.selectAll('.edge') .data(wedges, _diagram.edgeKey.eval); var edgeEnter = edge.enter().append('svg:path') .attr({ class: 'edge', id: _diagram.edgeId, opacity: 0 }) .each(function(e) { e.deleted = false; }); edge.exit().each(function(e) { e.deleted = true; }).transition() .duration(_diagram.stagedDuration()) .delay(_diagram.deleteDelay()) .attr('opacity', 0) .each(function(e) { edgeArrow(_diagram, _arrows, e, 'head', null); edgeArrow(_diagram, _arrows, e, 'tail', null); }) .remove(); if(_diagram.edgeSort()) { edge.sort(function(a, b) { var as = _diagram.edgeSort.eval(a), bs = _diagram.edgeSort.eval(b); return as &lt; bs ? -1 : bs &lt; as ? 1 : 0; }); } // another wider copy of the edge just for hover events var edgeHover = _edgeLayer.selectAll('.edge-hover') .data(wedges, _diagram.edgeKey.eval); var edgeHoverEnter = edgeHover.enter().append('svg:path') .attr('class', 'edge-hover') .attr('opacity', 0) .attr('fill', 'none') .attr('stroke', 'green') .attr('stroke-width', 10) .on('mouseover', function(e) { d3.select('#' + _diagram.edgeId(e) + '-label') .attr('visibility', 'visible'); }) .on('mouseout', function(e) { d3.select('#' + _diagram.edgeId(e) + '-label') .attr('visibility', 'hidden'); }); edgeHover.exit().remove(); var edgeLabels = _edgeLayer.selectAll('g.edge-label-wrapper') .data(wedges, _diagram.edgeKey.eval); var edgeLabelsEnter = edgeLabels.enter() .append('g') .attr('class', 'edge-label-wrapper') .attr('visibility', 'hidden') .attr('id', function(e) { return _diagram.edgeId(e) + '-label'; }); var textPaths = _defs.selectAll('path.edge-label-path') .data(wedges, _diagram.textpathId); var textPathsEnter = textPaths.enter() .append('svg:path').attr({ class: 'edge-label-path', id: _diagram.textpathId }); edgeLabels.exit().transition() .duration(_diagram.stagedDuration()) .delay(_diagram.deleteDelay()) .attr('opacity', 0).remove(); // create node SVG elements var node = _nodeLayer.selectAll('.node') .data(wnodes, _diagram.nodeKey.eval); var nodeEnter = node.enter().append('g') .attr('class', 'node') .attr('opacity', '0') // don't show until has layout .each(function(n) { n.deleted = false; }); // .call(_d3cola.drag); _diagram._enterNode(nodeEnter); node.exit().each(function(n) { n.deleted = true; }).transition() .duration(_diagram.stagedDuration()) .delay(_diagram.deleteDelay()) .attr('opacity', 0) .remove(); _dispatch.drawn(node, edge, edgeHover); _refresh(node, edge); // really we should have layout chaining like in the good old Dynagraph days // the ordering of this and the previous 4 statements is somewhat questionable if(_diagram.initialLayout()) _diagram.initialLayout()(_diagram, wnodes, wedges); // no layout if the topology and layout parameters haven't changed var skip_layout = false; if(!_diagram.layoutUnchanged()) { var nodes_snapshot = JSON.stringify(wnodes.map(function(n) { return {orig: get_original(n), cola: {dcg_nodeFixed: n.cola.dcg_nodeFixed}}; })); var edges_snapshot = JSON.stringify(wedges.map(function(e) { return {orig: get_original(e), cola: e.cola}; })); if(nodes_snapshot === _nodes_snapshot &amp;&amp; edges_snapshot === _edges_snapshot) skip_layout = true; _nodes_snapshot = nodes_snapshot; _edges_snapshot = edges_snapshot; } // cola constraints always use indices, but node references // are more friendly, so translate those // i am not satisfied with this constraint generation api... // https://github.com/dc-js/dc.graph.js/issues/10 var constraints = _diagram.constrain()(_diagram, wnodes, wedges); // translate references from names to indices (ugly) constraints.forEach(function(c) { if(c.type) { switch(c.type) { case 'alignment': c.offsets.forEach(function(o) { o.node = _nodes[o.node].index; }); break; case 'circle': c.nodes.forEach(function(n) { n.node = _nodes[n.node].index; }); break; } } else if(c.axis) { c.left = _nodes[c.left].index; c.right = _nodes[c.right].index; } }); // pseudo-cola.js features // 1. non-layout edges are drawn but not told to cola.js var layout_edges = wedges.filter(_diagram.edgeIsLayout.eval); var nonlayout_edges = wedges.filter(function(x) { return !_diagram.edgeIsLayout.eval(x); }); // 2. type=circle constraints var circle_constraints = constraints.filter(function(c) { return c.type === 'circle'; }); constraints = constraints.filter(function(c) { return c.type !== 'circle'; }); circle_constraints.forEach(function(c) { var R = (c.distance || _diagram.baseLength()*4) / (2*Math.sin(Math.PI/c.nodes.length)); var nindices = c.nodes.map(function(x) { return x.node; }); var namef = function(i) { return _diagram.nodeKey.eval(wnodes[i]); }; var wheel = dc_graph.wheel_edges(namef, nindices, R) .map(function(e) { var e1 = {internal: e}; e1.source = _nodes[e.sourcename]; e1.target = _nodes[e.targetname]; return e1; }); layout_edges = layout_edges.concat(wheel); }); // 3. ordered alignment var ordered_constraints = constraints.filter(function(c) { return c.type === 'ordering'; }); constraints = constraints.filter(function(c) { return c.type !== 'ordering'; }); ordered_constraints.forEach(function(c) { var sorted = c.nodes.map(function(n) { return _nodes[n]; }); if(c.ordering) { var sort = crossfilter.quicksort.by(param(c.ordering)); sorted = sort(sorted, 0, sorted.length); } var left; sorted.forEach(function(n, i) { if(i===0) left = n; else { constraints.push({ left: left.index, right: (left = n).index, axis: c.axis, gap: c.gap }); } }); }); if(skip_layout) { _running = false; draw(node, nodeEnter, edge, edgeEnter, edgeHover, edgeHoverEnter, edgeLabels, edgeLabelsEnter, textPaths, textPathsEnter, true); draw_ports(node); _dispatch.transitionsStarted(node, edge, edgeHover); check_zoom(node, edge); return this; } var startTime = Date.now(); function populate_cola(rnodes, redges) { rnodes.forEach(function(rn) { var n = _nodes[rn.dcg_nodeKey]; if(!n) { console.warn('received node &quot;' + rn.dcg_nodeKey + '&quot; that we did not send'); return; } n.cola.x = rn.x; n.cola.y = rn.y; }); redges.forEach(function(re) { var e = _edges[re.dcg_edgeKey]; if(!e) { console.warn('received edge &quot;' + re.dcg_edgeKey + '&quot; that we did not send'); return; } if(re.points) e.cola.points = re.points; }); } _diagram.layoutEngine() .on('tick', function(nodes, edges) { var elapsed = Date.now() - startTime; if(!_diagram.initialOnly()) populate_cola(nodes, edges); if(_diagram.showLayoutSteps()) { init_node_ports(_nodes, wports); _dispatch.receivedLayout(_diagram, _nodes, wnodes, _edges, wedges, _ports, wports); propagate_port_positions(_nodes, wedges, _ports); draw(node, nodeEnter, edge, edgeEnter, edgeHover, edgeHoverEnter, edgeLabels, edgeLabelsEnter, textPaths, textPathsEnter, true); draw_ports(node); // should do this only once _dispatch.transitionsStarted(node, edge, edgeHover); } if(_needsRedraw || _diagram.timeLimit() &amp;&amp; elapsed &gt; _diagram.timeLimit()) { console.log('cancelled'); _diagram.layoutEngine().stop(); } }) .on('end', function(nodes, edges) { if(!_diagram.showLayoutSteps()) { if(!_diagram.initialOnly()) populate_cola(nodes, edges); init_node_ports(_nodes, wports); _dispatch.receivedLayout(_diagram, _nodes, wnodes, _edges, wedges, _ports, wports); propagate_port_positions(_nodes, wedges, _ports); draw(node, nodeEnter, edge, edgeEnter, edgeHover, edgeHoverEnter, edgeLabels, edgeLabelsEnter, textPaths, textPathsEnter, true); draw_ports(node); _dispatch.transitionsStarted(node, edge, edgeHover); } else layout_done(true); check_zoom(node, edge); }) .on('start', function() { console.log('algo ' + _diagram.layoutEngine().layoutAlgorithm() + ' started.'); _dispatch.start(); }); if(_diagram.initialOnly()) _diagram.layoutEngine().dispatch().end(wnodes, wedges); else { _dispatch.start(); // cola doesn't seem to fire this itself? _diagram.layoutEngine().data( { width: _diagram.width(), height: _diagram.height() }, wnodes.map(function(v) { return Object.assign({}, v.cola, v.dcg_shape); }), layout_edges.map(function(v) { return v.cola; }), constraints ); _diagram.layoutEngine().start(); } return this; }; function check_zoom(node, edge) { var do_zoom, animate = true; switch(_diagram.autoZoom()) { case 'always-skipanimonce': animate = false; _diagram.autoZoom('always'); case 'always': do_zoom = true; break; case 'once-noanim': animate = false; case 'once': do_zoom = true; _diagram.autoZoom(null); break; default: do_zoom = false; } calc_bounds(node, edge); if(do_zoom) auto_zoom(animate); } function norm(v) { var len = Math.hypot(v[0], v[1]); return [v[0]/len, v[1]/len]; } function edge_vec(n, e) { var dy = e.target.cola.y - e.source.cola.y, dx = e.target.cola.x - e.source.cola.x; if(e.source !== n) dy = -dy, dx = -dx; if(e.parallel &amp;&amp; e.parallel.edges.length &gt; 1 &amp;&amp; e.source.index &gt; e.target.index) dy = -dy, dx = -dx; return norm([dx, dy]); } function init_node_ports(nodes, wports) { _nodePorts = {}; // assemble port-lists for nodes, again because we don't have a metagraph. wports.forEach(function(p) { var nid = _diagram.nodeKey.eval(p.node); var np = _nodePorts[nid] = _nodePorts[nid] || []; np.push(p); }); for(var nid in _nodePorts) { var n = nodes[nid], nports = _nodePorts[nid]; // initial positions: use average of edge vectors, if any, or existing position nports.forEach(function(p) { if(_diagram.portElastic.eval(p) &amp;&amp; p.edges.length) { var vecs = p.edges.map(edge_vec.bind(null, n)); p.vec = [ d3.sum(vecs, function(v) { return v[0]; })/vecs.length, d3.sum(vecs, function(v) { return v[1]; })/vecs.length ]; } else p.vec = p.vec || undefined; p.pos = null; }); } } function propagate_port_positions(nodes, wedges, ports) { // make sure we have projected vectors to positions for(var nid in _nodePorts) { var n = nodes[nid]; _nodePorts[nid].forEach(function(p) { if(!p.pos) project_port(_diagram, n, p); }); } // propagate port positions to edge endpoints wedges.forEach(function(e) { var name = _diagram.edgeSourcePortName.eval(e); e.sourcePort.pos = name ? ports[port_name(_diagram.nodeKey.eval(e.source), null, name)].pos : ports[port_name(null, _diagram.edgeKey.eval(e), 'source')].pos; name = _diagram.edgeTargetPortName.eval(e); e.targetPort.pos = name ? ports[port_name(_diagram.nodeKey.eval(e.target), null, name)].pos : ports[port_name(null, _diagram.edgeKey.eval(e), 'target')].pos; console.assert(e.sourcePort.pos &amp;&amp; e.targetPort.pos); }); } function _refresh(node, edge) { _diagram._updateEdge(edge); _diagram._updateNode(node); draw_ports(node); } _diagram.refresh = function(node, edge, edgeHover, edgeLabels, textPaths) { if(_animating) return this; // but what about changed attributes? node = node || _diagram.selectAllNodes(); edge = edge || _diagram.selectAllEdges(); _refresh(node, edge); edgeHover = edgeHover || _diagram.selectAllEdges('.edge-hover'); edgeLabels = edgeLabels || _diagram.selectAllEdges('.edge-label-wrapper'); textPaths = textPaths || _diagram.selectAllDefs('path.edge-label-path'); var nullSel = d3.select(null); // no enters draw(node, nullSel, edge, nullSel, edgeHover, nullSel, edgeLabels, nullSel, textPaths, nullSel, false); return this; }; _diagram.requestRefresh = function(durationOverride) { window.requestAnimationFrame(function() { var transdur; if(durationOverride !== undefined) { transdur = _diagram.transitionDuration(); _diagram.transitionDuration(durationOverride); } _diagram.refresh(); if(durationOverride !== undefined) _diagram.transitionDuration(transdur); }); }; _diagram.reposition = function(node, edge) { node .attr('transform', function (n) { return 'translate(' + n.cola.x + ',' + n.cola.y + ')'; }); // reset edge ports edge.each(function(e) { e.pos.new = null; e.pos.old = null; calc_edge_path(e, 'new', e.source.cola.x, e.source.cola.y, e.target.cola.x, e.target.cola.y); if(_diagram.edgeArrowhead.eval(e)) d3.select('#' + _diagram.arrowId(e, 'head')) .attr('orient', function() { return e.pos.new.orienthead; }); if(_diagram.edgeArrowtail.eval(e)) d3.select('#' + _diagram.arrowId(e, 'tail')) .attr('orient', function() { return e.pos.new.orienttail; }); }) .attr('d', render_edge_path('new')); return this; }; function layout_done(happens) { _dispatch.end(happens); _running = false; if(_needsRedraw) { _needsRedraw = false; window.setTimeout(function() { if(!_diagram.isRunning()) // someone else may already have started _diagram.redraw(); }, 0); } } function enforce_path_direction(path, spos, tpos) { var points = path.points, first = points[0], last = points[points.length-1]; switch(_diagram.enforceEdgeDirection()) { case 'LR': if(spos.x &gt;= tpos.x) { var dx = first.x - last.x; return { points: [ first, {x: first.x + dx, y: first.y - dx/2}, {x: last.x - dx, y: last.y - dx/2}, last ], bezDegree: 3, sourcePort: path.sourcePort, targetPort: path.targetPort }; } break; case 'TB': if(spos.y &gt;= tpos.y) { var dy = first.y - last.y; return { points: [ first, {x: first.x + dy/2, y: first.y + dy}, {x: last.x + dy/2, y: last.y - dy}, last ], bezDegree: 3, sourcePort: path.sourcePort, targetPort: path.targetPort }; } break; } return path; } function calc_edge_path(e, age, sx, sy, tx, ty) { var parallel = e.parallel; var source = e.source, target = e.target; if(parallel.edges.length &gt; 1 &amp;&amp; e.source.index &gt; e.target.index) { var t; t = target; target = source; source = t; t = tx; tx = sx; sx = t; t = ty; ty = sy; sy = t; } var source_padding = source.dcg_ry + _diagram.nodeStrokeWidth.eval(source) / 2, target_padding = target.dcg_ry + _diagram.nodeStrokeWidth.eval(target) / 2; for(var p = 0; p &lt; parallel.edges.length; ++p) { // alternate parallel edges over, then under var dir = (!!(p%2) === (sx &lt; tx)) ? -1 : 1, port = Math.floor((p+1)/2), last = port &gt; 0 ? parallel.edges[p &gt; 2 ? p - 2 : 0].pos[age].path : null; var path = draw_edge_to_shapes(_diagram, e, sx, sy, tx, ty, last, dir, _diagram.parallelEdgeOffset(), source_padding, target_padding ); if(parallel.edges.length &gt; 1 &amp;&amp; parallel.rev[p]) path.points.reverse(); if(_diagram.enforceEdgeDirection()) path = enforce_path_direction(path, source.cola, target.cola); parallel.edges[p].pos[age] = { path: path, orienthead: calculate_arrowhead_orientation(path.points, 'head'), orienttail: calculate_arrowhead_orientation(path.points, 'tail') }; } } function render_edge_path(age) { return function(e) { var path = e.pos[age].path; return generate_path(path.points, path.bezDegree); }; } function render_edge_label_path(age) { return function(e) { var path = e.pos[age].path; var points = path.points[path.points.length-1].x &lt; path.points[0].x ? path.points.slice(0).reverse() : path.points; return generate_path(points, path.bezDegree); }; } // wait on multiple transitions, adapted from // http://stackoverflow.com/questions/10692100/invoke-a-callback-at-the-end-of-a-transition function endall(transitions, callback) { if (transitions.every(function(transition) { return transition.size() === 0; })) callback(); var n = 0; transitions.forEach(function(transition) { transition .each(function() { ++n; }) .each('end.all', function() { if (!--n) callback(); }); }); } function node_bounds(n) { return {left: n.cola.x - n.dcg_rx, top: n.cola.y - n.dcg_ry, right: n.cola.x + n.dcg_rx, bottom: n.cola.y + n.dcg_ry}; } function union_bounds(b1, b2) { return { left: Math.min(b1.left, b2.left), top: Math.min(b1.top, b2.top), right: Math.max(b1.right, b2.right), bottom: Math.max(b1.bottom, b2.bottom) }; } function point_to_bounds(p) { return { left: p.x, top: p.y, right: p.x, bottom: p.y }; } function edge_bounds(e) { // assumption: edge must have some points var points = e.pos.new.path.points; return points.map(point_to_bounds).reduce(union_bounds); } function debug_bounds(bounds) { var brect = _g.selectAll('rect.bounds').data([0]); brect.enter() .insert('rect', ':first-child').attr({ class: 'bounds', fill: 'rgba(128,255,128,0.1)', stroke: '#000' }); brect .attr({ x: bounds.left, y: bounds.top, width: bounds.right - bounds.left, height: bounds.bottom - bounds.top }); } var _bounds; function calc_bounds(node, edge) { if((_diagram.fitStrategy() || _diagram.restrictPan()) &amp;&amp; node.size()) { // assumption: there can be no edges without nodes _bounds = node.data().map(node_bounds).reduce(union_bounds); _bounds = edge.data().map(edge_bounds).reduce(union_bounds, _bounds); } } function auto_zoom(animate) { if(_diagram.fitStrategy()) { if(!_bounds) return; var vwidth = _bounds.right - _bounds.left, vheight = _bounds.bottom - _bounds.top, swidth = _diagram.width() - _diagram.margins().left - _diagram.margins().right, sheight = _diagram.height() - _diagram.margins().top - _diagram.margins().bottom; if(_diagram.DEBUG_BOUNDS) debug_bounds(_bounds); var fitS = _diagram.fitStrategy(), translate = [0,0], scale = 1; if(['default', 'vertical', 'horizontal'].indexOf(fitS) &gt;= 0) { var sAR = sheight / swidth, vAR = vheight / vwidth, vrl = vAR&lt;sAR, // view aspect ratio is less (wider) amv = (fitS === 'default') ? !vrl : (fitS === 'vertical'); // align margins vertically scale = amv ? sheight / vheight : swidth / vwidth; scale = Math.max(_diagram.zoomExtent()[0], Math.min(_diagram.zoomExtent()[1], scale)); translate = [_diagram.margins().left - _bounds.left*scale + (swidth - vwidth*scale) / 2, _diagram.margins().top - _bounds.top*scale + (sheight - vheight*scale) / 2]; } else if(typeof fitS === 'string' &amp;&amp; fitS.match(/^align_/)) { var sides = fitS.split('_')[1].toLowerCase().split(''); if(sides.length &gt; 2) throw new Error(&quot;align_ expecting 0-2 sides, not &quot; + sides.length); var bounds = margined_bounds(); translate = _zoom.translate(); scale = _zoom.scale(); var vertalign = false, horzalign = false; sides.forEach(function(s) { switch(s) { case 'l': translate[0] = align_left(translate, bounds.left); horzalign = true; break; case 't': translate[1] = align_top(translate, bounds.top); vertalign = true; break; case 'r': translate[0] = align_right(translate, bounds.right); horzalign = true; break; case 'b': translate[1] = align_bottom(translate, bounds.bottom); vertalign = true; break; case 'c': // handled below break; default: throw new Error(&quot;align_ expecting l t r b or c, not '&quot; + s + &quot;'&quot;); } }); if(sides.includes('c')) { if(!horzalign) translate[0] = center_horizontally(translate, bounds); if(!vertalign) translate[1] = center_vertically(translate, bounds); } } else if(fitS === 'zoom') { scale = _zoom.scale(); translate = bring_in_bounds(_zoom.translate()); } else throw new Error('unknown fitStrategy type ' + typeof fitS); _animateZoom = animate; _zoom.translate(translate).scale(scale).event(_svg); _animateZoom = false; } } // determine pre-transition orientation that won't spin a lot going to new orientation function unsurprising_orient(oldorient, neworient) { var oldang = +oldorient.slice(0, -3), newang = +neworient.slice(0, -3); if(Math.abs(oldang - newang) &gt; Math.PI) { if(newang &gt; oldang) oldang += 2*Math.PI; else oldang -= 2*Math.PI; } return oldang + 'rad'; } function draw(node, nodeEnter, edge, edgeEnter, edgeHover, edgeHoverEnter, edgeLabels, edgeLabelsEnter, textPaths, textPathsEnter, animatePositions) { console.assert(edge.data().every(has_source_and_target)); var nodeEntered = {}; nodeEnter .each(function(n) { nodeEntered[_diagram.nodeKey.eval(n)] = true; }) .attr('transform', function (n) { // start new nodes at their final position return 'translate(' + n.cola.x + ',' + n.cola.y + ')'; }); var ntrans = node .transition() .duration(_diagram.stagedDuration()) .delay(function(n) { return _diagram.stagedDelay(nodeEntered[_diagram.nodeKey.eval(n)]); }) .attr('opacity', _diagram.nodeOpacity.eval); if(animatePositions) ntrans .attr('transform', function (n) { return 'translate(' + n.cola.x + ',' + n.cola.y + ')'; }) .each('end.record', function(n) { n.prevX = n.cola.x; n.prevY = n.cola.y; }); // recalculate edge positions edge.each(function(e) { e.pos.new = null; }); edge.each(function(e) { if(e.cola.points) { e.pos.new = { path: { points: e.cola.points, bezDegree: 3 }, orienthead: calculate_arrowhead_orientation(e.cola.points, 'head'), orienttail: calculate_arrowhead_orientation(e.cola.points, 'tail') }; } else { if(!e.pos.old) calc_edge_path(e, 'old', e.source.prevX || e.source.cola.x, e.source.prevY || e.source.cola.y, e.target.prevX || e.target.cola.x, e.target.prevY || e.target.cola.y); if(!e.pos.new) calc_edge_path(e, 'new', e.source.cola.x, e.source.cola.y, e.target.cola.x, e.target.cola.y); } if(e.pos.old) { if(e.pos.old.path.bezDegree !== e.pos.new.path.bezDegree || e.pos.old.path.points.length !== e.pos.new.path.points.length) { //console.log('old', e.pos.old.path.points.length, 'new', e.pos.new.path.points.length); if(is_one_segment(e.pos.old.path)) { e.pos.new.path.points = as_bezier3(e.pos.new.path); e.pos.old.path.points = split_bezier_n(as_bezier3(e.pos.old.path), (e.pos.new.path.points.length-1)/3); e.pos.old.path.bezDegree = e.pos.new.bezDegree = 3; } else if(is_one_segment(e.pos.new.path)) { e.pos.old.path.points = as_bezier3(e.pos.old.path); e.pos.new.path.points = split_bezier_n(as_bezier3(e.pos.new.path), (e.pos.old.path.points.length-1)/3); e.pos.old.path.bezDegree = e.pos.new.bezDegree = 3; } else console.warn(&quot;don't know how to interpolate two multi-segments&quot;); } } else e.pos.old = e.pos.new; }); var edgeEntered = {}; edgeEnter .each(function(e) { edgeEntered[_diagram.edgeKey.eval(e)] = true; }) .each(function(e) { // if staging transitions, just fade new edges in at new position // else start new edges at old positions of nodes, if any, else new positions var age = _diagram.stageTransitions() === 'modins' ? 'new' : 'old'; if(_diagram.edgeArrowhead.eval(e)) d3.select('#' + _diagram.arrowId(e, 'head')) .attr('orient', function() { return e.pos[age].orienthead; }); if(_diagram.edgeArrowtail.eval(e)) d3.select('#' + _diagram.arrowId(e, 'tail')) .attr('orient', function() { return e.pos[age].orienttail; }); }) .attr('d', render_edge_path(_diagram.stageTransitions() === 'modins' ? 'new' : 'old')); edge .each(function(e) { var totlength = this.getTotalLength(), arrowSize = diagram.edgeArrowSize.eval(e); var headlength = arrowSize*arrow_length(_arrows, arrow_parts(_arrows, _diagram.edgeArrowhead.eval(e))), taillength = arrowSize*arrow_length(_arrows, arrow_parts(_arrows, _diagram.edgeArrowtail.eval(e))); var tailStroke = _diagram.nodeStrokeWidth.eval(e.tail), headStroke = _diagram.nodeStrokeWidth.eval(e.head), length = Math.max(0, totlength-headlength-taillength - (tailStroke+headStroke)/2); d3.select(this) .attr('stroke-dasharray', length + ' ' + totlength*2) .attr('stroke-dashoffset', -(taillength + tailStroke/2)); }); var etrans = edge .each(function(e) { if(_diagram.edgeArrowhead.eval(e)) d3.select('#' + _diagram.arrowId(e, 'head')) .attr('orient', unsurprising_orient(e.pos.old.orienthead, e.pos.new.orienthead)) .transition().duration(_diagram.stagedDuration()) .delay(_diagram.stagedDelay(false)) .attr('orient', function() { return e.pos.new.orienthead; }); if(_diagram.edgeArrowtail.eval(e)) d3.select('#' + _diagram.arrowId(e, 'tail')) .attr('orient', unsurprising_orient(e.pos.old.orienttail, e.pos.new.orienttail)) .transition().duration(_diagram.stagedDuration()) .delay(_diagram.stagedDelay(false)) .attr('orient', function() { return e.pos.new.orienttail; }); }) .transition() .duration(_diagram.stagedDuration()) .delay(function(e) { return _diagram.stagedDelay(edgeEntered[_diagram.edgeKey.eval(e)]); }) .attr('opacity', _diagram.edgeOpacity.eval); if(animatePositions) etrans .attr('d', function(e) { var when = _diagram.stageTransitions() === 'insmod' &amp;&amp; edgeEntered[_diagram.edgeKey.eval(e)] ? 'old' : 'new'; return render_edge_path(when)(e); }); var elabels = edgeLabels .selectAll('text').data(function(e) { var labels = _diagram.edgeLabel.eval(e); if(!labels) return []; else if(typeof labels === 'string') return [labels]; else return labels; }); elabels.enter() .append('text') .attr({ 'class': 'edge-label', 'text-anchor': 'middle', dy: function(_, i) { return i * _diagram.edgeLabelSpacing.eval(this.parentNode) -2; } }) .append('textPath') .attr('startOffset', '50%') .attr('xlink:href', function(e) { var id = _diagram.textpathId(d3.select(this.parentNode.parentNode).datum()); // angular on firefox needs absolute paths for fragments return window.location.href.split('#')[0] + '#' + id; }); elabels .select('textPath') .text(function(t) { return t; }) .attr('opacity', function() { _diagram.edgeOpacity.eval(d3.select(this.parentNode.parentNode).datum()); }); textPathsEnter .attr('d', render_edge_label_path(_diagram.stageTransitions() === 'modins' ? 'new' : 'old')); var textTrans = textPaths.transition() .duration(_diagram.stagedDuration()) .delay(function(e) { return _diagram.stagedDelay(edgeEntered[_diagram.edgeKey.eval(e)]); }); if(animatePositions) textTrans .attr('d', function(e) { var when = _diagram.stageTransitions() === 'insmod' &amp;&amp; edgeEntered[_diagram.edgeKey.eval(e)] ? 'old' : 'new'; return render_edge_label_path(when)(e); }); if(_diagram.stageTransitions() === 'insmod' &amp;&amp; animatePositions) { // inserted edges transition twice in insmod mode if(_diagram.stagedDuration() &gt;= 50) { etrans = etrans.transition() .duration(_diagram.stagedDuration()) .attr('d', render_edge_path('new')); textTrans = textTrans.transition() .duration(_diagram.stagedDuration()) .attr('d', render_edge_label_path('new')); } else { // if transitions are too short, we run into various problems, // from transitions not completing to objects not found // so don't try to chain in that case // this also helped once: d3.timer.flush(); etrans .attr('d', render_edge_path('new')); textTrans .attr('d', render_edge_path('new')); } } // signal layout done when all transitions complete // because otherwise client might start another layout and lock the processor _animating = true; if(!_diagram.showLayoutSteps()) endall([ntrans, etrans, textTrans], function() { _animating = false; layout_done(true); }); if(animatePositions) edgeHover.attr('d', render_edge_path('new')); edge.each(function(e) { e.pos.old = e.pos.new; }); } _diagram.animating = function() { return _animating; }; _diagram.selectNodePortsOfStyle = function(node, style) { return node.selectAll('g.port').filter(function(p) { return _diagram.portStyleName.eval(p) === style; }); }; function draw_ports(node) { if(!_nodePorts) return; _diagram.portStyle.enum().forEach(function(style) { var nodePorts2 = {}; for(var nid in _nodePorts) nodePorts2[nid] = _nodePorts[nid].filter(function(p) { return _diagram.portStyleName.eval(p) === style; }); var port = _diagram.selectNodePortsOfStyle(node, style); _diagram.portStyle(style).drawPorts(port, nodePorts2, node); }); } /** * Standard dc.js * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin} * method. Erases any existing SVG elements and draws the diagram from scratch. `.render()` * must be called the first time, and `.redraw()` can be called after that. * @method render * @memberof dc_graph.diagram * @instance * @return {dc_graph.diagram} **/ _diagram.render = function () { if(_svg) _dispatch.reset(); if(!_diagram.initLayoutOnRedraw()) initLayout(); _diagram.resetSvg(); _g = _svg.append('g') .attr('class', 'draw'); var layers = ['edge-layer', 'node-layer']; if(_diagram.edgesInFront()) layers.reverse(); _g.selectAll('g').data(layers) .enter().append('g') .attr('class', function(l) { return l; }); _edgeLayer = _g.selectAll('g.edge-layer'); _nodeLayer = _g.selectAll('g.node-layer'); _dispatch.render(); _diagram.redraw(); return this; }; /** * Standard dc.js * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin} * method. Attaches an event handler to the diagram. The currently supported events are * * `start()` - layout is starting * * `drawn(nodes, edges)` - the node and edge elements have been rendered to the screen * and can be modified through the passed d3 selections. * * `end()` - diagram layout has completed. * @method on * @memberof dc_graph.diagram * @instance * @param {String} [event] - the event to subscribe to * @param {Function} [f] - the event handler * @return {dc_graph.diagram} **/ _diagram.on = function(event, f) { if(arguments.length === 1) return _dispatch.on(event); _dispatch.on(event, f); return this; }; /** * Returns an object with current statistics on graph layout. * * `nnodes` - number of nodes displayed * * `nedges` - number of edges displayed * @method getStats * @memberof dc_graph.diagram * @instance * @return {} * @return {dc_graph.diagram} **/ _diagram.getStats = function() { return _stats; }; /** * Standard dc.js * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin} * method. Execute a d3 single selection in the diagram's scope using the given selector * and return the d3 selection. Roughly the same as * ```js * d3.select('#diagram-id').select(selector) * ``` * Since this function returns a d3 selection, it is not chainable. (However, d3 selection * calls can be chained after it.) * @method select * @memberof dc_graph.diagram * @instance * @param {String} [selector] * @return {d3.selection} * @return {dc_graph.diagram} **/ _diagram.select = function (s) { return _diagram.root().select(s); }; /** * Standard dc.js * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin} * method. Selects all elements that match the d3 single selector in the diagram's scope, * and return the d3 selection. Roughly the same as * * ```js * d3.select('#diagram-id').selectAll(selector) * ``` * * Since this function returns a d3 selection, it is not chainable. (However, d3 selection * calls can be chained after it.) * @method selectAll * @memberof dc_graph.diagram * @instance * @param {String} [selector] * @return {d3.selection} * @return {dc_graph.diagram} **/ _diagram.selectAll = function (s) { return _diagram.root() ? _diagram.root().selectAll(s) : null; }; /** * Standard dc.js * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin} * method. Gets or sets the x scale. * @method x * @memberof dc_graph.diagram * @instance * @param {d3.scale} [scale] * @return {d3.scale} * @return {dc_graph.diagram} **/ _diagram.x = property(null); /** * Standard dc.js * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin} * method. Gets or sets the y scale. * @method x * @memberof dc_graph.diagram * @instance * @param {d3.scale} [scale] * @return {d3.scale} * @return {dc_graph.diagram} **/ _diagram.y = property(null); _diagram.zoom = function(_) { if(!arguments.length) return _zoom; _zoom = _; // is this a good idea? return _diagram; }; /** * Standard dc.js * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin} * method. Returns the top `svg` element for this specific diagram. You can also pass in a new * svg element, but setting the svg element on a diagram may have unexpected consequences. * @method svg * @memberof dc_graph.diagram * @instance * @param {d3.selection} [selection] * @return {d3.selection} * @return {dc_graph.diagram} **/ _diagram.svg = function (_) { if (!arguments.length) { return _svg; } _svg = _; return _diagram; }; /** * Returns the top `g` element for this specific diagram. This method is usually used to * retrieve the g element in order to overlay custom svg drawing * programatically. **Caution**: The root g element is usually generated internally, and * resetting it might produce unpredictable results. * @method g * @memberof dc_graph.diagram * @instance * @param {d3.selection} [selection] * @return {d3.selection} * @return {dc_graph.diagram} **/ _diagram.g = function (_) { if (!arguments.length) { return _g; } _g = _; return _diagram; }; _diagram.translate = function() { return _translate; }; _diagram.scale = function() { return _scale; }; /** * Standard dc.js * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin} * method. Remove the diagram's SVG elements from the dom and recreate the container SVG * element. * @method resetSvg * @memberof dc_graph.diagram * @instance * @return {dc_graph.diagram} **/ _diagram.resetSvg = function () { // we might be re-initialized in a div, in which case // we already have an &lt;svg&gt; element to delete var svg = _svg || _diagram.select('svg'); svg.remove(); _svg = null; return generateSvg(); }; /** * Standard dc.js * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin} * method. Causes all charts in the chart group to be redrawn. * @method redrawGroup * @memberof dc_graph.diagram * @instance * @return {dc_graph.diagram} **/ _diagram.redrawGroup = function () { dc.redrawAll(_chartGroup); }; /** * Standard dc.js * {@link https://github.com/dc-js/dc.js/blob/develop/web/docs/api-latest.md#dc.baseMixin baseMixin} * method. Causes all charts in the chart group to be rendered. * @method renderGroup * @memberof dc_graph.diagram * @instance * @return {dc_graph.diagram} **/ _diagram.renderGroup = function () { dc.renderAll(_chartGroup); }; /** * Creates an svg marker definition for drawing edge arrow tails or heads. The `viewBox` of * the marker is `0 -5 10 10`, so the arrow should be drawn from (0, -5) to (10, 5); it * will be moved and sized based on the other parameters, and rotated based on the * orientation of the edge. * * (If further customization is required, it is possible to append other `svg:defs` to * `diagram.svg()` and use refer to them by `id`.) * @method defineArrow * @memberof dc_graph.diagram * @instance * @param {Number} name - the identifier to give the marker, to be used with * {@link #dc_graph.diagram+edgeArrowhead edgeArrowhead} or * {@link #dc_graph.diagram+edgeArrowtail edgeArrowtail} * @param {Number} width - the width, in pixels, to draw the marker * @param {Number} height - the height, in pixels, to draw the marker * @param {Number} refX - the X reference position, in marker coordinates, which will be * aligned to the endpoint of the edge * @param {Number} refY - the Y reference position * @param {Function} drawf - a function to draw the marker using d3 SVG primitives, which * takes the marker object as its parameter. * @example * // the built-in `vee` arrow is defined like so: * _diagram.defineArrow('vee', 12, 12, 10, 0, function(marker) { * marker.append('svg:path') * .attr('d', 'M0,-5 L10,0 L0,5 L3,0') * .attr('stroke-width', '0px'); * }); * @return {dc_graph.diagram} **/ _diagram.defineArrow = function(defn, width, height, refX, refY, drawf) { if(typeof defn === 'string') defn = { name: defn, width: width, height: height, refX: refX, refY: refY, drawFunction: drawf }; _arrows[defn.name] = defn; return _diagram; }; // hmm _diagram.arrows = function() { return _arrows; }; _diagram.addOrRemoveDef = function(id, whether, tag, onEnter) { var data = whether ? [0] : []; var sel = _defs.selectAll('#' + id).data(data); var selEnter = sel .enter().append(tag) .attr('id', id); if(selEnter.size() &amp;&amp; onEnter) selEnter.call(onEnter); sel.exit().remove(); return sel; }; Object.keys(dc_graph.builtin_arrows).forEach(function(aname) { var defn = dc_graph.builtin_arrows[aname]; defn.name = aname; _diagram.defineArrow(defn); }); function globalTransform(pos, scale, animate) { _translate = pos; _scale = scale; var obj = _g; if(animate) obj = _g.transition().duration(_diagram.zoomDuration()); obj.attr('transform', 'translate(' + pos + ')' + ' scale(' + scale + ')'); } function margined_bounds() { var bounds = _bounds || {left: 0, top: 0, right: 0, bottom: 0}; var scale = _zoom ? _zoom.scale() : 1; return { left: bounds.left - _diagram.margins().left/scale, top: bounds.top - _diagram.margins().top/scale, right: bounds.right + _diagram.margins().right/scale, bottom: bounds.bottom + _diagram.margins().bottom/scale }; } // with thanks to comments in https://github.com/d3/d3/issues/1084 function align_left(translate, x) { return translate[0] - _diagram.x()(x) + _diagram.x().range()[0]; } function align_top(translate, y) { return translate[1] - _diagram.y()(y) + _diagram.y().range()[0]; } function align_right(translate, x) { return translate[0] - _diagram.x()(x) + _diagram.x().range()[1]; } function align_bottom(translate, y) { return translate[1] - _diagram.y()(y) + _diagram.y().range()[1];; } function center_horizontally(translate, bounds) { return (align_left(translate, bounds.left) + align_right(translate, bounds.right))/2; } function center_vertically(translate, bounds) { return (align_top(translate, bounds.top) + align_bottom(translate, bounds.bottom))/2; } function bring_in_bounds(translate) { var xDomain = _diagram.x().domain(), yDomain = _diagram.y().domain(); var bounds = margined_bounds(); var less1 = bounds.left &lt; xDomain[0], less2 = bounds.right &lt; xDomain[1], lessExt = (bounds.right - bounds.left) &lt; (xDomain[1] - xDomain[0]); var align, nothing = 0; if(less1 &amp;&amp; less2) if(lessExt) align = 'left'; else align = 'right'; else if(!less1 &amp;&amp; !less2) if(lessExt) align = 'right'; else align = 'left'; switch(align) { case 'left': translate[0] = align_left(translate, bounds.left); break; case 'right': translate[0] = align_right(translate, bounds.right); break; default: ++nothing; } less1 = bounds.top &lt; yDomain[0]; less2 = bounds.bottom &lt; yDomain[1]; lessExt = (bounds.bottom - bounds.top) &lt; (yDomain[1] - yDomain[0]); if(less1 &amp;&amp; less2) if(lessExt) align = 'top'; else align = 'bottom'; else if(!less1 &amp;&amp; !less2) if(lessExt) align = 'bottom'; else align = 'top'; switch(align) { case 'top': translate[1] = align_top(translate, bounds.top); break; case 'bottom': translate[1] = align_bottom(translate, bounds.bottom); break; default: ++nothing; } return translate; } function doZoom() { if(_width === 'auto' || _height === 'auto') detect_size_change(); var translate, scale = d3.event.scale; if(_diagram.restrictPan()) _zoom.translate(translate = bring_in_bounds(d3.event.translate)); else translate = d3.event.translate; globalTransform(translate, scale, _animateZoom); _dispatch.zoomed(translate, scale, _diagram.x().domain(), _diagram.y().domain()); } _diagram.resizeSvg = function(w, h) { if(_svg) { _svg.attr('width', w || (_width === 'auto' ? '100%' : _diagram.width())) .attr('height', h || (_height === 'auto' ? '100%' : _diagram.height())); } return _diagram; }; function enableZoom() { _svg.call(_zoom); _svg.on('dblclick.zoom', null); } function disableZoom() { _svg.on('.zoom', null); } function generateSvg() { _svg = _diagram.root().append('svg'); _diagram.resizeSvg(); _defs = _svg.append('svg:defs'); // start out with 1:1 zoom if(!_diagram.x()) _diagram.x(d3.scale.linear() .domain([0, _diagram.width()]) .range([0, _diagram.width()])); if(!_diagram.y()) _diagram.y(d3.scale.linear() .domain([0, _diagram.height()]) .range([0, _diagram.height()])); _zoom = d3.behavior.zoom() .on('zoom', doZoom) .x(_diagram.x()).y(_diagram.y()) .scaleExtent(_diagram.zoomExtent()); if(_diagram.mouseZoomable()) { var mod, mods; var brush = _diagram.child('brush'); if((mod = _diagram.modKeyZoom())) { if (Array.isArray (mod)) mods = mod.slice (); else if (typeof mod === &quot;string&quot;) mods = [mod]; else mods = ['Alt']; var mouseDown = false, modDown = false, zoomEnabled = false; _svg.on('mousedown.modkey-zoom', function() { mouseDown = true; }).on('mouseup.modkey-zoom', function() { mouseDown = false; if(!mouseDown &amp;&amp; !modDown &amp;&amp; zoomEnabled) { zoomEnabled = false; disableZoom(); if(brush) brush.activate(); } }); d3.select(document) .on('keydown.modkey-zoom', function() { if(mods.indexOf (d3.event.key) &gt; -1) { modDown = true; if(!mouseDown) { zoomEnabled = true; enableZoom(); if(brush) brush.deactivate(); } } }) .on('keyup.modkey-zoom', function() { if(mods.indexOf (d3.event.key) &gt; -1) { modDown = false; if(!mouseDown) { zoomEnabled = false; disableZoom(); if(brush) brush.activate(); } } }); } else enableZoom(); } return _svg; } _diagram.invertCoord = function(clientCoord) { return [ _diagram.x().invert(clientCoord[0]), _diagram.y().invert(clientCoord[1]) ]; }; /** * Set the root SVGElement to either be any valid [d3 single * selector](https://github.com/mbostock/d3/wiki/Selections#selecting-elements) specifying a dom * block element such as a div; or a dom element or d3 selection. This class is called * internally on diagram initialization, but be called again to relocate the diagram. However, it * will orphan any previously created SVGElements. * @method anchor * @memberof dc_graph.diagram * @instance * @param {anchorSelector|anchorNode|d3.selection} [parent] * @param {String} [chartGroup] * @return {String|node|d3.selection} * @return {dc_graph.diagram} */ _diagram.anchor = function(parent, chartGroup) { if (!arguments.length) { return _anchor; } if (parent) { if (parent.select &amp;&amp; parent.classed) { // detect d3 selection _anchor = parent.node(); } else { _anchor = parent; } _diagram.root(d3.select(_anchor)); _diagram.root().classed(dc_graph.constants.CHART_CLASS, true); dc.registerChart(_diagram, chartGroup); } else { throw new dc.errors.BadArgumentException('parent must be defined'); } _chartGroup = chartGroup; return _diagram; }; /** * Returns the internal numeric ID of the chart. * @method chartID * @memberof dc.baseMixin * @instance * @returns {String} */ _diagram.chartID = function () { return _diagram.__dcFlag__; }; /** * Returns the DOM id for the chart's anchored location. * @method anchorName * @memberof dc_graph.diagram * @instance * @return {String} */ _diagram.anchorName = function () { var a = _diagram.anchor(); if (a &amp;&amp; a.id) { return a.id; } if (a &amp;&amp; a.replace) { return a.replace('#', ''); } return 'dc-graph' + _diagram.chartID(); }; return _diagram.anchor(parent, chartGroup); }; × Search results Close "},"core.js.html":{"id":"core.js.html","title":"Source: core.js","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Source: core.js /** * The entire dc.graph.js library is scoped under the **dc_graph** name space. It does not introduce * anything else into the global name space. * * Like in dc.js and most libraries built on d3, most `dc_graph` functions are designed to allow function chaining, meaning they return the current diagram * instance whenever it is appropriate. The getter forms of functions do not participate in function * chaining because they return values that are not the diagram. * @namespace dc_graph * @version &lt;%= conf.pkg.version %&gt; * @example * // Example chaining * diagram.width(600) * .height(400) * .nodeDimension(nodeDim) * .nodeGroup(nodeGroup); */ var dc_graph = { version: '&lt;%= conf.pkg.version %&gt;', constants: { CHART_CLASS: 'dc-graph' } }; function get_original(x) { return x.orig; } function identity(x) { return x; }; var property = function (defaultValue, unwrap) { if(unwrap === undefined) unwrap = get_original; else if(unwrap === false) unwrap = identity; var value = defaultValue, react = null; var cascade = []; var ret = function (_) { if (!arguments.length) { return value; } if(react) react(_); value = _; return this; }; ret.cascade = function (n, f) { for(var i = 0; i&lt;cascade.length; ++i) { if(cascade[i].n === n) { if(f) cascade[i].f = f; else cascade.splice(i, 1); return ret; } else if(cascade[i].n &gt; n) { cascade.splice(i, 0, {n: n, f: f}); return ret; } } cascade.push({n: n, f: f}); return ret; }; ret._eval = function(o, n) { if(n===0 || !cascade.length) return dc_graph.functor_wrap(ret(), unwrap)(o); else { var last = cascade[n-1]; return last.f(o, function() { return ret._eval(o, n-1); }); } }; ret.eval = function(o) { return ret._eval(o, cascade.length); }; ret.react = function(_) { if (!arguments.length) { return react; } react = _; return this; }; return ret; }; function named_children() { var _children = {}; var f = function(id, object) { if(arguments.length === 1) return _children[id]; // do not notify unnecessarily if(_children[id] === object) return this; if(_children[id]) _children[id].parent(null); _children[id] = object; if(object) object.parent(this); return this; }; f.enum = function() { return Object.keys(_children); }; f.nameOf = function(o) { var found = Object.entries(_children).find(function(kv) { return kv[1] == o; }); return found ? found[0] : null; }; return f; } function deprecated_property(message, defaultValue) { var prop = property(defaultValue); var ret = function() { if(arguments.length) { console.warn(message); prop.apply(property, arguments); return this; } return prop(); }; ['cascade', '_eval', 'eval', 'react'].forEach(function(method) { ret[method] = prop[method]; }); return ret; } function deprecation_warning(message) { var said = false; return function() { if(said) return; console.warn(message); }; } // http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript function uuid() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { var r = Math.random()*16|0, v = c == 'x' ? r : (r&amp;0x3|0x8); return v.toString(16); }); } // polyfill Object.assign for IE // it's just too useful to do without if (typeof Object.assign != 'function') { // Must be writable: true, enumerable: false, configurable: true Object.defineProperty(Object, &quot;assign&quot;, { value: function assign(target, varArgs) { // .length of function is 2 'use strict'; if (target == null) { // TypeError if undefined or null throw new TypeError('Cannot convert undefined or null to object'); } var to = Object(target); for (var index = 1; index &lt; arguments.length; index++) { var nextSource = arguments[index]; if (nextSource != null) { // Skip over if undefined or null for (var nextKey in nextSource) { // Avoid bugs when hasOwnProperty is shadowed if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) { to[nextKey] = nextSource[nextKey]; } } } } return to; }, writable: true, configurable: true }); } function getBBoxNoThrow(elem) { // firefox seems to have issues with some of my texts // just catch for now try { return elem.getBBox(); } catch(xep) { return {x: 0, y: 0, width:0, height: 0}; } } × Search results Close "},"behavior.js.html":{"id":"behavior.js.html","title":"Source: behavior.js","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Source: behavior.js dc_graph.behavior = function(event_namespace, options) { var _behavior = {}; var _eventName = options.laterDraw ? 'transitionsStarted' : 'drawn'; /** #### .parent([object]) Assigns this behavior to a diagram. **/ _behavior.parent = property(null) .react(function(p) { var diagram; if(p) { var first = true; diagram = p; p.on(_eventName + '.' + event_namespace, function(node, edge, ehover) { options.add_behavior(diagram, node, edge, ehover); if(first &amp;&amp; options.first) { options.first(diagram, node, edge, ehover); first = false; } else if(options.rest) options.rest(diagram, node, edge, ehover); }); p.on('reset.' + event_namespace, function() { options.remove_behavior(diagram, diagram.selectAllNodes(), diagram.selectAllEdges(), diagram.selectAllEdges('.edge-hover')); }); } else if(_behavior.parent()) { diagram = _behavior.parent(); diagram.on(_eventName + '.' + event_namespace, function(node, edge, ehover) { options.remove_behavior(diagram, node, edge, ehover); diagram.on(_eventName + '.' + event_namespace, null); }); } options.parent &amp;&amp; options.parent(p); }); return _behavior; }; × Search results Close "},"cola_layout.js.html":{"id":"cola_layout.js.html","title":"Source: cola_layout.js","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Source: cola_layout.js /** * `dc_graph.cola_layout` is an adaptor for cola.js layouts in dc.graph.js * @class cola_layout * @memberof dc_graph * @param {String} [id=uuid()] - Unique identifier * @return {dc_graph.cola_layout} **/ dc_graph.cola_layout = function(id) { var _layoutId = id || uuid(); var _d3cola = null; var _dispatch = d3.dispatch('tick', 'start', 'end'); var _flowLayout; // node and edge objects shared with cola.js, preserved from one iteration // to the next (as long as the object is still in the layout) var _nodes = {}, _edges = {}; function init(options) { // width, height, handleDisconnected, lengthStrategy, baseLength, flowLayout, tickSize _d3cola = cola.d3adaptor() .avoidOverlaps(true) .size([options.width, options.height]) .handleDisconnected(options.handleDisconnected); if(_d3cola.tickSize) // non-standard _d3cola.tickSize(options.tickSize); switch(options.lengthStrategy) { case 'symmetric': _d3cola.symmetricDiffLinkLengths(options.baseLength); break; case 'jaccard': _d3cola.jaccardLinkLengths(options.baseLength); break; case 'individual': _d3cola.linkDistance(function(e) { return e.dcg_edgeLength || options.baseLength; }); break; case 'none': default: } if(options.flowLayout) { _d3cola.flowLayout(options.flowLayout.axis, options.flowLayout.minSeparation); } } function data(nodes, edges, constraints) { var wnodes = regenerate_objects(_nodes, nodes, null, function(v) { return v.dcg_nodeKey; }, function(v1, v) { v1.dcg_nodeKey = v.dcg_nodeKey; v1.width = v.width; v1.height = v.height; v1.fixed = !!v.dcg_nodeFixed; if(v1.fixed &amp;&amp; typeof v.dcg_nodeFixed === 'object') { v1.x = v.dcg_nodeFixed.x; v1.y = v.dcg_nodeFixed.y; } else { // should we support e.g. null to unset x,y? if(v.x !== undefined) v1.x = v.x; if(v.y !== undefined) v1.y = v.y; } }); var wedges = regenerate_objects(_edges, edges, null, function(e) { return e.dcg_edgeKey; }, function(e1, e) { e1.dcg_edgeKey = e.dcg_edgeKey; // cola edges can work with indices or with object references // but it will replace indices with object references e1.source = _nodes[e.dcg_edgeSource]; e1.target = _nodes[e.dcg_edgeTarget]; e1.dcg_edgeLength = e.dcg_edgeLength; }); // cola needs each node object to have an index property wnodes.forEach(function(v, i) { v.index = i; }); var groups = null; if(engine.groupConnected()) { var components = cola.separateGraphs(wnodes, wedges); groups = components.map(function(g) { return {leaves: g.array.map(function(n) { return n.index; })}; }); } function dispatchState(event) { _dispatch[event]( wnodes, wedges.map(function(e) { return {dcg_edgeKey: e.dcg_edgeKey}; }) ); } _d3cola.on('tick', /* _tick = */ function() { dispatchState('tick'); }).on('start', function() { _dispatch.start(); }).on('end', /* _done = */ function() { dispatchState('end'); }); _d3cola.nodes(wnodes) .links(wedges) .constraints(constraints) .groups(groups); } function start() { _d3cola.start(engine.unconstrainedIterations(), engine.userConstraintIterations(), engine.allConstraintsIterations(), engine.gridSnapIterations()); } function stop() { if(_d3cola) _d3cola.stop(); } var graphviz = dc_graph.graphviz_attrs(), graphviz_keys = Object.keys(graphviz); graphviz.rankdir(null); var engine = Object.assign(graphviz, { layoutAlgorithm: function() { return 'cola'; }, layoutId: function() { return _layoutId; }, supportsWebworker: function() { return true; }, needsStage: function(stage) { // stopgap until we have engine chaining return stage === 'ports' || stage === 'edgepos'; }, parent: property(null), on: function(event, f) { if(arguments.length === 1) return _dispatch.on(event); _dispatch.on(event, f); return this; }, init: function(options) { this.optionNames().forEach(function(option) { options[option] = options[option] || this[option](); }.bind(this)); init(options); return this; }, data: function(graph, nodes, edges, constraints) { data(nodes, edges, constraints); }, start: function() { start(); }, stop: function() { stop(); }, optionNames: function() { return ['handleDisconnected', 'lengthStrategy', 'baseLength', 'flowLayout', 'tickSize', 'groupConnected'] .concat(graphviz_keys); }, populateLayoutNode: function() {}, populateLayoutEdge: function() {}, /** * Instructs cola.js to fit the connected components. * @method handleDisconnected * @memberof dc_graph.cola_layout * @instance * @param {Boolean} [handleDisconnected=true] * @return {Boolean} * @return {dc_graph.cola_layout} **/ handleDisconnected: property(true), /** * Currently, three strategies are supported for specifying the lengths of edges: * * 'individual' - uses the `edgeLength` for each edge. If it returns falsy, uses the * `baseLength` * * 'symmetric', 'jaccard' - compute the edge length based on the graph structure around * the edge. See * {@link https://github.com/tgdwyer/WebCola/wiki/link-lengths the cola.js wiki} * for more details. * 'none' - no edge lengths will be specified * @method lengthStrategy * @memberof dc_graph.cola_layout * @instance * @param {Function|String} [lengthStrategy='symmetric'] * @return {Function|String} * @return {dc_graph.cola_layout} **/ lengthStrategy: property('symmetric'), /** * Gets or sets the default edge length (in pixels) when the `.lengthStrategy` is * 'individual', and the base value to be multiplied for 'symmetric' and 'jaccard' edge * lengths. * @method baseLength * @memberof dc_graph.cola_layout * @instance * @param {Number} [baseLength=30] * @return {Number} * @return {dc_graph.cola_layout} **/ baseLength: property(30), /** * If `flowLayout` is set, it determines the axis and separation for * {@link http://marvl.infotech.monash.edu/webcola/doc/classes/cola.layout.html#flowlayout cola flow layout}. * If it is not set, `flowLayout` will be calculated from the {@link dc_graph.graphviz_attrs#rankdir rankdir} * and {@link dc_graph.graphviz_attrs#ranksep ranksep}; if `rankdir` is also null (the * default for cola layout), then there will be no flow. * @method flowLayout * @memberof dc_graph.cola_layout * @instance * @param {Object} [flowLayout=null] * @example * // No flow (default) * diagram.flowLayout(null) * // flow in x with min separation 200 * diagram.flowLayout({axis: 'x', minSeparation: 200}) **/ flowLayout: function(flow) { if(!arguments.length) { if(_flowLayout) return _flowLayout; var dir = engine.rankdir(); switch(dir) { case 'LR': return {axis: 'x', minSeparation: engine.ranksep() + engine.parent().nodeRadius()*2}; case 'TB': return {axis: 'y', minSeparation: engine.ranksep() + engine.parent().nodeRadius()*2}; default: return null; // RL, BT do not appear to be possible (negative separation) (?) } } _flowLayout = flow; return this; }, unconstrainedIterations: property(10), userConstraintIterations: property(20), allConstraintsIterations: property(20), gridSnapIterations: property(0), tickSize: property(1), groupConnected: property(false) }); return engine; }; dc_graph.cola_layout.scripts = ['d3.js', 'cola.js']; × Search results Close "},"constraint_pattern.js.html":{"id":"constraint_pattern.js.html","title":"Source: constraint_pattern.js","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Source: constraint_pattern.js /** * In cola.js there are three factors which influence the positions of nodes: * * *edge length* suggestions, controlled by the * {@link #dc_graph.diagram+lengthStrategy lengthStrategy}, * {@link #dc_graph.diagram+baseLength baseLength}, and * {@link #dc_graph.diagram+edgeLength edgeLength} parameters in dc.graph.js * * *automatic constraints* based on the global edge flow direction (`cola.flowLayout`) and overlap * avoidance parameters (`cola.avoidOverlaps`) * * *manual constraints* such as alignment, inequality and equality constraints in a dimension/axis. * * Generally when the * {@link https://github.com/tgdwyer/WebCola/wiki/Constraints cola.js documentation mentions constraints}, * it means the manual constraints. * * dc.graph.js allows generation of manual constraints using * {@link #dc_graph.diagram+constrain diagram.constrain} but it can be tedious to write these * functions because it usually means looping over the nodes and edges multiple times to * determine what classes or types of nodes to apply constraints to, and which edges should * take additional constraints. * * This utility creates a constraint generator function from a *pattern*, a graph where: * 1. Nodes represent *types* or classes of layout nodes, annotated with a specification * of how to match the nodes belonging each type. * 2. Edges represent *rules* to generate constraints. There are two kinds of rules: * &lt;ol type='a'&gt; * &lt;li&gt;To generate additional constraints on edges besides the built-in ones, create a rules * between two different types. The rule will apply to any edges in the layout which match the * source and target types, and generate simple &quot;left/right&quot; constraints. (Note that &quot;left&quot; and * &quot;right&quot; in this context refer to sides of an inequality constraint `left + gap &lt;= right`) * &lt;li&gt;To generate constraints on a set of nodes, such as alignment, ordering, or circle * constraints, create a rule from a type to itself, a self edge. * &lt;/ol&gt; * (It is also conceivable to want constraints between individual nodes which don't * have edges between them. This is not directly supported at this time; right now the workaround * is to create the edge but not draw it, e.g. by setting its {@link #dc_graph.diagram+edgeOpacity} * to zero. If you have a use-case for this, please * {@link https://github.com/dc-js/dc.graph.js/issues/new file an issue}. * * The pattern syntax is an embedded domain specific language designed to be terse without * restricting its power. As such, there are complicated rules for defaulting and inferring * parameters from other parameters. Since most users will want the simplest form, this document * will start from the highest level and then show how to use more complicated forms in order to * gain more control. * * Then we'll build back up from the ground up and show how inference works. * @class constraint_pattern * @memberof dc_graph * @param {dc_graph.diagram} diagram - the diagram to pull attributes from, mostly to determine * the keys of nodes and edge sources and targets * @param {Object} pattern - a graph which defines the constraints to be generated * @return {Function} */ dc_graph.constraint_pattern = function(pattern) { var types = {}, rules = []; pattern.nodes.forEach(function(n) { var id = n.id; var type = types[id] || (types[id] = {}); // partitions could be done more efficiently; this is POC if(n.partition) { var partition = n.partition; var value = n.value || n.id; if(n.all || n.typename) { type.match = n.extract ? function(n2) { return n.extract(n2.value[partition]); } : function(n2) { return n2.value[partition]; }; type.typename = n.typename || function(n2) { return partition + '=' + n2.value[partition]; }; } else type.match = function(n2) { return n2.value[partition] === value; }; } else if(n.match) type.match = n.match; else throw new Error(&quot;couldn't determine matcher for type &quot; + JSON.stringify(n)); }); pattern.edges.forEach(function(e) { if(e.disable) return; var rule = {source: e.source, target: e.target}; rule.produce = typeof e.produce === 'function' ? e.produce : function() { return clone(e.produce); }; ['listname', 'wrap', 'reverse'].forEach(function(k) { if(e[k] !== undefined) rule[k] = e[k]; }); rules.push(rule); }); return function(diagram, nodes, edges) { var constraints = []; var members = {}; nodes.forEach(function(n) { var key = diagram.nodeKey.eval(n); for(var t in types) { var type = types[t], value = type.match(n.orig); if(value) { var tname = type.typename ? type.typename(t, value) : t; if(!members[tname]) members[tname] = { nodes: [], // original ordering whether: {} // boolean }; members[tname].nodes.push(key); members[tname].whether[key] = true; } } }); // traversal of rules could be more efficient, again POC var edge_rules = rules.filter(function(r) { return r.source !== r.target; }); var type_rules = rules.filter(function(r) { return r.source === r.target; }); edges.forEach(function(e) { var source = diagram.edgeSource.eval(e), target = diagram.edgeTarget.eval(e); edge_rules.forEach(function(r) { if(members[r.source] &amp;&amp; members[r.source].whether[source] &amp;&amp; members[r.target] &amp;&amp; members[r.target].whether[target]) { var constraint = r.produce(members, nodes, edges); if(r.reverse) { constraint.left = target; constraint.right = source; } else { constraint.left = source; constraint.right = target; } constraints.push(constraint); } }); }); type_rules.forEach(function(r) { if(!members[r.source]) return; var constraint = r.produce(), listname = r.listname || r.produce.listname || 'nodes', wrap = r.wrap || r.produce.wrap || function(x) { return x; }; constraint[listname] = members[r.source].nodes.map(wrap); constraints.push(constraint); }); return constraints; }; }; // constraint generation convenience functions dc_graph.gap_y = function(gap, equality) { return { axis: 'y', gap: gap, equality: !!equality }; }; dc_graph.gap_x = function(gap, equality) { return { axis: 'x', gap: gap, equality: !!equality }; }; function align_f(axis) { var ret = function() { return { type: 'alignment', axis: axis }; }; ret.listname = 'offsets'; ret.wrap = function(x) { return {node: x, offset: 0}; }; return ret; } dc_graph.align_y = function() { return align_f('y'); }; dc_graph.align_x = function() { return align_f('x'); }; dc_graph.order_x = function(gap, ordering) { return { type: 'ordering', axis: 'x', gap: 60, ordering: ordering }; }; dc_graph.order_y = function(gap, ordering) { return { type: 'ordering', axis: 'y', gap: 60, ordering: ordering }; }; × Search results Close "},"d3_force_layout.js.html":{"id":"d3_force_layout.js.html","title":"Source: d3_force_layout.js","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Source: d3_force_layout.js /** * `dc_graph.d3_force_layout` is an adaptor for d3-force layouts in dc.graph.js * @class d3_force_layout * @memberof dc_graph * @param {String} [id=uuid()] - Unique identifier * @return {dc_graph.d3_force_layout} **/ dc_graph.d3_force_layout = function(id) { var _layoutId = id || uuid(); var _simulation = null; // d3-force simulation var _dispatch = d3.dispatch('tick', 'start', 'end'); // node and edge objects shared with d3-force, preserved from one iteration // to the next (as long as the object is still in the layout) var _nodes = {}, _edges = {}; var _wnodes = [], _wedges = []; var _options = null; var _paths = null; function init(options) { _options = options; _simulation = d3.layout.force() .size([options.width, options.height]); _simulation.on('tick', /* _tick = */ function() { dispatchState('tick'); }).on('start', function() { _dispatch.start(); }).on('end', /* _done = */ function() { dispatchState('end'); }); } function dispatchState(event) { _dispatch[event]( _wnodes, _wedges.map(function(e) { return {dcg_edgeKey: e.dcg_edgeKey}; }) ); } function data(nodes, edges, constraints) { var nodeIDs = {}; nodes.forEach(function(d, i) { nodeIDs[d.dcg_nodeKey] = i; }); _wnodes = regenerate_objects(_nodes, nodes, null, function(v) { return v.dcg_nodeKey; }, function(v1, v) { v1.dcg_nodeKey = v.dcg_nodeKey; v1.width = v.width; v1.height = v.height; v1.id = v.dcg_nodeKey; if(v.dcg_nodeFixed) { v1.fixed = true; v1.x = v.dcg_nodeFixed.x; v1.y = v.dcg_nodeFixed.y; } else v1.fixed = false; }); _wedges = regenerate_objects(_edges, edges, null, function(e) { return e.dcg_edgeKey; }, function(e1, e) { e1.dcg_edgeKey = e.dcg_edgeKey; // cola edges can work with indices or with object references // but it will replace indices with object references e1.source = _nodes[e.dcg_edgeSource]; e1.source.id = nodeIDs[e1.source.dcg_nodeKey]; e1.target = _nodes[e.dcg_edgeTarget]; e1.target.id = nodeIDs[e1.target.dcg_nodeKey]; e1.dcg_edgeLength = e.dcg_edgeLength; }); _simulation.nodes(_wnodes); _simulation.links(_wedges); } function start() { installForces(); runSimulation(_options.iterations); } function stop() { if(_simulation) _simulation.stop(); } function savePositions() { var data = {}; Object.keys(_nodes).forEach(function(key) { data[key] = {x: _nodes[key].x, y: _nodes[key].y}; }); return data; } function restorePositions(data) { Object.keys(data).forEach(function(key) { if(_nodes[key]) { _nodes[key].fixed = false; _nodes[key].x = data[key].x; _nodes[key].y = data[key].y; } }); } function installForces() { if(_paths === null) _simulation.gravity(_options.gravityStrength) .charge(_options.initialCharge); else { if(_options.fixOffPathNodes) { var nodesOnPath = d3.set(); // nodes on path _paths.forEach(function(path) { path.forEach(function(nid) { nodesOnPath.add(nid); }); }); // fix nodes not on paths Object.keys(_nodes).forEach(function(key) { if(!nodesOnPath.has(key)) { _nodes[key].fixed = true; } else { _nodes[key].fixed = false; } }); } // enlarge charge force to separate nodes on paths _simulation.charge(_options.chargeForce); } }; function runSimulation(iterations) { if(!iterations) { dispatchState('end'); return; } _simulation.start(); for (var i = 0; i &lt; 300; ++i) { _simulation.tick(); if(_paths) applyPathAngleForces(); } _simulation.stop(); } function applyPathAngleForces() { function _dot(v1, v2) { return v1.x*v2.x + v1.y*v2.y; }; function _len(v) { return Math.sqrt(v.x*v.x + v.y*v.y); }; function _angle(v1, v2) { var a = _dot(v1, v2) / (_len(v1)*_len(v2)); a = Math.min(a, 1); a = Math.max(a, -1); return Math.acos(a); }; // perpendicular unit length vector function _pVec(v) { var xx = -v.y/v.x, yy = 1; var length = _len({x: xx, y: yy}); return {x: xx/length, y: yy/length}; }; function updateNode(node, angle, pVec, alpha) { node.x += pVec.x*(Math.PI-angle)*alpha; node.y += pVec.y*(Math.PI-angle)*alpha; } _paths.forEach(function(path) { if(path.length &lt; 3) return; // at least 3 nodes (and 2 edges): A-&gt;B-&gt;C for(var i = 1; i &lt; path.length-1; ++i) { var current = _nodes[path[i]]; var prev = _nodes[path[i-1]]; var next = _nodes[path[i+1]]; // calculate the angle var vPrev = {x: prev.x - current.x, y: prev.y - current.y}; var vNext = {x: next.x - current.x, y: next.y - current.y}; var angle = _angle(vPrev, vNext); // angle in [0, PI] var pvecPrev = _pVec(vPrev); var pvecNext = _pVec(vNext); // make sure the perpendicular vector is in the // direction that makes the angle more towards 180 degree // 1. calculate the middle point of node 'prev' and 'next' var mid = {x: (prev.x+next.x)/2.0, y: (prev.y+next.y)/2.0}; // 2. calculate the vectors: 'prev' pointing to 'mid', 'next' pointing to 'mid' var prev_mid = {x: mid.x-prev.x, y: mid.y-prev.y}; var next_mid = {x: mid.x-next.x, y: mid.y-next.y}; // 3. the 'correct' vector: the angle between pvec and prev_mid(next_mid) should // be an obtuse angle pvecPrev = _angle(prev_mid, pvecPrev) &gt;= Math.PI/2.0 ? pvecPrev : {x: -pvecPrev.x, y: -pvecPrev.y}; pvecNext = _angle(next_mid, pvecNext) &gt;= Math.PI/2.0 ? pvecNext : {x: -pvecNext.x, y: -pvecNext.y}; // modify positions of prev and next updateNode(prev, angle, pvecPrev, _options.angleForce); updateNode(next, angle, pvecNext, _options.angleForce); } }); } var graphviz = dc_graph.graphviz_attrs(), graphviz_keys = Object.keys(graphviz); var engine = Object.assign(graphviz, { layoutAlgorithm: function() { return 'd3-force'; }, layoutId: function() { return _layoutId; }, supportsWebworker: function() { return true; }, parent: property(null), on: function(event, f) { if(arguments.length === 1) return _dispatch.on(event); _dispatch.on(event, f); return this; }, init: function(options) { this.optionNames().forEach(function(option) { options[option] = options[option] || this[option](); }.bind(this)); init(options); return this; }, data: function(graph, nodes, edges, constraints) { data(nodes, edges, constraints); }, start: function() { start(); }, stop: function() { stop(); }, paths: function(paths) { _paths = paths; }, savePositions: savePositions, restorePositions: restorePositions, optionNames: function() { return ['iterations', 'angleForce', 'chargeForce', 'gravityStrength', 'initialCharge', 'fixOffPathNodes'] .concat(graphviz_keys); }, iterations: property(300), angleForce: property(0.02), chargeForce: property(-500), gravityStrength: property(1.0), initialCharge: property(-400), fixOffPathNodes: property(false), populateLayoutNode: function() {}, populateLayoutEdge: function() {} }); return engine; }; dc_graph.d3_force_layout.scripts = ['d3.js']; × Search results Close "},"d3v4_force_layout.js.html":{"id":"d3v4_force_layout.js.html","title":"Source: d3v4_force_layout.js","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Source: d3v4_force_layout.js /** * `dc_graph.d3v4_force_layout` is an adaptor for d3-force version 4 layouts in dc.graph.js * @class d3v4_force_layout * @memberof dc_graph * @param {String} [id=uuid()] - Unique identifier * @return {dc_graph.d3v4_force_layout} **/ dc_graph.d3v4_force_layout = function(id) { var _layoutId = id || uuid(); var _simulation = null; // d3-force simulation var _dispatch = d3.dispatch('tick', 'start', 'end'); // node and edge objects shared with d3-force, preserved from one iteration // to the next (as long as the object is still in the layout) var _nodes = {}, _edges = {}; var _wnodes = [], _wedges = []; var _options = null; var _paths = null; function init(options) { _options = options; _simulation = d3v4.forceSimulation() .force('link', d3v4.forceLink()) .force('center', d3v4.forceCenter(options.width / 2, options.height / 2)) .force('gravityX', d3v4.forceX(options.width / 2).strength(_options.gravityStrength)) .force('gravityY', d3v4.forceY(options.height / 2).strength(_options.gravityStrength)) .force('collision', d3v4.forceCollide(_options.collisionRadius)) .force('charge', d3v4.forceManyBody()) .stop(); } function dispatchState(event) { _dispatch[event]( _wnodes, _wedges.map(function(e) { return {dcg_edgeKey: e.dcg_edgeKey}; }) ); } function data(nodes, edges, constraints) { var nodeIDs = {}; nodes.forEach(function(d, i) { nodeIDs[d.dcg_nodeKey] = i; }); _wnodes = regenerate_objects(_nodes, nodes, null, function(v) { return v.dcg_nodeKey; }, function(v1, v) { v1.dcg_nodeKey = v.dcg_nodeKey; v1.width = v.width; v1.height = v.height; v1.id = v.dcg_nodeKey; if(v.dcg_nodeFixed) { v1.fx = v.dcg_nodeFixed.x; v1.fy = v.dcg_nodeFixed.y; } else v1.fx = v1.fy = null; }); _wedges = regenerate_objects(_edges, edges, null, function(e) { return e.dcg_edgeKey; }, function(e1, e) { e1.dcg_edgeKey = e.dcg_edgeKey; e1.source = nodeIDs[_nodes[e.dcg_edgeSource].dcg_nodeKey]; e1.target = nodeIDs[_nodes[e.dcg_edgeTarget].dcg_nodeKey]; e1.dcg_edgeLength = e.dcg_edgeLength; }); _simulation.force('straighten', null); _simulation.nodes(_wnodes); _simulation.force('link').links(_wedges); } function start() { _dispatch.start(); installForces(_paths); runSimulation(_options.iterations); } function stop() { // not running asynchronously, no _simulation.stop(); } function savePositions() { var data = {}; Object.keys(_nodes).forEach(function(key) { data[key] = {x: _nodes[key].x, y: _nodes[key].y}; }); return data; } function restorePositions(data) { Object.keys(data).forEach(function(key) { if(_nodes[key]) { _nodes[key].fx = data[key].x; _nodes[key].fy = data[key].y; } }); } function installForces(paths) { if(paths) paths = paths.filter(function(path) { return path.nodes.every(function(nk) { return _nodes[nk]; }); }); if(paths === null || !paths.length) { _simulation.force('charge').strength(_options.initialCharge); } else { var nodesOnPath; if(_options.fixOffPathNodes) { nodesOnPath = d3.set(); paths.forEach(function(path) { path.nodes.forEach(function(nid) { nodesOnPath.add(nid); }); }); } // fix nodes not on paths Object.keys(_nodes).forEach(function(key) { if(_options.fixOffPathNodes &amp;&amp; !nodesOnPath.has(key)) { _nodes[key].fx = _nodes[key].x; _nodes[key].fy = _nodes[key].y; } else { _nodes[key].fx = null; _nodes[key].fy = null; } }); _simulation.force('charge').strength(_options.chargeForce); _simulation.force('straighten', d3v4.forceStraightenPaths() .id(function(n) { return n.dcg_nodeKey; }) .angleForce(_options.angleForce) .pathNodes(function(p) { return p.nodes; }) .pathStrength(function(p) { return p.strength; }) .paths(paths)); } }; function runSimulation(iterations) { _simulation.alpha(1); for (var i = 0; i &lt; iterations; ++i) { _simulation.tick(); dispatchState('tick'); } dispatchState('end'); } var graphviz = dc_graph.graphviz_attrs(), graphviz_keys = Object.keys(graphviz); var engine = Object.assign(graphviz, { layoutAlgorithm: function() { return 'd3v4-force'; }, layoutId: function() { return _layoutId; }, supportsWebworker: function() { return true; }, parent: property(null), on: function(event, f) { if(arguments.length === 1) return _dispatch.on(event); _dispatch.on(event, f); return this; }, init: function(options) { this.optionNames().forEach(function(option) { options[option] = options[option] || this[option](); }.bind(this)); init(options); return this; }, data: function(graph, nodes, edges, constraints) { data(nodes, edges, constraints); }, start: function() { start(); }, stop: function() { stop(); }, paths: function(paths) { _paths = paths; }, savePositions: savePositions, restorePositions: restorePositions, optionNames: function() { return ['iterations', 'angleForce', 'chargeForce', 'gravityStrength', 'collisionRadius', 'initialCharge', 'fixOffPathNodes'] .concat(graphviz_keys); }, iterations: property(300), angleForce: property(0.01), chargeForce: property(-600), gravityStrength: property(0.3), collisionRadius: property(8), initialCharge: property(-100), fixOffPathNodes: property(false), populateLayoutNode: function() {}, populateLayoutEdge: function() {} }); engine.pathStraightenForce = engine.angleForce; return engine; }; dc_graph.d3v4_force_layout.scripts = ['d3.js', 'd3v4-force.js']; × Search results Close "},"dagre_layout.js.html":{"id":"dagre_layout.js.html","title":"Source: dagre_layout.js","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Source: dagre_layout.js /** * `dc_graph.dagre_layout` is an adaptor for dagre.js layouts in dc.graph.js * * In addition to the below layout attributes, `dagre_layout` also implements the attributes from * {@link dc_graph.graphviz_attrs graphviz_attrs} * @class dagre_layout * @memberof dc_graph * @param {String} [id=uuid()] - Unique identifier * @return {dc_graph.dagre_layout} **/ dc_graph.dagre_layout = function(id) { var _layoutId = id || uuid(); var _dagreGraph = null, _tick, _done; var _dispatch = d3.dispatch('tick', 'start', 'end'); // node and edge objects preserved from one iteration // to the next (as long as the object is still in the layout) var _nodes = {}, _edges = {}; function init(options) { // Create a new directed graph _dagreGraph = new dagre.graphlib.Graph({multigraph: true}); // Set an object for the graph label _dagreGraph.setGraph({rankdir: options.rankdir, nodesep: options.nodesep, ranksep: options.ranksep}); // Default to assigning a new object as a label for each new edge. _dagreGraph.setDefaultEdgeLabel(function() { return {}; }); } function data(nodes, edges) { var wnodes = regenerate_objects(_nodes, nodes, null, function(v) { return v.dcg_nodeKey; }, function(v1, v) { v1.dcg_nodeKey = v.dcg_nodeKey; v1.width = v.width; v1.height = v.height; /* dagre does not seem to accept input positions if(v.dcg_nodeFixed) { v1.x = v.dcg_nodeFixed.x; v1.y = v.dcg_nodeFixed.y; } */ }, function(k, o) { _dagreGraph.setNode(k, o); }, function(k) { _dagreGraph.removeNode(k); }); var wedges = regenerate_objects(_edges, edges, null, function(e) { return e.dcg_edgeKey; }, function(e1, e) { e1.dcg_edgeKey = e.dcg_edgeKey; e1.dcg_edgeSource = e.dcg_edgeSource; e1.dcg_edgeTarget = e.dcg_edgeTarget; }, function(k, o, e) { _dagreGraph.setEdge(e.dcg_edgeSource, e.dcg_edgeTarget, o); }, function(k, e) { _dagreGraph.removeEdge(e.dcg_edgeSource, e.dcg_edgeTarget, e.dcg_edgeKey); }); function dispatchState(event) { _dispatch[event]( wnodes, wedges.map(function(e) { return {dcg_edgeKey: e.dcg_edgeKey}; }) ); } _tick = function() { dispatchState('tick'); }; _done = function() { dispatchState('end'); }; } function start(options) { _dispatch.start(); dagre.layout(_dagreGraph); _done(); } function stop() { } var graphviz = dc_graph.graphviz_attrs(), graphviz_keys = Object.keys(graphviz); return Object.assign(graphviz, { layoutAlgorithm: function() { return 'dagre'; }, layoutId: function() { return _layoutId; }, supportsWebworker: function() { return true; }, needsStage: function(stage) { // stopgap until we have engine chaining return stage === 'ports' || stage === 'edgepos'; }, on: function(event, f) { if(arguments.length === 1) return _dispatch.on(event); _dispatch.on(event, f); return this; }, init: function(options) { this.optionNames().forEach(function(option) { options[option] = options[option] || this[option](); }.bind(this)); init(options); return this; }, data: function(graph, nodes, edges) { data(nodes, edges); }, start: function() { start(); }, stop: function() { stop(); }, optionNames: function() { return graphviz_keys; }, populateLayoutNode: function() {}, populateLayoutEdge: function() {} }); }; dc_graph.dagre_layout.scripts = ['d3.js', 'dagre.js']; × Search results Close "},"flat_group.js.html":{"id":"flat_group.js.html","title":"Source: flat_group.js","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Source: flat_group.js /** * `dc_graph.flat_group` implements a special [&quot;fake group&quot;](https://github.com/dc-js/dc.js/wiki/FAQ#fake-groups) * for the special case where you want a group that represents the filtered rows of the crossfilter. * * Although `dc_graph` can be used with reduced data, typically the nodes and edges are just rows of * the corresponding data arrays, and each array has a column which contains the unique identifier * for the node or edge. In this setup, there are other dimensions and groups which are aggregated * for the use of dc.js charts, but the graph just shows or does not show the nodes and edges from * the rows. * * This simple class supports that use case in three steps: * 1. It creates a dimension keyed on the unique identifier (specified to `flat_group.make`) * 2. It creates a group from the dimension with a reduction function that returns the row when the * row is filtered in, and `null` when the row is filtered out. * 3. It wraps the group in a fake group which filters out the resulting nulls. * * The result is a fake group whose `.all()` method returns an array of the currently filtered-in * `{key, value}` pairs, where the key is that returned by the ID accessor, and the value is the raw * row object from the data. * * This could be a useful crossfilter utility outside of dc.graph. For example, bubble charts and * scatter plots often use similar functionality because each observation is either shown or not, * and it is helpful to have the entire row available as reduced data. * * But it would need to be generalized and cleaned up. (For example, the way it has to create the * crossfilter and dimension is kinda dumb.) And there is currently no such crossfilter utility * library to put it in. * * @namespace flat_group * @memberof dc_graph * @type {{}} **/ dc_graph.flat_group = (function() { var reduce_01 = { add: function(p, v) { return v; }, remove: function() { return null; }, init: function() { return null; } }; // now we only really want to see the non-null values, so make a fake group function non_null(group) { return { all: function() { return group.all().filter(function(kv) { return kv.value !== null; }); } }; } function dim_group(ndx, id_accessor) { var dimension = ndx.dimension(id_accessor); return { crossfilter: ndx, dimension: dimension, group: non_null(dimension.group().reduce(reduce_01.add, reduce_01.remove, reduce_01.init)) }; } return { /** * Create a crossfilter, dimension, and flat group, as described in {@link dc_graph.flat_group flat_group}. * Returns an object containing all three. * @method make * @memberof dc_graph.flat_group * @param {Array} vec - the data array for crossfilter * @param {Function} id_accessor - accessor function taking a row object and returning its * unique identifier * @return {Object} `{crossfilter, dimension, group}` **/ make: function(vec, id_accessor) { var ndx = crossfilter(vec); return dim_group(ndx, id_accessor); }, /** * Create a flat dimension and group from an existing crossfilter. * * This is a wretched name for this function. * @method another * @memberof dc_graph.flat_group * @param {Object} ndx - crossfilter instance * @param {Function} id_accessor - accessor function taking a row object and returning its * unique identifier * @return {Object} `{crossfilter, dimension, group}` **/ another: function(ndx, id_accessor) { return dim_group(ndx, id_accessor); } }; })(); × Search results Close "},"graphviz_attrs.js.html":{"id":"graphviz_attrs.js.html","title":"Source: graphviz_attrs.js","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Source: graphviz_attrs.js /** * `dc_graph.graphviz_attrs defines a basic set of attributes which layout engines should * implement - although these are not required, they make it easier for clients and * behaviors (like expand_collapse) to work with multiple layout engines. * * these attributes are {@link http://www.graphviz.org/doc/info/attrs.html from graphviz} * @class graphviz_attrs * @memberof dc_graph * @return {Object} **/ dc_graph.graphviz_attrs = function() { return { /** * Direction to draw ranks. * @method rankdir * @memberof dc_graph.graphviz_attrs * @instance * @param {String} [rankdir='TB'] 'TB', 'LR', 'BT', or 'RL' **/ rankdir: property('TB'), /** * Spacing in between nodes in the same rank. * @method nodesep * @memberof dc_graph.graphviz_attrs * @instance * @param {String} [nodesep=40] **/ nodesep: property(40), /** * Spacing in between ranks. * @method ranksep * @memberof dc_graph.graphviz_attrs * @instance * @param {String} [ranksep=40] **/ ranksep: property(40) }; }; × Search results Close "},"graphviz_layout.js.html":{"id":"graphviz_layout.js.html","title":"Source: graphviz_layout.js","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Source: graphviz_layout.js /** * `dc_graph.graphviz_layout` is an adaptor for viz.js (graphviz) layouts in dc.graph.js * * In addition to the below layout attributes, `graphviz_layout` also implements the attributes from * {@link dc_graph.graphviz_attrs graphviz_attrs} * @class graphviz_layout * @memberof dc_graph * @param {String} [id=uuid()] - Unique identifier * @return {dc_graph.graphviz_layout} **/ dc_graph.graphviz_layout = function(id, layout, server) { var _layoutId = id || uuid(); var _dispatch = d3.dispatch('tick', 'start', 'end'); var _dotInput, _dotString; var _clusters; // hack to get cluster data out function init(options) { } function encode_name(name) { return name.replace(/^%/, '&amp;#37;'); } function decode_name(name) { return name.replace(/^&amp;#37;/, '%'); } function stringize_property(prop, value) { return [prop, '&quot;' + value + '&quot;'].join('='); } function stringize_properties(props) { return '[' + props.join(', ') + ']'; } function data(nodes, edges) { if(_dotInput) { _dotString = _dotInput; return; } var lines = []; var directed = layout !== 'neato'; lines.push((directed ? 'digraph' : 'graph') + ' g {'); lines.push('graph ' + stringize_properties([ stringize_property('nodesep', graphviz.nodesep()/72), stringize_property('ranksep', graphviz.ranksep()/72), stringize_property('rankdir', graphviz.rankdir()) ])); lines = lines.concat(nodes.map(function(v) { var props = [ stringize_property('width', v.width/72), stringize_property('height', v.height/72), stringize_property('fixedsize', 'shape'), stringize_property('shape', v.abstract.shape) ]; if(v.dcg_nodeFixed) props.push(stringize_property('pos', [ v.dcg_nodeFixed.x, 1000-v.dcg_nodeFixed.y ].join(','))); return ' &quot;' + encode_name(v.dcg_nodeKey) + '&quot; ' + stringize_properties(props); })); lines = lines.concat(edges.map(function(e) { return ' &quot;' + encode_name(e.dcg_edgeSource) + (directed ? '&quot; -&gt; &quot;' : '&quot; -- &quot;') + encode_name(e.dcg_edgeTarget) + '&quot; ' + stringize_properties([ stringize_property('id', encode_name(e.dcg_edgeKey)), stringize_property('arrowhead', 'none'), stringize_property('arrowtail', 'none') ]); })); lines.push('}'); lines.push(''); _dotString = lines.join('\\n'); } function process_response(error, result) { _dispatch.start(); var bb = result.bb.split(',').map(function(x) { return +x; }); var nodes = (result.objects || []).filter(function(n) { return n.pos; // remove non-nodes like clusters }).map(function(n) { var pos = n.pos.split(','); return { dcg_nodeKey: decode_name(n.name), x: +pos[0], y: bb[3] - pos[1] }; }); _clusters = (result.objects || []).filter(function(n) { return /^cluster/.test(n.name); }); _clusters.forEach(function(c) { // annotate with flipped cluster coords for convenience c.bbflip = c.bb.split(',').map(function(s) { return +s; }); var t = bb[3] - c.bbflip[1]; c.bbflip[1] = bb[3] - c.bbflip[3]; c.bbflip[3] = t; }); var edges = (result.edges || []).map(function(e) { var e2 = { dcg_edgeKey: decode_name(e.id || 'n' + e._gvid) }; if(e._draw_) { var directive = e._draw_.find(function(d) { return d.op &amp;&amp; d.points; }); e2.points = directive.points.map(function(p) { return {x: p[0], y: bb[3] - p[1]}; }); } return e2; }); _dispatch.end(nodes, edges); } function start() { if(server) { d3.json(server) .header(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;) .post('layouttool=' + layout + '&amp;' + encodeURIComponent(_dotString), process_response); } else { var result = Viz(_dotString, {format: 'json', engine: layout, totalMemory: 1 &lt;&lt; 25}); result = JSON.parse(result); process_response(null, result); } } function stop() { } var graphviz = dc_graph.graphviz_attrs(), graphviz_keys = Object.keys(graphviz); return Object.assign(graphviz, { layoutAlgorithm: function() { return layout; }, layoutId: function() { return _layoutId; }, supportsWebworker: function() { return false; }, on: function(event, f) { if(arguments.length === 1) return _dispatch.on(event); _dispatch.on(event, f); return this; }, init: function(options) { this.optionNames().forEach(function(option) { options[option] = options[option] || this[option](); }.bind(this)); init(options); return this; }, data: function(graph, nodes, edges) { data(nodes, edges); }, dotInput: function(text) { _dotInput = text; return this; }, clusters: function() { // filter out clusters and return them separately, because dc.graph doesn't know how to draw them return _clusters; }, start: function() { start(); }, stop: function() { stop(); }, optionNames: function() { return graphviz_keys; }, populateLayoutNode: function() {}, populateLayoutEdge: function() {} }); } × Search results Close "},"legend.js.html":{"id":"legend.js.html","title":"Source: legend.js","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Source: legend.js /** ## Legend The dc_graph.legend shows labeled examples of nodes &amp; edges, within the frame of a dc_graph.diagram. **/ dc_graph.legend = function(legend_namespace) { legend_namespace = legend_namespace || 'node-legend'; var _items, _included = []; var _dispatch = d3.dispatch('filtered'); var _totals, _counts; function apply_filter() { if(_legend.dimension()) { _legend.dimension().filterFunction(function(k) { return !_included.length || _included.includes(k); }); _legend.parent().redraw(); } } var _legend = dc_graph.behavior(legend_namespace, { add_behavior: redraw, remove_behavior: function() {}, parent: function(p) { if(p) { p .on('render.' + legend_namespace, render) .on('data.' + legend_namespace, on_data); } else { _legend.parent() .on('render.' + legend_namespace, null) .on('data.' + legend_namespace, null); } } }); /** #### .type([value]) Set or get the handler for the specific type of item to be displayed. Default: dc_graph.legend.node_legend() **/ _legend.type = property(dc_graph.legend.node_legend()); /** #### .x([value]) Set or get x coordinate for legend widget. Default: 0. **/ _legend.x = property(0); /** #### .y([value]) Set or get y coordinate for legend widget. Default: 0. **/ _legend.y = property(0); /** #### .gap([value]) Set or get gap between legend items. Default: 5. **/ _legend.gap = property(5); /** #### .itemWidth([value]) Set or get width to reserve for legend item. Default: 30. **/ _legend.itemWidth = _legend.nodeWidth = property(40); /** #### .itemHeight([value]) Set or get height to reserve for legend item. Default: 30. **/ _legend.itemHeight = _legend.nodeHeight = property(40); _legend.omitEmpty = property(false); /** #### .noLabel([value]) Remove item labels, since legend labels are displayed outside of the items. Default: true **/ _legend.noLabel = property(true); _legend.counter = property(null); _legend.replaceFilter = function(filter) { if(filter &amp;&amp; filter.length === 1) _included = filter[0]; else _included = []; return _legend; }; _legend.filters = function() { return _included; }; _legend.on = function(type, f) { _dispatch.on(type, f); return _legend; }; /** #### .exemplars([object]) Specifies an object where the keys are the names of items to add to the legend, and the values are objects which will be passed to the accessors of the attached diagram in order to determine the drawing attributes. Alternately, if the key needs to be specified separately from the name, the function can take an array of {name, key, value} objects. **/ _legend.exemplars = property({}); function on_data(diagram, nodes, wnodes, edges, wedges, ports, wports) { if(_legend.counter()) _counts = _legend.counter()(wnodes.map(get_original), wedges.map(get_original), wports.map(get_original)); } function redraw() { var legend = _legend.parent().svg() .selectAll('g.dc-graph-legend.' + legend_namespace) .data([0]); legend.enter().append('g') .attr('class', 'dc-graph-legend ' + legend_namespace) .attr('transform', 'translate(' + _legend.x() + ',' + _legend.y() + ')'); var items = !_legend.omitEmpty() || !_counts ? _items : _items.filter(function(i) { return _included.length &amp;&amp; !_included.includes(i.orig.key) || _counts[i.orig.key]; }); var item = legend.selectAll(_legend.type().itemSelector()) .data(items, function(n) { return n.name; }); item.exit().remove(); var itemEnter = _legend.type().create(_legend.parent(), item.enter(), _legend.itemWidth(), _legend.itemHeight()); itemEnter.append('text') .attr('dy', '0.3em') .attr('class', 'legend-label'); item .attr('transform', function(n, i) { return 'translate(' + _legend.itemWidth()/2 + ',' + (_legend.itemHeight() + _legend.gap())*(i+0.5) + ')'; }); item.select('text.legend-label') .attr('transform', 'translate(' + (_legend.itemWidth()/2+_legend.gap()) + ',0)') .attr('pointer-events', _legend.dimension() ? 'auto' : 'none') .text(function(d) { return d.name + (_legend.counter() &amp;&amp; _counts ? (' (' + (_counts[d.orig.key] || 0) + (_counts[d.orig.key] !== _totals[d.orig.key] ? '/' + (_totals[d.orig.key] || 0) : '') + ')') : ''); }); _legend.type().draw(_legend.parent(), itemEnter, item); if(_legend.noLabel()) item.selectAll(_legend.type().labelSelector()).remove(); if(_legend.dropdown()) { var caret = item.selectAll('text.dropdown-caret').data(function(x) { return [x]; }); caret .enter().append('text') .attr('dy', '0.3em') .attr('font-size', '75%') .attr('fill', 'blue') .attr('class', 'dropdown-caret') .style('visibility', 'hidden') .html('&amp;emsp;&amp;#x25BC;'); caret .attr('dx', function(d) { return (_legend.itemWidth()/2+_legend.gap()) + getBBoxNoThrow(d3.select(this.parentNode).select('text.legend-label').node()).width; }) .on('mouseenter', function(n) { var rect = this.getBoundingClientRect(); var key = _legend.parent().nodeKey.eval(n); _legend.dropdown() .show(key, rect.x, rect.y); }); item .on('mouseenter', function(d) { if(_counts &amp;&amp; _counts[d.orig.key]) { d3.select(this).selectAll('.dropdown-caret') .style('visibility', 'visible'); } }) .on('mouseleave', function(d) { d3.select(this).selectAll('.dropdown-caret') .style('visibility', 'hidden'); }); } if(_legend.dimension()) { item.attr('cursor', 'pointer') .on('click.legend', function(d) { var key = _legend.parent().nodeKey.eval(d); if(!_included.length) _included = _items.map(_legend.parent().nodeKey.eval); if(_included.includes(key)) _included = _included.filter(function(x) { return x !== key; }); else _included.push(key); apply_filter(); _dispatch.filtered(_legend, key); }); } else { item.attr('cursor', 'auto') .on('click.legend', null); } item.transition().duration(1000) .attr('opacity', function(d) { return (!_included.length || _included.includes(_legend.parent().nodeKey.eval(d))) ? 1 : 0.25; }); }; _legend.countBaseline = function() { if(_legend.counter) _totals = _legend.counter()( _legend.parent().nodeGroup().all(), _legend.parent().edgeGroup().all(), _legend.parent().portGroup() &amp;&amp; _legend.parent().portGroup().all()); }; function render() { var exemplars = _legend.exemplars(); _legend.countBaseline(); if(exemplars instanceof Array) { _items = exemplars.map(function(v) { return {name: v.name, orig: {key: v.key, value: v.value}, cola: {}}; }); } else { _items = []; for(var item in exemplars) _items.push({name: item, orig: {key: item, value: exemplars[item]}, cola: {}}); } redraw(); }; _legend.dropdown = property(null).react(function(v) { if(!!v !== !!_legend.dropdown() &amp;&amp; _legend.parent() &amp;&amp; _legend.parent().svg()) window.setTimeout(_legend.redraw, 0); }); /* enables filtering */ _legend.dimension = property(null) .react(function(v) { if(!v) { _included = []; apply_filter(); } }); return _legend; }; dc_graph.legend.node_legend = function() { return { itemSelector: function() { return '.node'; }, labelSelector: function() { return '.node-label'; }, create: function(diagram, selection) { return selection.append('g') .attr('class', 'node'); }, draw: function(diagram, itemEnter, item) { diagram ._enterNode(itemEnter) ._updateNode(item); } }; }; dc_graph.legend.edge_legend = function() { var _type = { itemSelector: function() { return '.edge-container'; }, labelSelector: function() { return '.edge-label'; }, create: function(diagram, selection, w, h) { var edgeEnter = selection.append('g') .attr('class', 'edge-container') .attr('opacity', 0); edgeEnter .append('rect') .attr({ x: -w/2, y: -h/2, width: w, height: h, fill: 'green', opacity: 0 }); edgeEnter .selectAll('circle') .data([-1, 1]) .enter() .append('circle') .attr({ r: _type.fakeNodeRadius(), fill: 'none', stroke: 'black', &quot;stroke-dasharray&quot;: &quot;4,4&quot;, opacity: 0.15, transform: function(d) { return 'translate(' + [d * _type.length() / 2, 0].join(',') + ')'; } }); var edgex = _type.length()/2 - _type.fakeNodeRadius(); edgeEnter.append('svg:path') .attr({ class: 'edge', id: function(d) { return d.name; }, d: 'M' + -edgex + ',0 L' + edgex + ',0', opacity: diagram.edgeOpacity.eval }); return edgeEnter; }, fakeNodeRadius: property(10), length: property(50), draw: function(diagram, itemEnter, item) { diagram._updateEdge(itemEnter.select('path.edge')); } }; return _type; }; × Search results Close "},"tip.js.html":{"id":"tip.js.html","title":"Source: tip.js","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Source: tip.js /** * Asynchronous [d3.tip](https://github.com/Caged/d3-tip) support for dc.graph.js * * Add tooltips to the nodes and edges of a graph using an asynchronous callback to get * the html to show. * * Optional - requires separately loading the d3.tip script and CSS (which are included in * dc.graph.js in `web/js/d3-tip/index.js` and `web/css/d3-tip/example-styles.css`) * * @class tip * @memberof dc_graph * @return {Object} **/ dc_graph.tip = function(options) { options = options || {}; var _namespace = options.namespace || 'tip'; var _d3tip = null; var _showTimeout, _hideTimeout; var _dispatch = d3.dispatch('tipped'); function init(parent) { if(!_d3tip) { _d3tip = d3.tip() .attr('class', options.class || 'd3-tip') .html(function(d) { return &quot;&lt;span&gt;&quot; + d + &quot;&lt;/span&gt;&quot;; }) .direction(_behavior.direction()); if(_behavior.offset()) _d3tip.offset(_behavior.offset()); parent.svg().call(_d3tip); } } function fetch_and_show_content(d) { if(_behavior.disabled() || _behavior.selection().exclude &amp;&amp; _behavior.selection().exclude(d3.event.target)) { hide_tip.call(this); return; } var target = this, next = function() { _behavior.content()(d, function(content) { _d3tip.show.call(target, content, target); d3.select('div.d3-tip') .selectAll('a.tip-link') .on('click', function() { d3.event.preventDefault(); if(_behavior.linkCallback()) _behavior.linkCallback()(this.id); }); _dispatch.tipped(d); }); }; if(_hideTimeout) window.clearTimeout(_hideTimeout); if(_behavior.delay()) { window.clearTimeout(_showTimeout); _showTimeout = window.setTimeout(next, _behavior.delay()); } else next(); } function check_hide_tip() { if(d3.event.relatedTarget &amp;&amp; (!_behavior.selection().exclude || !_behavior.selection().exclude(d3.event.target)) &amp;&amp; (this &amp;&amp; this.contains(d3.event.relatedTarget) || // do not hide when mouse is still over a child _behavior.clickable() &amp;&amp; d3.event.relatedTarget.classList.contains('d3-tip'))) return false; return true; } function preempt_tip() { if(_showTimeout) { window.clearTimeout(_showTimeout); _showTimeout = null; } } function hide_tip() { if(!check_hide_tip.apply(this)) return; preempt_tip(); _d3tip.hide(); } function hide_tip_delay() { if(!check_hide_tip.apply(this)) return; preempt_tip(); if(_behavior.hideDelay()) _hideTimeout = window.setTimeout(function () { _d3tip.hide(); }, _behavior.hideDelay()); else _d3tip.hide(); } function add_behavior(diagram, node, edge, ehover) { init(diagram); _behavior.programmatic() || _behavior.selection().select(diagram, node, edge, ehover) .on('mouseover.' + _namespace, fetch_and_show_content) .on('mouseout.' + _namespace, hide_tip_delay); if(_behavior.clickable()) { d3.select('div.d3-tip') .on('mouseover.' + _namespace, function() { if(_hideTimeout) window.clearTimeout(_hideTimeout); }) .on('mouseout.' + _namespace, hide_tip_delay); } } function remove_behavior(diagram, node, edge, ehover) { _behavior.programmatic() || _behavior.selection().select(diagram, node, edge, ehover) .on('mouseover.' + _namespace, null) .on('mouseout.' + _namespace, null); } var _behavior = dc_graph.behavior(_namespace, { add_behavior: add_behavior, remove_behavior: remove_behavior, laterDraw: true }); /** * Specify the direction for tooltips. Currently supports the * [cardinal and intercardinal directions](https://en.wikipedia.org/wiki/Points_of_the_compass) supported by * [d3.tip.direction](https://github.com/Caged/d3-tip/blob/master/docs/positioning-tooltips.md#tipdirection): * `'n'`, `'ne'`, `'e'`, etc. * @name direction * @memberof dc_graph.tip * @instance * @param {String} [direction='n'] * @return {String} * @return {dc_graph.tip} * @example * // show all the attributes and values in the node and edge objects * var tip = dc_graph.tip(); * tip.content(tip.table()); **/ _behavior.direction = property('n'); /** * Specifies the function to generate content for the tooltip. This function has the * signature `function(d, k)`, where `d` is the datum of the thing being hovered over, * and `k` is a continuation. The function should fetch the content, asynchronously if * needed, and then pass html forward to `k`. * @name content * @memberof dc_graph.tip * @instance * @param {Function} [content] * @return {Function} * @example * // Default behavior: assume it's a node, show node title * var tip = dc_graph.tip().content(function(n, k) { * k(_behavior.parent() ? _behavior.parent().nodeTitle.eval(n) : ''); * }); **/ _behavior.content = property(function(n, k) { k(_behavior.parent() ? _behavior.parent().nodeTitle.eval(n) : ''); }); _behavior.on = function(event, f) { return _dispatch.on(event, f); }; _behavior.disabled = property(false); _behavior.programmatic = property(false); _behavior.displayTip = function(filter, n, cb) { if(typeof filter !== 'function') { var d = filter; filter = function(d2) { return d2 === d; }; } var found = _behavior.selection().select(_behavior.parent(), _behavior.parent().selectAllNodes(), _behavior.parent().selectAllEdges(), null) .filter(filter); if(found.size() &gt; 0) { var action = fetch_and_show_content; // we need to flatten e.g. for ports, which will have nested selections // .nodes() does this better in D3v4 var flattened = found.reduce(function(p, v) { return p.concat(v); }, []); var which = (n || 0) % flattened.length; action.call(flattened[which], d3.select(flattened[which]).datum()); d = d3.select(flattened[which]).datum(); if(cb) cb(d); if(_behavior.programmatic()) found.on('mouseout', hide_tip_delay); } return _behavior; }; _behavior.hideTip = function(delay) { if(_d3tip) { if(delay) hide_tip_delay(); else hide_tip(); } return _behavior; }; _behavior.selection = property(dc_graph.tip.select_node_and_edge()); _behavior.showDelay = _behavior.delay = property(0); _behavior.hideDelay = property(200); _behavior.offset = property(null); _behavior.clickable = property(false); _behavior.linkCallback = property(null); return _behavior; }; /** * Generates a handler which can be passed to `tip.content` to produce a table of the * attributes and values of the hovered object. * * Note: this interface is not great and is subject to change in the near term. * @name table * @memberof dc_graph.tip * @instance * @return {Function} * @example * // show all the attributes and values in the node and edge objects * var tip = dc_graph.tip(); * tip.content(dc_graph.tip.table()); **/ dc_graph.tip.table = function() { var gen = function(d, k) { d = gen.fetch()(d); var keys = Object.keys(d).filter(d3.functor(gen.filter())) .filter(function(k) { return d[k]; }); var table = d3.select(document.createElement('table')); var rows = table.selectAll('tr').data(keys); var rowsEnter = rows.enter().append('tr'); rowsEnter.append('td').text(function(k) { return k; }); rowsEnter.append('td').text(function(k) { return d[k]; }); k(table.node().outerHTML); // optimizing for clarity over speed (?) }; gen.filter = property(true); gen.fetch = property(function(d) { return d.orig.value; }); return gen; }; dc_graph.tip.select_node_and_edge = function() { return { select: function(diagram, node, edge, ehover) { // hack to merge selections, not supported d3v3 var selection = diagram.selectAll('.foo-this-does-not-exist'); selection[0] = node[0].concat(ehover ? ehover[0] : []); return selection; }, exclude: function(element) { return ancestor_has_class(element, 'port'); } }; }; dc_graph.tip.select_node = function() { return { select: function(diagram, node, edge, ehover) { return node; }, exclude: function(element) { return ancestor_has_class(element, 'port'); } }; }; dc_graph.tip.select_edge = function() { return { select: function(diagram, node, edge, ehover) { return edge; } }; }; dc_graph.tip.select_port = function() { return { select: function(diagram, node, edge, ehover) { return node.selectAll('g.port'); } }; }; × Search results Close "},"tree_layout.js.html":{"id":"tree_layout.js.html","title":"Source: tree_layout.js","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Source: tree_layout.js /** * `dc_graph.tree_layout` is a very simple and not very bright tree layout. It can draw any DAG, but * tries to position the nodes as a tree. * @class tree_layout * @memberof dc_graph * @param {String} [id=uuid()] - Unique identifier * @return {dc_graph.tree_layout} **/ dc_graph.tree_layout = function(id) { var _layoutId = id || uuid(); var _dispatch = d3.dispatch('tick', 'start', 'end'); var _dfs; function init(options) { var x; var nodeWidth = d3.functor(options.nodeWidth); function best_dist(left, right) { return (nodeWidth(left) + nodeWidth(right)) / 2; } _dfs = dc_graph.depth_first_traversal({ nodeid: function(n) { return n.dcg_nodeKey; }, sourceid: function(n) { return n.dcg_edgeSource; }, targetid: function(n) { return n.dcg_edgeTarget; }, init: function() { x = options.offsetX; }, row: function(n) { return n.dcg_rank; }, place: function(n, r, row) { if(row.length) { var left = row[row.length-1]; var g = (nodeWidth(left) + nodeWidth(n)) / 2; x = Math.max(x, left.left_x + g); } n.left_x = x; n.hit_ins = 1; n.y = r*options.gapY + options.offsetY; }, sib: function(isroot, left, right) { var g = best_dist(left, right); if(isroot) g = g*1.5; x += g; }, pop: function(n) { n.x = (n.left_x + x)/2; }, skip: function(n, indegree) { // rolling average of in-neighbor x positions n.x = (n.hit_ins*n.x + x)/++n.hit_ins; if(n.hit_ins === indegree) delete n.hit_ins; }, finish: function(rows) { // this is disgusting. patch up any places where nodes overlap by scanning // right far enough to find the space, then fill from left to right at the // minimum gap rows.forEach(function(row) { var sort = row.sort(function(a, b) { return a.x - b.x; }); var badi = null, badl = null, want; for(var i=0; i&lt;sort.length-1; ++i) { var left = sort[i], right = sort[i+1]; if(!badi) { if(right.x - left.x &lt; best_dist(left, right)) { badi = i; badl = left.x; want = best_dist(left, right); } // else still not bad } else { want += best_dist(left, right); if(i &lt; sort.length - 2 &amp;&amp; right.x &lt; badl + want) continue; // still bad else { if(badi&gt;0) --badi; // might want to use more left var l, limit; if(i &lt; sort.length - 2) { // found space before right var extra = right.x - (badl + want); l = sort[badi].x + extra/2; limit = i+1; } else { l = Math.max(sort[badi].x, badl - best_dist(sort[badi], sort[badi+1]) - (want - right.x + badl)/2); limit = sort.length; } for(var j = badi+1; j&lt;limit; ++j) { l += best_dist(sort[j-1], sort[j]); sort[j].x = l; } badi = badl = want = null; } } } }); } }); } var _nodes, _edges; function data(nodes, edges) { _nodes = nodes; _edges = edges; } function start() { _dfs(_nodes, _edges); _dispatch.end(_nodes, _edges); } function stop() { } var layout = { layoutAlgorithm: function() { return 'tree'; }, layoutId: function() { return _layoutId; }, supportsWebworker: function() { return false; }, on: function(event, f) { if(arguments.length === 1) return _dispatch.on(event); _dispatch.on(event, f); return this; }, init: function(options) { this.optionNames().forEach(function(option) { options[option] = options[option] || this[option](); }.bind(this)); init(options); return this; }, data: function(graph, nodes, edges) { data(nodes, edges); }, start: function() { start(); }, stop: function() { stop(); }, optionNames: function() { return ['nodeWidth', 'offsetX', 'offsetY', 'rowFunction', 'gapY']; }, populateLayoutNode: function(layout, node) { if(this.rowFunction()) layout.dcg_rank = this.rowFunction.eval(node); }, populateLayoutEdge: function() {}, nodeWidth: property(function(n) { return n.width; }), offsetX: property(30), offsetY: property(30), rowFunction: property(null), gapY: property(100) }; return layout; }; dc_graph.tree_layout.scripts = []; × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Classes Classes cola_layout constraint_pattern d3_force_layout d3v4_force_layout dagre_layout diagram graphviz_attrs graphviz_layout tip tree_layout Namespaces dc_graph flat_group × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Namespaces Classes cola_layout constraint_pattern d3_force_layout d3v4_force_layout dagre_layout diagram graphviz_attrs graphviz_layout tip tree_layout Namespaces dc_graph flat_group × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout dc.graph.jsWelcome to the dc.graph.js documentation. × Search results Close "},"dc_graph.html":{"id":"dc_graph.html","title":"Namespace: dc_graph","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Namespace: dc_graph dc_graph The entire dc.graph.js library is scoped under the dc_graph name space. It does not introduce anything else into the global name space. Like in dc.js and most libraries built on d3, most dc_graph functions are designed to allow function chaining, meaning they return the current diagram instance whenever it is appropriate. The getter forms of functions do not participate in function chaining because they return values that are not the diagram. Version: Source: core.js, line 1 Example // Example chaining diagram.width(600) .height(400) .nodeDimension(nodeDim) .nodeGroup(nodeGroup); Classes cola_layout constraint_pattern d3_force_layout d3v4_force_layout dagre_layout diagram graphviz_attrs graphviz_layout tip tree_layout Namespaces flat_group Methods &lt;static&gt; legend() LegendThe dc_graph.legend shows labeled examples of nodes &amp; edges, within the frame of a dc_graph.diagram. Source: legend.js, line 6 × Search results Close "},"dc_graph.cola_layout.html":{"id":"dc_graph.cola_layout.html","title":"Class: cola_layout","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Class: cola_layout dc_graph. cola_layout new cola_layout( [id]) dc_graph.cola_layout is an adaptor for cola.js layouts in dc.graph.js Parameters: Name Type Argument Default Description id String &lt;optional&gt; uuid() Unique identifier Source: cola_layout.js, line 1 Returns: Type dc_graph.cola_layout Methods baseLength( [baseLength]) Gets or sets the default edge length (in pixels) when the .lengthStrategy is 'individual', and the base value to be multiplied for 'symmetric' and 'jaccard' edge lengths. Parameters: Name Type Argument Default Description baseLength Number &lt;optional&gt; 30 Source: cola_layout.js, line 196 Returns: Type Number Type dc_graph.cola_layout flowLayout( [flowLayout]) If flowLayout is set, it determines the axis and separation for cola flow layout. If it is not set, flowLayout will be calculated from the rankdir and ranksep; if rankdir is also null (the default for cola layout), then there will be no flow. Parameters: Name Type Argument Default Description flowLayout Object &lt;optional&gt; null Source: cola_layout.js, line 208 Example // No flow (default) diagram.flowLayout(null) // flow in x with min separation 200 diagram.flowLayout({axis: 'x', minSeparation: 200}) handleDisconnected( [handleDisconnected]) Instructs cola.js to fit the connected components. Parameters: Name Type Argument Default Description handleDisconnected Boolean &lt;optional&gt; true Source: cola_layout.js, line 169 Returns: Type Boolean Type dc_graph.cola_layout lengthStrategy( [lengthStrategy]) Currently, three strategies are supported for specifying the lengths of edges: 'individual' - uses the edgeLength for each edge. If it returns falsy, uses the baseLength 'symmetric', 'jaccard' - compute the edge length based on the graph structure around the edge. See the cola.js wiki for more details. 'none' - no edge lengths will be specified Parameters: Name Type Argument Default Description lengthStrategy function | String &lt;optional&gt; 'symmetric' Source: cola_layout.js, line 179 Returns: Type function | String Type dc_graph.cola_layout × Search results Close "},"dc_graph.constraint_pattern.html":{"id":"dc_graph.constraint_pattern.html","title":"Class: constraint_pattern","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Class: constraint_pattern dc_graph. constraint_pattern new constraint_pattern(diagram, pattern) In cola.js there are three factors which influence the positions of nodes: edge length suggestions, controlled by the lengthStrategy, baseLength, and edgeLength parameters in dc.graph.js automatic constraints based on the global edge flow direction (cola.flowLayout) and overlap avoidance parameters (cola.avoidOverlaps) manual constraints such as alignment, inequality and equality constraints in a dimension/axis. Generally when the cola.js documentation mentions constraints, it means the manual constraints. dc.graph.js allows generation of manual constraints using diagram.constrain but it can be tedious to write these functions because it usually means looping over the nodes and edges multiple times to determine what classes or types of nodes to apply constraints to, and which edges should take additional constraints. This utility creates a constraint generator function from a pattern, a graph where: Nodes represent types or classes of layout nodes, annotated with a specification of how to match the nodes belonging each type. Edges represent rules to generate constraints. There are two kinds of rules: To generate additional constraints on edges besides the built-in ones, create a rules between two different types. The rule will apply to any edges in the layout which match the source and target types, and generate simple &quot;left/right&quot; constraints. (Note that &quot;left&quot; and &quot;right&quot; in this context refer to sides of an inequality constraint left + gap &lt;= right) To generate constraints on a set of nodes, such as alignment, ordering, or circle constraints, create a rule from a type to itself, a self edge. (It is also conceivable to want constraints between individual nodes which don't have edges between them. This is not directly supported at this time; right now the workaround is to create the edge but not draw it, e.g. by setting its #dc_graph.diagram+edgeOpacity to zero. If you have a use-case for this, please file an issue. The pattern syntax is an embedded domain specific language designed to be terse without restricting its power. As such, there are complicated rules for defaulting and inferring parameters from other parameters. Since most users will want the simplest form, this document will start from the highest level and then show how to use more complicated forms in order to gain more control. Then we'll build back up from the ground up and show how inference works. Parameters: Name Type Description diagram dc_graph.diagram the diagram to pull attributes from, mostly to determine the keys of nodes and edge sources and targets pattern Object a graph which defines the constraints to be generated Source: constraint_pattern.js, line 1 Returns: Type function × Search results Close "},"dc_graph.d3_force_layout.html":{"id":"dc_graph.d3_force_layout.html","title":"Class: d3_force_layout","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Class: d3_force_layout dc_graph. d3_force_layout new d3_force_layout( [id]) dc_graph.d3_force_layout is an adaptor for d3-force layouts in dc.graph.js Parameters: Name Type Argument Default Description id String &lt;optional&gt; uuid() Unique identifier Source: d3_force_layout.js, line 1 Returns: Type dc_graph.d3_force_layout × Search results Close "},"dc_graph.d3v4_force_layout.html":{"id":"dc_graph.d3v4_force_layout.html","title":"Class: d3v4_force_layout","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Class: d3v4_force_layout dc_graph. d3v4_force_layout new d3v4_force_layout( [id]) dc_graph.d3v4_force_layout is an adaptor for d3-force version 4 layouts in dc.graph.js Parameters: Name Type Argument Default Description id String &lt;optional&gt; uuid() Unique identifier Source: d3v4_force_layout.js, line 1 Returns: Type dc_graph.d3v4_force_layout × Search results Close "},"dc_graph.dagre_layout.html":{"id":"dc_graph.dagre_layout.html","title":"Class: dagre_layout","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Class: dagre_layout dc_graph. dagre_layout new dagre_layout( [id]) dc_graph.dagre_layout is an adaptor for dagre.js layouts in dc.graph.js In addition to the below layout attributes, dagre_layout also implements the attributes from graphviz_attrs Parameters: Name Type Argument Default Description id String &lt;optional&gt; uuid() Unique identifier Source: dagre_layout.js, line 1 Returns: Type dc_graph.dagre_layout × Search results Close "},"dc_graph.diagram.html":{"id":"dc_graph.diagram.html","title":"Class: diagram","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Class: diagram dc_graph. diagram new diagram(parent [, chartGroup]) dc_graph.diagram is a dc.js-compatible network visualization component. It registers in the dc.js chart registry and its nodes and edges are generated from crossfilter groups. It logically derives from the dc.js baseMixin, but it does not physically derive from it since so much is different about network visualization versus conventional charts. Parameters: Name Type Argument Description parent String | node Any valid d3 single selector specifying a dom block element such as a div; or a dom element. chartGroup String &lt;optional&gt; The name of the dc.js chart group this diagram instance should be placed in. Filter interaction with a diagram will only trigger events and redraws within the diagram's group. Source: diagram.js, line 1 Returns: Type dc_graph.diagram Members &lt;inner&gt; _needsRedraw Standard dc.js baseMixin method. Computes a new layout based on the nodes and edges in the edge groups, and displays the diagram. To the extent possible, the diagram will minimize changes in positions from the previous layout. .render() must be called the first time, and .redraw() can be called after that. .redraw() will be triggered by changes to the filters in any other charts in the same dc.js chart group. Unlike in dc.js, redraw executes asynchronously, because drawing can be computationally intensive, and the diagram will be drawn multiple times if showLayoutSteps is enabled. Watch the 'end' event to know when layout is complete. Source: diagram.js, line 1398 Methods altKeyZoom( [altKeyZoom]) Whether zooming should only be enabled when the alt key is pressed. Parameters: Name Type Argument Default Description altKeyZoom Boolean &lt;optional&gt; true Source: diagram.js, line 205 Returns: Type Boolean Type dc_graph.diagram anchor( [parent] [, chartGroup]) Set the root SVGElement to either be any valid d3 single selector specifying a dom block element such as a div; or a dom element or d3 selection. This class is called internally on diagram initialization, but be called again to relocate the diagram. However, it will orphan any previously created SVGElements. Parameters: Name Type Argument Description parent anchorSelector | anchorNode | d3.selection &lt;optional&gt; chartGroup String &lt;optional&gt; Source: diagram.js, line 3029 Returns: Type String | node | d3.selection Type dc_graph.diagram anchorName() Returns the DOM id for the chart's anchored location. Source: diagram.js, line 3074 Returns: Type String autoZoom( [autoZoom]) Auto-zoom behavior. 'always' - zoom every time layout happens 'once' - zoom the next time layout happens null - manual, call zoomToFit to fit Parameters: Name Type Argument Default Description autoZoom String &lt;optional&gt; null Source: diagram.js, line 251 Returns: Type String Type dc_graph.diagram baseLength( [baseLength]) Gets or sets the default edge length (in pixels) when the .lengthStrategy is 'individual', and the base value to be multiplied for 'symmetric' and 'jaccard' edge lengths. Deprecated: use cola_layout.baseLength instead. Parameters: Name Type Argument Description baseLength Number &lt;optional&gt; Source: diagram.js, line 856 Returns: Type Number Type dc_graph.diagram child( [id] [, object]) Specifies another kind of child layer or interface. For example, this can be used to display tooltips on nodes using dc_graph.tip. The child needs to support a parent method, the diagram to modify. Parameters: Name Type Argument Description id String &lt;optional&gt; the name of the child to modify or add object Object &lt;optional&gt; the child object to add, or null to remove Source: diagram.js, line 1105 Returns: Type dc_graph.diagram Example // Display tooltips on node hover, via the d3-tip library var tip = dc_graph.tip() tip.content(function(n, k) { // you can do an asynchronous call here, e.g. d3.json, if you need // to fetch data to show the tooltip - just call k() with the content k(&quot;This is &lt;em&gt;&quot; + n.orig.value.name + &quot;&lt;/em&gt;&quot;); }); diagram.child('tip', tip); constrain( [constrain]) Gets or sets a function which will be called with the current nodes and edges on each redraw in order to derive new layout constraints. The constraints are built from scratch on each redraw. This can be used to generate alignment (rank) or axis constraints. By default, no constraints will be added, although cola.js uses constraints internally to implement flow and overlap prevention. See the cola.js wiki for more details. For convenience, dc.graph.js implements a other constraints on top of those implemented by cola.js: 'ordering' - the nodes will be ordered on the specified axis according to the keys returned by the ordering function, by creating separation constraints using the specified gap. 'circle' - (experimental) the nodes will be placed in a circle using &quot;wheel&quot; edge lengths similar to those described in href=&quot;http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf&quot;&gt;www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf Scalable, Versatile, and Simple Constrained Graph Layout Although this is not as performant or stable as might be desired, it may work for simple cases. In particular, it should use edge length constraints, which don't yet exist in cola.js. Because it is tedious to write code to generate constraints for a graph, dc.graph.js also includes a constraint generator to produce this constrain function, specifying the constraints themselves in a graph. Parameters: Name Type Argument Description constrain function &lt;optional&gt; Source: diagram.js, line 936 Returns: Type function Type dc_graph.diagram defineArrow(name, width, height, refX, refY, drawf) Creates an svg marker definition for drawing edge arrow tails or heads. The viewBox of the marker is 0 -5 10 10, so the arrow should be drawn from (0, -5) to (10, 5); it will be moved and sized based on the other parameters, and rotated based on the orientation of the edge. (If further customization is required, it is possible to append other svg:defs to diagram.svg() and use refer to them by id.) Parameters: Name Type Description name Number the identifier to give the marker, to be used with edgeArrowhead or edgeArrowtail width Number the width, in pixels, to draw the marker height Number the height, in pixels, to draw the marker refX Number the X reference position, in marker coordinates, which will be aligned to the endpoint of the edge refY Number the Y reference position drawf function a function to draw the marker using d3 SVG primitives, which takes the marker object as its parameter. Source: diagram.js, line 2765 Returns: Type dc_graph.diagram Example // the built-in `vee` arrow is defined like so: _diagram.defineArrow('vee', 12, 12, 10, 0, function(marker) { marker.append('svg:path') .attr('d', 'M0,-5 L10,0 L0,5 L3,0') .attr('stroke-width', '0px'); }); deleteDelay( [deleteDelay]) The delete transition happens simultaneously with layout, which can take longer than the transition duration. Delaying it can bring it closer to the other staged transitions. Parameters: Name Type Argument Default Description deleteDelay Number &lt;optional&gt; 0 Source: diagram.js, line 900 Returns: Type Number Type dc_graph.diagram edgeArrowhead( [edgeArrowhead]) Set or get the function which will be used to retrieve the name of the arrowhead to use for the target/ head/destination of the edge. Arrow symbols can be specified with .defineArrow(). Return null to display no arrowhead. Parameters: Name Type Argument Default Description edgeArrowhead function | String &lt;optional&gt; 'vee' Source: diagram.js, line 725 Returns: Type function | String Type dc_graph.diagram edgeArrowSize( [edgeArrowSize]) Multiplier for arrow size. Parameters: Name Type Argument Default Description edgeArrowSize function | Number &lt;optional&gt; 1 Source: diagram.js, line 751 Returns: Type function | Number Type dc_graph.diagram edgeArrowtail( [edgeArrowtail]) Set or get the function which will be used to retrieve the name of the arrow tail to use for the tail/source of the edge. Arrow symbols can be specified with .defineArrow(). Return null to display no arrowtail. Parameters: Name Type Argument Default Description edgeArrowtail function | String &lt;optional&gt; null Source: diagram.js, line 738 Returns: Type function | String Type dc_graph.diagram edgeDimension( [edgeDimension]) Set or get the crossfilter dimension which represents the edges in the diagram. Typically there will be a crossfilter instance for the nodes, and another for the edges. Dimensions are included on the diagram for similarity to dc.js, however the diagram itself does not use them - but filter_selection will. Parameters: Name Type Argument Description edgeDimension crossfilter.dimension &lt;optional&gt; Source: diagram.js, line 309 Returns: Type crossfilter.dimension Type dc_graph.diagram edgeGroup( [edgeGroup]) Set or get the crossfilter group which is the data source for the edges in the diagram. See .nodeGroup above for the way data is loaded from a crossfilter group. The values in the key/value pairs returned by diagram.edgeGroup().all() need to support, at a minimum, the nodeSource and nodeTarget, which should return the same keys as the nodeKey Parameters: Name Type Argument Description edgeGroup crossfilter.group &lt;optional&gt; Source: diagram.js, line 325 Returns: Type crossfilter.group Type dc_graph.diagram edgeIsLayout( [edgeIsLayout]) To draw an edge but not have it affect the layout, specify a function which returns false for that edge. By default, will return false if the notLayout field of the edge value is truthy, true otherwise. Parameters: Name Type Argument Description edgeIsLayout function | Boolean &lt;optional&gt; Source: diagram.js, line 762 Returns: Type function | Boolean Type dc_graph.diagram Example // Default behavior diagram.edgeIsLayout(function(kv) { return !kv.value.notLayout; }); edgeKey( [edgeKey]) Set or get the function which will be used to retrieve the unique key for each edge. By default, this accesses the key field of the object passed to it. Parameters: Name Type Argument Default Description edgeKey function &lt;optional&gt; function(kv) { return kv.key } Source: diagram.js, line 362 Returns: Type function Type dc_graph.diagram edgeLabel( [edgeLabel]) Set or get the function which will be used to retrieve the edge label text. The label is displayed when an edge is hovered over. By default, uses the edgeKey. Parameters: Name Type Argument Description edgeLabel function | String &lt;optional&gt; Source: diagram.js, line 704 Returns: Type function | String Type dc_graph.diagram Example // Default behavior diagram.edgeLabel(function(e) { return _diagram.edgeKey()(e); }); edgeLength( [edgeLength]) When the .lengthStrategy is 'individual', this accessor will be used to read the length of each edge. By default, reads the distance field of the edge. If the distance is falsy, uses the baseLength. Parameters: Name Type Argument Description edgeLength function | Number &lt;optional&gt; Source: diagram.js, line 807 Returns: Type function | Number Type dc_graph.diagram Example // Default behavior diagram.edgeLength(function(kv) { return kv.value.distance; }); edgeOpacity( [edgeOpacity]) Set or get the function which will be used to retrieve the edge opacity, a number from 0 to 1. Parameters: Name Type Argument Default Description edgeOpacity function | Number &lt;optional&gt; 1 Source: diagram.js, line 692 Returns: Type function | Number Type dc_graph.diagram edgeOrdering( [edgeOrdering]) By default, edges are added to the layout in the order that .edgeGroup().all() returns them. If specified, .edgeOrdering provides an accessor that returns a key to sort the edges on. It would be better not to rely on ordering to affect layout, but it may affect the layout in some cases. (Probably less than node ordering, but it does affect which parallel edge is which.) Parameters: Name Type Argument Default Description edgeOrdering function &lt;optional&gt; null Source: diagram.js, line 985 Returns: Type function Type dc_graph.diagram edgeSource( [edgeSource]) Set or get the function which will be used to retrieve the source (origin/tail) key of the edge objects. The key must equal the key returned by the .nodeKey for one of the nodes; if it does not, or if the node is currently filtered out, the edge will not be displayed. By default, looks for .value.sourcename. Parameters: Name Type Argument Default Description edgeSource function &lt;optional&gt; function(kv) { return kv.value.sourcename; } Source: diagram.js, line 377 Returns: Type function Type dc_graph.diagram edgeStroke( [edgeStroke]) Set or get the function which will be used to retrieve the stroke color for the edges. Parameters: Name Type Argument Default Description edgeStroke function | String &lt;optional&gt; 'black' Source: diagram.js, line 668 Returns: Type function | String Type dc_graph.diagram edgeStrokeWidth( [edgeStrokeWidth]) Set or get the function which will be used to retrieve the stroke width for the edges. Parameters: Name Type Argument Default Description edgeStrokeWidth function | Number &lt;optional&gt; 1 Source: diagram.js, line 679 Returns: Type function | Number Type dc_graph.diagram edgeTarget( [edgeTarget]) Set or get the function which will be used to retrieve the target (destination/head) key of the edge objects. The key must equal the key returned by the nodeKey for one of the nodes; if it does not, or if the node is currently filtered out, the edge will not be displayed. By default, looks for .value.targetname. Parameters: Name Type Argument Default Description edgeTarget function &lt;optional&gt; function(kv) { return kv.value.targetname; } Source: diagram.js, line 394 Returns: Type function Type dc_graph.diagram fitStrategy( [fitStrategy]) Set or get the fitting strategy for the canvas, which affects how the translate and scale get calculated when autoZoom is triggered. 'default' - simulates the preserveAspectRatio behavior of xMidYMid meet, but with margins - the content is stretched or squished in the more constrained direction, and centered in the other direction 'vertical' - fits the canvas vertically (with vertical margins) and centers it horizontally. If the canvas is taller than the viewport, it will meet vertically and there will be blank areas to the left and right. If the canvas is wider than the viewport, it will be sliced. 'horizontal' - fits the canvas horizontally (with horizontal margins) and centers it vertically. If the canvas is wider than the viewport, it will meet horizontally and there will be blank areas above and below. If the canvas is taller than the viewport, it will be sliced. Other options null - no attempt is made to fit the content in the viewport 'zoom' - does not scale the content, but attempts to bring as much content into view as possible, using using the same algorithm as restrictPan 'align_{tlbrc}[2]' - does not scale; aligns up to two sides or centers them Parameters: Name Type Argument Default Description fitStrategy String &lt;optional&gt; 'default' Source: diagram.js, line 216 Returns: Type String Type dc_graph.diagram flowLayout( [flowLayout]) This should be equivalent to rankdir and ranksep in the dagre/graphviz nomenclature, but for now it is separate. Deprecated: use cola_layout.flowLayout instead. Parameters: Name Type Argument Description flowLayout Object &lt;optional&gt; Source: diagram.js, line 827 Example // No flow (default) diagram.flowLayout(null) // flow in x with min separation 200 diagram.flowLayout({axis: 'x', minSeparation: 200}) g( [selection]) Returns the top g element for this specific diagram. This method is usually used to retrieve the g element in order to overlay custom svg drawing programatically. Caution: The root g element is usually generated internally, and resetting it might produce unpredictable results. Parameters: Name Type Argument Description selection d3.selection &lt;optional&gt; Source: diagram.js, line 2692 Returns: Type d3.selection Type dc_graph.diagram getStats() Returns an object with current statistics on graph layout. nnodes - number of nodes displayed nedges - number of edges displayed Source: diagram.js, line 2578 Returns: Type dc_graph.diagram groupConnected( [stageTransitions]) Whether to put connected components each in their own group, to stabilize layout. Parameters: Name Type Argument Default Description stageTransitions String &lt;optional&gt; false Source: diagram.js, line 913 Returns: Type String Type dc_graph.diagram handleDisconnected( [handleDisconnected]) Instructs cola.js to fit the connected components. Deprecated: Use cola_layout.handleDisconnected instead. Parameters: Name Type Argument Default Description handleDisconnected Boolean &lt;optional&gt; true Source: diagram.js, line 1243 Returns: Type Boolean Type dc_graph.diagram height( [height]) Set or get the height attribute of the diagram. If a value is given, then the diagram is returned for method chaining. If no value is given, then the current value of the height attribute will be returned. The width and height are applied to the SVG element generated by the diagram on render, or when resizeSvg is called. If the value is falsy or a function, the height will be calculated the first time it is needed, using the provided function or default height calculator, and then cached. The default calculator uses the client rect of the element specified when constructing the chart, with a minimum of minHeight. A custom calculator will be passed the element. If the value is 'auto', the height will be calculated every time the diagram is drawn, and it will not be set on the &lt;svg&gt; element. Instead, the element will be pinned to the same rectangle as its containing div using CSS. Parameters: Name Type Argument Default Description height Number &lt;optional&gt; 200 Source: diagram.js, line 75 Returns: Type Number Type dc_graph.diagram induceNodes( [induceNodes]) By default, all nodes are included, and edges are only included if both end-nodes are visible. If .induceNodes is set, then only nodes which have at least one edge will be shown. Parameters: Name Type Argument Default Description induceNodes Boolean &lt;optional&gt; false Source: diagram.js, line 1067 Returns: Type Boolean Type dc_graph.diagram initialLayout( [initialLayout]) Function to call to generate an initial layout. Takes (diagram, nodes, edges) Deprecated: The only layout that was using this was tree_positions and it never worked as an initialization step for cola, as was originally intended. Now that tree_layout is a layout algorithm, this should go away. In the future, there will be support for chaining layout algorithms. But that will be a matter of composing them into a super-algorithm, not a special step like this was. Parameters: Name Type Argument Default Description initialLayout function &lt;optional&gt; null Source: diagram.js, line 1047 Returns: Type function Type dc_graph.diagram initLayoutOnRedraw( [initLayoutOnRedraw]) Currently there are some bugs when the same instance of cola.js is used multiple times. (In particular, overlaps between nodes may not be eliminated if cola is not reinitialized This flag can be set true to construct a new cola layout object on each redraw. However, layout seems to be more stable if this is set false, so hopefully this will be fixed soon. Parameters: Name Type Argument Default Description initLayoutOnRedraw Boolean &lt;optional&gt; false Source: diagram.js, line 1006 Returns: Type Boolean Type dc_graph.diagram layoutAlgorithm( [algo]) Specify 'cola' (the default) or 'dagre' as the Layout Algorithm and it will replace the back-end. Deprecated: use diagram.layoutEngine with the engine object instead Parameters: Name Type Argument Default Description algo String &lt;optional&gt; 'cola' the name of the layout algorithm to use Source: diagram.js, line 1136 Returns: Type dc_graph.diagram Example // use dagre for layout diagram.layoutAlgorithm('dagre'); layoutEngine( [engine]) The layout engine determines how to draw things! Parameters: Name Type Argument Default Description engine Object &lt;optional&gt; null the layout engine to use Source: diagram.js, line 1170 Example // use cola with no webworker diagram.layoutEngine(dc_graph.cola_layout()); // use dagre with a webworker diagram.layoutEngine(dc_graph.webworker_layout(dc_graph.dagre_layout())); layoutUnchanged( [layoutUnchanged]) Whether to perform layout when the data is unchanged from the last redraw. Parameters: Name Type Argument Default Description layoutUnchanged Boolean &lt;optional&gt; false Source: diagram.js, line 1022 Returns: Type Boolean Type dc_graph.diagram legend( [legend]) Assigns a legend object which will be displayed within the same SVG element and according to the visual encoding of this diagram. Parameters: Name Type Argument Default Description legend Object &lt;optional&gt; null Source: diagram.js, line 1093 Returns: Type Object Type dc_graph.diagram lengthStrategy( [lengthStrategy]) Currently, three strategies are supported for specifying the lengths of edges: 'individual' - uses the edgeLength for each edge. If it returns falsy, uses the baseLength 'symmetric', 'jaccard' - compute the edge length based on the graph structure around the edge. See the cola.js wiki for more details. 'none' - no edge lengths will be specified Deprecated: Use cola_layout.lengthStrategy instead. Parameters: Name Type Argument Default Description lengthStrategy function | String &lt;optional&gt; 'symmetric' Source: diagram.js, line 787 Returns: Type function | String Type dc_graph.diagram mouseZoomable( [mouseZoomable]) Get or set whether mouse wheel rotation or touchpad gestures will zoom the diagram, and whether dragging on the background pans the diagram. Parameters: Name Type Argument Default Description mouseZoomable Boolean &lt;optional&gt; true Source: diagram.js, line 191 Returns: Type Boolean Type dc_graph.diagram nodeDimension( [nodeDimension]) Set or get the crossfilter dimension which represents the nodes (vertices) in the diagram. Typically there will be a crossfilter instance for the nodes, and another for the edges. Dimensions are included on the diagram for similarity to dc.js, however the diagram itself does not use them - but filter_selection will. Parameters: Name Type Argument Description nodeDimension crossfilter.dimension &lt;optional&gt; Source: diagram.js, line 273 Returns: Type crossfilter.dimension Type dc_graph.diagram nodeFill( [nodeFill]) Set or get the function which will be used to retrieve the fill color for the body of each node. Parameters: Name Type Argument Default Description nodeFill function | String &lt;optional&gt; 'white' Source: diagram.js, line 478 Returns: Type function | String Type dc_graph.diagram nodeFillScale( [nodeFillScale]) If set, the value returned from nodeFill will be processed through this d3.scale to return the fill color. If falsy, uses the identity function (no scale). Parameters: Name Type Argument Description nodeFillScale function | d3.scale &lt;optional&gt; Source: diagram.js, line 465 Returns: Type function | d3.scale Type dc_graph.diagram nodeFitLabel( [nodeFitLabel]) Whether to fit the node shape around the label Parameters: Name Type Argument Default Description nodeFitLabel function | Boolean &lt;optional&gt; true Source: diagram.js, line 570 Returns: Type function | Boolean Type dc_graph.diagram nodeFixed( [nodeFixed]) Specify an accessor that returns an {x,y} coordinate for a node that should be fixed in place, and returns falsy for other nodes. Parameters: Name Type Argument Default Description nodeFixed function | Object &lt;optional&gt; null Source: diagram.js, line 654 Returns: Type function | Object Type dc_graph.diagram nodeGroup( [nodeGroup]) Set or get the crossfilter group which is the data source for the nodes in the diagram. The diagram will use the group's .all() method to get an array of {key, value} pairs, where the key is a unique identifier, and the value is usually an object containing the node's attributes. All accessors work with these key/value pairs. If the group is changed or returns different values, the next call to .redraw() will reflect the changes incrementally. It is possible to pass another object with the same .all() interface instead of a crossfilter group. Parameters: Name Type Argument Description nodeGroup crossfilter.group &lt;optional&gt; Source: diagram.js, line 289 Returns: Type crossfilter.group Type dc_graph.diagram nodeKey( [nodeKey]) Set or get the function which will be used to retrieve the unique key for each node. By default, this accesses the key field of the object passed to it. The keys should match the keys returned by the edgeSource and edgeTarget. Parameters: Name Type Argument Default Description nodeKey function &lt;optional&gt; function(kv) { return kv.key } Source: diagram.js, line 345 Returns: Type function Type dc_graph.diagram nodeLabel( [nodeLabel]) Set or get the function which will be used to retrieve the label text to display in each node. By default, looks for a field label or name inside the value field. Parameters: Name Type Argument Description nodeLabel function | String &lt;optional&gt; Source: diagram.js, line 537 Returns: Type function | String Type dc_graph.diagram Example // Default behavior diagram.nodeLabel(function(kv) { return kv.value.label || kv.value.name; }); nodeLabelFill( [nodeLabelFill]) Set or get the function which will be used to retrieve the label fill color. Default: null Parameters: Name Type Argument Default Description nodeLabelFill function | String &lt;optional&gt; null Source: diagram.js, line 559 Returns: Type function | String Type dc_graph.diagram nodeLabelPadding( [nodeLabelPadding]) Set or get the padding, in pixels, for a node's label. If an object, should contain fields x and y. If a number, will be applied to both x and y. Parameters: Name Type Argument Default Description nodeLabelPadding function | Number | Object &lt;optional&gt; 0 Source: diagram.js, line 514 Returns: Type function | Number Type dc_graph.diagram nodeLineHeight( [nodeLineHeight]) Set or get the line height for nodes with multiple lines of text, in ems. Parameters: Name Type Argument Default Description nodeLineHeight function | Number &lt;optional&gt; 1 Source: diagram.js, line 526 Returns: Type function | Number Type dc_graph.diagram nodeOpacity( [nodeOpacity]) Set or get the function which will be used to retrieve the opacity of each node. Parameters: Name Type Argument Default Description nodeOpacity function | Number &lt;optional&gt; 1 Source: diagram.js, line 490 Returns: Type function | Number Type dc_graph.diagram nodeOrdering( [nodeOrdering]) By default, nodes are added to the layout in the order that .nodeGroup().all() returns them. If specified, .nodeOrdering provides an accessor that returns a key to sort the nodes on. It would be better not to rely on ordering to affect layout, but it may affect the layout in some cases. Parameters: Name Type Argument Default Description nodeOrdering function &lt;optional&gt; null Source: diagram.js, line 640 Returns: Type function Type dc_graph.diagram nodePadding( [nodePadding]) Set or get the padding or minimum distance, in pixels, for a node. (Will be distributed to both sides of the node.) Parameters: Name Type Argument Default Description nodePadding function | Number &lt;optional&gt; 6 Source: diagram.js, line 501 Returns: Type function | Number Type dc_graph.diagram nodeRadius( [nodeRadius]) Set or get the function which will be used to retrieve the radius, in pixels, for each node. This determines the height of nodes,and if nodeFitLabel is false, the width too. Parameters: Name Type Argument Default Description nodeRadius function | Number &lt;optional&gt; 25 Source: diagram.js, line 426 Returns: Type function | Number Type dc_graph.diagram nodeShape( [nodeShape]) The shape to use for drawing each node, specified as an object with at least the field shape. The names of shapes are mostly taken from graphviz; currently ellipse, egg, triangle, rectangle, diamond, trapezium, parallelogram, pentagon, hexagon, septagon, octagon, invtriangle, invtrapezium, square, polygon are supported. If shape = polygon: sides: number of sides for a polygon Parameters: Name Type Argument Default Description nodeShape function | Object &lt;optional&gt; {shape: 'ellipse'} Source: diagram.js, line 581 Returns: Type function | Object Type dc_graph.diagram Example // set shape to diamond or parallelogram based on flag diagram.nodeShape(function(kv) { return {shape: kv.value.flag ? 'diamond' : 'parallelogram'}; }); nodeStroke( [nodeStroke]) Set or get the function which will be used to retrieve the stroke color for the outline of each node. Parameters: Name Type Argument Default Description nodeStroke function | String &lt;optional&gt; 'black' Source: diagram.js, line 451 Returns: Type function | String Type dc_graph.diagram nodeStrokeWidth( [nodeStrokeWidth]) Set or get the function which will be used to retrieve the stroke width, in pixels, for drawing the outline of each node. According to the SVG specification, the outline will be drawn half on top of the fill, and half outside. Default: 1 Parameters: Name Type Argument Default Description nodeStrokeWidth function | Number &lt;optional&gt; 1 Source: diagram.js, line 438 Returns: Type function | Number Type dc_graph.diagram nodeTitle( [nodeTitle]) Set or get the function which will be used to retrieve the node title, usually rendered as a tooltip. By default, uses the key of the node. Parameters: Name Type Argument Description nodeTitle function | String &lt;optional&gt; Source: diagram.js, line 621 Returns: Type function | String Type dc_graph.diagram Example // Default behavior diagram.nodeTitle(function(kv) { return _diagram.nodeKey()(kv); }); on( [event] [, f]) Standard dc.js baseMixin method. Attaches an event handler to the diagram. The currently supported events are start() - layout is starting drawn(nodes, edges) - the node and edge elements have been rendered to the screen and can be modified through the passed d3 selections. end() - diagram layout has completed. Parameters: Name Type Argument Description event String &lt;optional&gt; the event to subscribe to f function &lt;optional&gt; the event handler Source: diagram.js, line 2556 Returns: Type dc_graph.diagram parallelEdgeOffset( [parallelEdgeOffset]) If there are multiple edges between the same two nodes, start them this many pixels away from the original so they don't overlap. Parameters: Name Type Argument Default Description parallelEdgeOffset Number &lt;optional&gt; 10 Source: diagram.js, line 973 Returns: Type Number Type dc_graph.diagram rankdir( [rankdir]) Direction to draw ranks. Currently for dagre and expand_collapse, but I think cola could be generated from graphviz-style since it is more general. Deprecated: use dagre_layout.rankdir instead. Parameters: Name Type Argument Description rankdir String &lt;optional&gt; Source: diagram.js, line 844 redrawGroup() Standard dc.js baseMixin method. Causes all charts in the chart group to be redrawn. Source: diagram.js, line 2739 Returns: Type dc_graph.diagram relayout() When layoutUnchanged is false, this will force layout to happen again. This may be needed when changing a parameter but not changing the topology of the graph. (Yes, probably should not be necessary.) Source: diagram.js, line 1033 Returns: Type dc_graph.diagram render() Standard dc.js baseMixin method. Erases any existing SVG elements and draws the diagram from scratch. .render() must be called the first time, and .redraw() can be called after that. Source: diagram.js, line 2523 Returns: Type dc_graph.diagram renderGroup() Standard dc.js baseMixin method. Causes all charts in the chart group to be rendered. Source: diagram.js, line 2752 Returns: Type dc_graph.diagram resetSvg() Standard dc.js baseMixin method. Remove the diagram's SVG elements from the dom and recreate the container SVG element. Source: diagram.js, line 2720 Returns: Type dc_graph.diagram root( [root]) Get or set the root element, which is usually the parent div. Normally the root is set when the diagram is constructed; setting it later may have unexpected consequences. Parameters: Name Type Argument Default Description root node &lt;optional&gt; null Source: diagram.js, line 176 Returns: Type node Type dc_graph.diagram select( [selector]) Standard dc.js baseMixin method. Execute a d3 single selection in the diagram's scope using the given selector and return the d3 selection. Roughly the same as d3.select('#diagram-id').select(selector)Since this function returns a d3 selection, it is not chainable. (However, d3 selection calls can be chained after it.) Parameters: Name Type Argument Description selector String &lt;optional&gt; Source: diagram.js, line 2593 Returns: Type d3.selection Type dc_graph.diagram selectAll( [selector]) Standard dc.js baseMixin method. Selects all elements that match the d3 single selector in the diagram's scope, and return the d3 selection. Roughly the same as d3.select('#diagram-id').selectAll(selector)Since this function returns a d3 selection, it is not chainable. (However, d3 selection calls can be chained after it.) Parameters: Name Type Argument Description selector String &lt;optional&gt; Source: diagram.js, line 2614 Returns: Type d3.selection Type dc_graph.diagram showLayoutSteps( [showLayoutSteps]) If this flag is true, the positions of nodes and will be updated while layout is iterating. If false, the positions will only be updated once layout has stabilized. Note: this may not be compatible with transitionDuration. Parameters: Name Type Argument Default Description showLayoutSteps Boolean &lt;optional&gt; false Source: diagram.js, line 1080 Returns: Type Boolean Type dc_graph.diagram stageTransitions( [stageTransitions]) How transitions should be split into separate animations to emphasize the delete, modify, and insert operations: none: modify and insert operations animate at the same time modins: modify operations happen before inserts insmod: insert operations happen before modifies Deletions always happen before/during layout computation. Parameters: Name Type Argument Default Description stageTransitions String &lt;optional&gt; 'none' Source: diagram.js, line 883 Returns: Type String Type dc_graph.diagram svg( [selection]) Standard dc.js baseMixin method. Returns the top svg element for this specific diagram. You can also pass in a new svg element, but setting the svg element on a diagram may have unexpected consequences. Parameters: Name Type Argument Description selection d3.selection &lt;optional&gt; Source: diagram.js, line 2672 Returns: Type d3.selection Type dc_graph.diagram timeLimit( [timeLimit]) Gets or sets the maximum time spent doing layout for a render or redraw. Set to 0 for no limit. Parameters: Name Type Argument Default Description timeLimit function | Number &lt;optional&gt; 0 Source: diagram.js, line 924 Returns: Type function | Number Type dc_graph.diagram transitionDuration( [transitionDuration]) Gets or sets the transition duration, the length of time each change to the diagram will be animated. Parameters: Name Type Argument Default Description transitionDuration Number &lt;optional&gt; 500 Source: diagram.js, line 871 Returns: Type Number Type dc_graph.diagram width( [width]) Set or get the width attribute of the diagram. If a value is given, then the diagram is returned for method chaining. If no value is given, then the current value of the width attribute will be returned. The width and height are applied to the SVG element generated by the diagram on render, or when resizeSvg is called. If the value is falsy or a function, the width will be calculated the first time it is needed, using the provided function or default width calculator, and then cached. The default calculator uses the client rect of the element specified when constructing the chart, with a minimum of minWidth. A custom calculator will be passed the element. If the value is 'auto', the width will be calculated every time the diagram is drawn, and it will not be set on the &lt;svg&gt; element. Instead, the element will be pinned to the same rectangle as its containing div using CSS. Parameters: Name Type Argument Default Description width Number &lt;optional&gt; 200 Source: diagram.js, line 125 Returns: Type Number Type dc_graph.diagram x( [scale]) Standard dc.js baseMixin method. Gets or sets the x scale. Parameters: Name Type Argument Description scale d3.scale &lt;optional&gt; Source: diagram.js, line 2637 Returns: Type d3.scale Type dc_graph.diagram x( [scale]) Standard dc.js baseMixin method. Gets or sets the y scale. Parameters: Name Type Argument Description scale d3.scale &lt;optional&gt; Source: diagram.js, line 2651 Returns: Type d3.scale Type dc_graph.diagram × Search results Close "},"dc_graph.flat_group.html":{"id":"dc_graph.flat_group.html","title":"Namespace: flat_group","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Namespace: flat_group dc_graph. flat_group dc_graph.flat_group implements a special &quot;fake group&quot; for the special case where you want a group that represents the filtered rows of the crossfilter. Although dc_graph can be used with reduced data, typically the nodes and edges are just rows of the corresponding data arrays, and each array has a column which contains the unique identifier for the node or edge. In this setup, there are other dimensions and groups which are aggregated for the use of dc.js charts, but the graph just shows or does not show the nodes and edges from the rows. This simple class supports that use case in three steps: It creates a dimension keyed on the unique identifier (specified to flat_group.make) It creates a group from the dimension with a reduction function that returns the row when the row is filtered in, and null when the row is filtered out. It wraps the group in a fake group which filters out the resulting nulls. The result is a fake group whose .all() method returns an array of the currently filtered-in {key, value} pairs, where the key is that returned by the ID accessor, and the value is the raw row object from the data. This could be a useful crossfilter utility outside of dc.graph. For example, bubble charts and scatter plots often use similar functionality because each observation is either shown or not, and it is helpful to have the entire row available as reduced data. But it would need to be generalized and cleaned up. (For example, the way it has to create the crossfilter and dimension is kinda dumb.) And there is currently no such crossfilter utility library to put it in. Source: flat_group.js, line 1 Methods &lt;static&gt; another(ndx, id_accessor) Create a flat dimension and group from an existing crossfilter. This is a wretched name for this function. Parameters: Name Type Description ndx Object crossfilter instance id_accessor function accessor function taking a row object and returning its unique identifier Source: flat_group.js, line 78 Returns: {crossfilter, dimension, group} Type Object &lt;static&gt; make(vec, id_accessor) Create a crossfilter, dimension, and flat group, as described in flat_group. Returns an object containing all three. Parameters: Name Type Description vec Array the data array for crossfilter id_accessor function accessor function taking a row object and returning its unique identifier Source: flat_group.js, line 63 Returns: {crossfilter, dimension, group} Type Object × Search results Close "},"dc_graph.graphviz_attrs.html":{"id":"dc_graph.graphviz_attrs.html","title":"Class: graphviz_attrs","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Class: graphviz_attrs dc_graph. graphviz_attrs new graphviz_attrs() `dc_graph.graphviz_attrs defines a basic set of attributes which layout engines should implement - although these are not required, they make it easier for clients and behaviors (like expand_collapse) to work with multiple layout engines. these attributes are href=&quot;http://www.graphviz.org/doc/info/attrs.html&quot;&gt;www.graphviz.org/doc/info/attrs.html from graphviz Source: graphviz_attrs.js, line 1 Returns: Type Object Methods nodesep( [nodesep]) Spacing in between nodes in the same rank. Parameters: Name Type Argument Default Description nodesep String &lt;optional&gt; 40 Source: graphviz_attrs.js, line 21 rankdir( [rankdir]) Direction to draw ranks. Parameters: Name Type Argument Default Description rankdir String &lt;optional&gt; 'TB' 'TB', 'LR', 'BT', or 'RL' Source: graphviz_attrs.js, line 13 ranksep( [ranksep]) Spacing in between ranks. Parameters: Name Type Argument Default Description ranksep String &lt;optional&gt; 40 Source: graphviz_attrs.js, line 29 × Search results Close "},"dc_graph.graphviz_layout.html":{"id":"dc_graph.graphviz_layout.html","title":"Class: graphviz_layout","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Class: graphviz_layout dc_graph. graphviz_layout new graphviz_layout( [id]) dc_graph.graphviz_layout is an adaptor for viz.js (graphviz) layouts in dc.graph.js In addition to the below layout attributes, graphviz_layout also implements the attributes from graphviz_attrs Parameters: Name Type Argument Default Description id String &lt;optional&gt; uuid() Unique identifier Source: graphviz_layout.js, line 1 Returns: Type dc_graph.graphviz_layout × Search results Close "},"dc_graph.tip.html":{"id":"dc_graph.tip.html","title":"Class: tip","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Class: tip dc_graph. tip new tip() Asynchronous d3.tip support for dc.graph.js Add tooltips to the nodes and edges of a graph using an asynchronous callback to get the html to show. Optional - requires separately loading the d3.tip script and CSS (which are included in dc.graph.js in web/js/d3-tip/index.js and web/css/d3-tip/example-styles.css) Source: tip.js, line 1 Returns: Type Object Members content Specifies the function to generate content for the tooltip. This function has the signature function(d, k), where d is the datum of the thing being hovered over, and k is a continuation. The function should fetch the content, asynchronously if needed, and then pass html forward to k. Source: tip.js, line 138 Example // Default behavior: assume it's a node, show node title var tip = dc_graph.tip().content(function(n, k) { k(_behavior.parent() ? _behavior.parent().nodeTitle.eval(n) : ''); }); direction Specify the direction for tooltips. Currently supports the cardinal and intercardinal directions supported by d3.tip.direction: 'n', 'ne', 'e', etc. Source: tip.js, line 120 Example // show all the attributes and values in the node and edge objects var tip = dc_graph.tip(); tip.content(tip.table()); table Generates a handler which can be passed to tip.content to produce a table of the attributes and values of the hovered object. Note: this interface is not great and is subject to change in the near term. Source: tip.js, line 209 Example // show all the attributes and values in the node and edge objects var tip = dc_graph.tip(); tip.content(dc_graph.tip.table()); × Search results Close "},"dc_graph.tree_layout.html":{"id":"dc_graph.tree_layout.html","title":"Class: tree_layout","body":" dc.graph.js Namespaces dc_graphdc_graph.flat_group Classes dc_graph.cola_layoutdc_graph.constraint_patterndc_graph.d3_force_layoutdc_graph.d3v4_force_layoutdc_graph.dagre_layoutdc_graph.diagramdc_graph.graphviz_attrsdc_graph.graphviz_layoutdc_graph.tipdc_graph.tree_layout Class: tree_layout dc_graph. tree_layout new tree_layout( [id]) dc_graph.tree_layout is a very simple and not very bright tree layout. It can draw any DAG, but tries to position the nodes as a tree. Parameters: Name Type Argument Default Description id String &lt;optional&gt; uuid() Unique identifier Source: tree_layout.js, line 1 Returns: Type dc_graph.tree_layout × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
